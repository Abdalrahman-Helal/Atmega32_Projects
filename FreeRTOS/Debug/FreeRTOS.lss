
FreeRTOS.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00004568  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         0000001a  00800060  00004568  000045fc  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          0000067d  0080007a  0080007a  00004616  2**0
                  ALLOC
  3 .stab         00005820  00000000  00000000  00004618  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      000035fa  00000000  00000000  00009e38  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 00000140  00000000  00000000  0000d432  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_pubnames 00000170  00000000  00000000  0000d572  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   00001c49  00000000  00000000  0000d6e2  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 00000eeb  00000000  00000000  0000f32b  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   00000dad  00000000  00000000  00010216  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  00000160  00000000  00000000  00010fc4  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    0000028d  00000000  00000000  00011124  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    000007ce  00000000  00000000  000113b1  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00000050  00000000  00000000  00011b7f  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 ac 16 	jmp	0x2d58	; 0x2d58 <__vector_7>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	10 e0       	ldi	r17, 0x00	; 0
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	e8 e6       	ldi	r30, 0x68	; 104
      68:	f5 e4       	ldi	r31, 0x45	; 69
      6a:	02 c0       	rjmp	.+4      	; 0x70 <.do_copy_data_start>

0000006c <.do_copy_data_loop>:
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0

00000070 <.do_copy_data_start>:
      70:	aa 37       	cpi	r26, 0x7A	; 122
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <.do_copy_data_loop>

00000076 <__do_clear_bss>:
      76:	16 e0       	ldi	r17, 0x06	; 6
      78:	aa e7       	ldi	r26, 0x7A	; 122
      7a:	b0 e0       	ldi	r27, 0x00	; 0
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	a7 3f       	cpi	r26, 0xF7	; 247
      82:	b1 07       	cpc	r27, r17
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 51 0e 	call	0x1ca2	; 0x1ca2 <main>
      8a:	0c 94 b2 22 	jmp	0x4564	; 0x4564 <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <__fixunssfsi>:
      92:	ef 92       	push	r14
      94:	ff 92       	push	r15
      96:	0f 93       	push	r16
      98:	1f 93       	push	r17
      9a:	7b 01       	movw	r14, r22
      9c:	8c 01       	movw	r16, r24
      9e:	20 e0       	ldi	r18, 0x00	; 0
      a0:	30 e0       	ldi	r19, 0x00	; 0
      a2:	40 e0       	ldi	r20, 0x00	; 0
      a4:	5f e4       	ldi	r21, 0x4F	; 79
      a6:	0e 94 49 03 	call	0x692	; 0x692 <__gesf2>
      aa:	88 23       	and	r24, r24
      ac:	8c f0       	brlt	.+34     	; 0xd0 <__fixunssfsi+0x3e>
      ae:	c8 01       	movw	r24, r16
      b0:	b7 01       	movw	r22, r14
      b2:	20 e0       	ldi	r18, 0x00	; 0
      b4:	30 e0       	ldi	r19, 0x00	; 0
      b6:	40 e0       	ldi	r20, 0x00	; 0
      b8:	5f e4       	ldi	r21, 0x4F	; 79
      ba:	0e 94 c1 01 	call	0x382	; 0x382 <__subsf3>
      be:	0e 94 a9 03 	call	0x752	; 0x752 <__fixsfsi>
      c2:	9b 01       	movw	r18, r22
      c4:	ac 01       	movw	r20, r24
      c6:	20 50       	subi	r18, 0x00	; 0
      c8:	30 40       	sbci	r19, 0x00	; 0
      ca:	40 40       	sbci	r20, 0x00	; 0
      cc:	50 48       	sbci	r21, 0x80	; 128
      ce:	06 c0       	rjmp	.+12     	; 0xdc <__fixunssfsi+0x4a>
      d0:	c8 01       	movw	r24, r16
      d2:	b7 01       	movw	r22, r14
      d4:	0e 94 a9 03 	call	0x752	; 0x752 <__fixsfsi>
      d8:	9b 01       	movw	r18, r22
      da:	ac 01       	movw	r20, r24
      dc:	b9 01       	movw	r22, r18
      de:	ca 01       	movw	r24, r20
      e0:	1f 91       	pop	r17
      e2:	0f 91       	pop	r16
      e4:	ff 90       	pop	r15
      e6:	ef 90       	pop	r14
      e8:	08 95       	ret

000000ea <_fpadd_parts>:
      ea:	a0 e0       	ldi	r26, 0x00	; 0
      ec:	b0 e0       	ldi	r27, 0x00	; 0
      ee:	eb e7       	ldi	r30, 0x7B	; 123
      f0:	f0 e0       	ldi	r31, 0x00	; 0
      f2:	0c 94 5c 22 	jmp	0x44b8	; 0x44b8 <__prologue_saves__>
      f6:	dc 01       	movw	r26, r24
      f8:	2b 01       	movw	r4, r22
      fa:	fa 01       	movw	r30, r20
      fc:	9c 91       	ld	r25, X
      fe:	92 30       	cpi	r25, 0x02	; 2
     100:	08 f4       	brcc	.+2      	; 0x104 <_fpadd_parts+0x1a>
     102:	39 c1       	rjmp	.+626    	; 0x376 <_fpadd_parts+0x28c>
     104:	eb 01       	movw	r28, r22
     106:	88 81       	ld	r24, Y
     108:	82 30       	cpi	r24, 0x02	; 2
     10a:	08 f4       	brcc	.+2      	; 0x10e <_fpadd_parts+0x24>
     10c:	33 c1       	rjmp	.+614    	; 0x374 <_fpadd_parts+0x28a>
     10e:	94 30       	cpi	r25, 0x04	; 4
     110:	69 f4       	brne	.+26     	; 0x12c <_fpadd_parts+0x42>
     112:	84 30       	cpi	r24, 0x04	; 4
     114:	09 f0       	breq	.+2      	; 0x118 <_fpadd_parts+0x2e>
     116:	2f c1       	rjmp	.+606    	; 0x376 <_fpadd_parts+0x28c>
     118:	11 96       	adiw	r26, 0x01	; 1
     11a:	9c 91       	ld	r25, X
     11c:	11 97       	sbiw	r26, 0x01	; 1
     11e:	89 81       	ldd	r24, Y+1	; 0x01
     120:	98 17       	cp	r25, r24
     122:	09 f4       	brne	.+2      	; 0x126 <_fpadd_parts+0x3c>
     124:	28 c1       	rjmp	.+592    	; 0x376 <_fpadd_parts+0x28c>
     126:	af e6       	ldi	r26, 0x6F	; 111
     128:	b0 e0       	ldi	r27, 0x00	; 0
     12a:	25 c1       	rjmp	.+586    	; 0x376 <_fpadd_parts+0x28c>
     12c:	84 30       	cpi	r24, 0x04	; 4
     12e:	09 f4       	brne	.+2      	; 0x132 <_fpadd_parts+0x48>
     130:	21 c1       	rjmp	.+578    	; 0x374 <_fpadd_parts+0x28a>
     132:	82 30       	cpi	r24, 0x02	; 2
     134:	a9 f4       	brne	.+42     	; 0x160 <_fpadd_parts+0x76>
     136:	92 30       	cpi	r25, 0x02	; 2
     138:	09 f0       	breq	.+2      	; 0x13c <_fpadd_parts+0x52>
     13a:	1d c1       	rjmp	.+570    	; 0x376 <_fpadd_parts+0x28c>
     13c:	9a 01       	movw	r18, r20
     13e:	ad 01       	movw	r20, r26
     140:	88 e0       	ldi	r24, 0x08	; 8
     142:	ea 01       	movw	r28, r20
     144:	09 90       	ld	r0, Y+
     146:	ae 01       	movw	r20, r28
     148:	e9 01       	movw	r28, r18
     14a:	09 92       	st	Y+, r0
     14c:	9e 01       	movw	r18, r28
     14e:	81 50       	subi	r24, 0x01	; 1
     150:	c1 f7       	brne	.-16     	; 0x142 <_fpadd_parts+0x58>
     152:	e2 01       	movw	r28, r4
     154:	89 81       	ldd	r24, Y+1	; 0x01
     156:	11 96       	adiw	r26, 0x01	; 1
     158:	9c 91       	ld	r25, X
     15a:	89 23       	and	r24, r25
     15c:	81 83       	std	Z+1, r24	; 0x01
     15e:	08 c1       	rjmp	.+528    	; 0x370 <_fpadd_parts+0x286>
     160:	92 30       	cpi	r25, 0x02	; 2
     162:	09 f4       	brne	.+2      	; 0x166 <_fpadd_parts+0x7c>
     164:	07 c1       	rjmp	.+526    	; 0x374 <_fpadd_parts+0x28a>
     166:	12 96       	adiw	r26, 0x02	; 2
     168:	2d 90       	ld	r2, X+
     16a:	3c 90       	ld	r3, X
     16c:	13 97       	sbiw	r26, 0x03	; 3
     16e:	eb 01       	movw	r28, r22
     170:	8a 81       	ldd	r24, Y+2	; 0x02
     172:	9b 81       	ldd	r25, Y+3	; 0x03
     174:	14 96       	adiw	r26, 0x04	; 4
     176:	ad 90       	ld	r10, X+
     178:	bd 90       	ld	r11, X+
     17a:	cd 90       	ld	r12, X+
     17c:	dc 90       	ld	r13, X
     17e:	17 97       	sbiw	r26, 0x07	; 7
     180:	ec 80       	ldd	r14, Y+4	; 0x04
     182:	fd 80       	ldd	r15, Y+5	; 0x05
     184:	0e 81       	ldd	r16, Y+6	; 0x06
     186:	1f 81       	ldd	r17, Y+7	; 0x07
     188:	91 01       	movw	r18, r2
     18a:	28 1b       	sub	r18, r24
     18c:	39 0b       	sbc	r19, r25
     18e:	b9 01       	movw	r22, r18
     190:	37 ff       	sbrs	r19, 7
     192:	04 c0       	rjmp	.+8      	; 0x19c <_fpadd_parts+0xb2>
     194:	66 27       	eor	r22, r22
     196:	77 27       	eor	r23, r23
     198:	62 1b       	sub	r22, r18
     19a:	73 0b       	sbc	r23, r19
     19c:	60 32       	cpi	r22, 0x20	; 32
     19e:	71 05       	cpc	r23, r1
     1a0:	0c f0       	brlt	.+2      	; 0x1a4 <_fpadd_parts+0xba>
     1a2:	61 c0       	rjmp	.+194    	; 0x266 <_fpadd_parts+0x17c>
     1a4:	12 16       	cp	r1, r18
     1a6:	13 06       	cpc	r1, r19
     1a8:	6c f5       	brge	.+90     	; 0x204 <_fpadd_parts+0x11a>
     1aa:	37 01       	movw	r6, r14
     1ac:	48 01       	movw	r8, r16
     1ae:	06 2e       	mov	r0, r22
     1b0:	04 c0       	rjmp	.+8      	; 0x1ba <_fpadd_parts+0xd0>
     1b2:	96 94       	lsr	r9
     1b4:	87 94       	ror	r8
     1b6:	77 94       	ror	r7
     1b8:	67 94       	ror	r6
     1ba:	0a 94       	dec	r0
     1bc:	d2 f7       	brpl	.-12     	; 0x1b2 <_fpadd_parts+0xc8>
     1be:	21 e0       	ldi	r18, 0x01	; 1
     1c0:	30 e0       	ldi	r19, 0x00	; 0
     1c2:	40 e0       	ldi	r20, 0x00	; 0
     1c4:	50 e0       	ldi	r21, 0x00	; 0
     1c6:	04 c0       	rjmp	.+8      	; 0x1d0 <_fpadd_parts+0xe6>
     1c8:	22 0f       	add	r18, r18
     1ca:	33 1f       	adc	r19, r19
     1cc:	44 1f       	adc	r20, r20
     1ce:	55 1f       	adc	r21, r21
     1d0:	6a 95       	dec	r22
     1d2:	d2 f7       	brpl	.-12     	; 0x1c8 <_fpadd_parts+0xde>
     1d4:	21 50       	subi	r18, 0x01	; 1
     1d6:	30 40       	sbci	r19, 0x00	; 0
     1d8:	40 40       	sbci	r20, 0x00	; 0
     1da:	50 40       	sbci	r21, 0x00	; 0
     1dc:	2e 21       	and	r18, r14
     1de:	3f 21       	and	r19, r15
     1e0:	40 23       	and	r20, r16
     1e2:	51 23       	and	r21, r17
     1e4:	21 15       	cp	r18, r1
     1e6:	31 05       	cpc	r19, r1
     1e8:	41 05       	cpc	r20, r1
     1ea:	51 05       	cpc	r21, r1
     1ec:	21 f0       	breq	.+8      	; 0x1f6 <_fpadd_parts+0x10c>
     1ee:	21 e0       	ldi	r18, 0x01	; 1
     1f0:	30 e0       	ldi	r19, 0x00	; 0
     1f2:	40 e0       	ldi	r20, 0x00	; 0
     1f4:	50 e0       	ldi	r21, 0x00	; 0
     1f6:	79 01       	movw	r14, r18
     1f8:	8a 01       	movw	r16, r20
     1fa:	e6 28       	or	r14, r6
     1fc:	f7 28       	or	r15, r7
     1fe:	08 29       	or	r16, r8
     200:	19 29       	or	r17, r9
     202:	3c c0       	rjmp	.+120    	; 0x27c <_fpadd_parts+0x192>
     204:	23 2b       	or	r18, r19
     206:	d1 f1       	breq	.+116    	; 0x27c <_fpadd_parts+0x192>
     208:	26 0e       	add	r2, r22
     20a:	37 1e       	adc	r3, r23
     20c:	35 01       	movw	r6, r10
     20e:	46 01       	movw	r8, r12
     210:	06 2e       	mov	r0, r22
     212:	04 c0       	rjmp	.+8      	; 0x21c <_fpadd_parts+0x132>
     214:	96 94       	lsr	r9
     216:	87 94       	ror	r8
     218:	77 94       	ror	r7
     21a:	67 94       	ror	r6
     21c:	0a 94       	dec	r0
     21e:	d2 f7       	brpl	.-12     	; 0x214 <_fpadd_parts+0x12a>
     220:	21 e0       	ldi	r18, 0x01	; 1
     222:	30 e0       	ldi	r19, 0x00	; 0
     224:	40 e0       	ldi	r20, 0x00	; 0
     226:	50 e0       	ldi	r21, 0x00	; 0
     228:	04 c0       	rjmp	.+8      	; 0x232 <_fpadd_parts+0x148>
     22a:	22 0f       	add	r18, r18
     22c:	33 1f       	adc	r19, r19
     22e:	44 1f       	adc	r20, r20
     230:	55 1f       	adc	r21, r21
     232:	6a 95       	dec	r22
     234:	d2 f7       	brpl	.-12     	; 0x22a <_fpadd_parts+0x140>
     236:	21 50       	subi	r18, 0x01	; 1
     238:	30 40       	sbci	r19, 0x00	; 0
     23a:	40 40       	sbci	r20, 0x00	; 0
     23c:	50 40       	sbci	r21, 0x00	; 0
     23e:	2a 21       	and	r18, r10
     240:	3b 21       	and	r19, r11
     242:	4c 21       	and	r20, r12
     244:	5d 21       	and	r21, r13
     246:	21 15       	cp	r18, r1
     248:	31 05       	cpc	r19, r1
     24a:	41 05       	cpc	r20, r1
     24c:	51 05       	cpc	r21, r1
     24e:	21 f0       	breq	.+8      	; 0x258 <_fpadd_parts+0x16e>
     250:	21 e0       	ldi	r18, 0x01	; 1
     252:	30 e0       	ldi	r19, 0x00	; 0
     254:	40 e0       	ldi	r20, 0x00	; 0
     256:	50 e0       	ldi	r21, 0x00	; 0
     258:	59 01       	movw	r10, r18
     25a:	6a 01       	movw	r12, r20
     25c:	a6 28       	or	r10, r6
     25e:	b7 28       	or	r11, r7
     260:	c8 28       	or	r12, r8
     262:	d9 28       	or	r13, r9
     264:	0b c0       	rjmp	.+22     	; 0x27c <_fpadd_parts+0x192>
     266:	82 15       	cp	r24, r2
     268:	93 05       	cpc	r25, r3
     26a:	2c f0       	brlt	.+10     	; 0x276 <_fpadd_parts+0x18c>
     26c:	1c 01       	movw	r2, r24
     26e:	aa 24       	eor	r10, r10
     270:	bb 24       	eor	r11, r11
     272:	65 01       	movw	r12, r10
     274:	03 c0       	rjmp	.+6      	; 0x27c <_fpadd_parts+0x192>
     276:	ee 24       	eor	r14, r14
     278:	ff 24       	eor	r15, r15
     27a:	87 01       	movw	r16, r14
     27c:	11 96       	adiw	r26, 0x01	; 1
     27e:	9c 91       	ld	r25, X
     280:	d2 01       	movw	r26, r4
     282:	11 96       	adiw	r26, 0x01	; 1
     284:	8c 91       	ld	r24, X
     286:	98 17       	cp	r25, r24
     288:	09 f4       	brne	.+2      	; 0x28c <_fpadd_parts+0x1a2>
     28a:	45 c0       	rjmp	.+138    	; 0x316 <_fpadd_parts+0x22c>
     28c:	99 23       	and	r25, r25
     28e:	39 f0       	breq	.+14     	; 0x29e <_fpadd_parts+0x1b4>
     290:	a8 01       	movw	r20, r16
     292:	97 01       	movw	r18, r14
     294:	2a 19       	sub	r18, r10
     296:	3b 09       	sbc	r19, r11
     298:	4c 09       	sbc	r20, r12
     29a:	5d 09       	sbc	r21, r13
     29c:	06 c0       	rjmp	.+12     	; 0x2aa <_fpadd_parts+0x1c0>
     29e:	a6 01       	movw	r20, r12
     2a0:	95 01       	movw	r18, r10
     2a2:	2e 19       	sub	r18, r14
     2a4:	3f 09       	sbc	r19, r15
     2a6:	40 0b       	sbc	r20, r16
     2a8:	51 0b       	sbc	r21, r17
     2aa:	57 fd       	sbrc	r21, 7
     2ac:	08 c0       	rjmp	.+16     	; 0x2be <_fpadd_parts+0x1d4>
     2ae:	11 82       	std	Z+1, r1	; 0x01
     2b0:	33 82       	std	Z+3, r3	; 0x03
     2b2:	22 82       	std	Z+2, r2	; 0x02
     2b4:	24 83       	std	Z+4, r18	; 0x04
     2b6:	35 83       	std	Z+5, r19	; 0x05
     2b8:	46 83       	std	Z+6, r20	; 0x06
     2ba:	57 83       	std	Z+7, r21	; 0x07
     2bc:	1d c0       	rjmp	.+58     	; 0x2f8 <_fpadd_parts+0x20e>
     2be:	81 e0       	ldi	r24, 0x01	; 1
     2c0:	81 83       	std	Z+1, r24	; 0x01
     2c2:	33 82       	std	Z+3, r3	; 0x03
     2c4:	22 82       	std	Z+2, r2	; 0x02
     2c6:	88 27       	eor	r24, r24
     2c8:	99 27       	eor	r25, r25
     2ca:	dc 01       	movw	r26, r24
     2cc:	82 1b       	sub	r24, r18
     2ce:	93 0b       	sbc	r25, r19
     2d0:	a4 0b       	sbc	r26, r20
     2d2:	b5 0b       	sbc	r27, r21
     2d4:	84 83       	std	Z+4, r24	; 0x04
     2d6:	95 83       	std	Z+5, r25	; 0x05
     2d8:	a6 83       	std	Z+6, r26	; 0x06
     2da:	b7 83       	std	Z+7, r27	; 0x07
     2dc:	0d c0       	rjmp	.+26     	; 0x2f8 <_fpadd_parts+0x20e>
     2de:	22 0f       	add	r18, r18
     2e0:	33 1f       	adc	r19, r19
     2e2:	44 1f       	adc	r20, r20
     2e4:	55 1f       	adc	r21, r21
     2e6:	24 83       	std	Z+4, r18	; 0x04
     2e8:	35 83       	std	Z+5, r19	; 0x05
     2ea:	46 83       	std	Z+6, r20	; 0x06
     2ec:	57 83       	std	Z+7, r21	; 0x07
     2ee:	82 81       	ldd	r24, Z+2	; 0x02
     2f0:	93 81       	ldd	r25, Z+3	; 0x03
     2f2:	01 97       	sbiw	r24, 0x01	; 1
     2f4:	93 83       	std	Z+3, r25	; 0x03
     2f6:	82 83       	std	Z+2, r24	; 0x02
     2f8:	24 81       	ldd	r18, Z+4	; 0x04
     2fa:	35 81       	ldd	r19, Z+5	; 0x05
     2fc:	46 81       	ldd	r20, Z+6	; 0x06
     2fe:	57 81       	ldd	r21, Z+7	; 0x07
     300:	da 01       	movw	r26, r20
     302:	c9 01       	movw	r24, r18
     304:	01 97       	sbiw	r24, 0x01	; 1
     306:	a1 09       	sbc	r26, r1
     308:	b1 09       	sbc	r27, r1
     30a:	8f 5f       	subi	r24, 0xFF	; 255
     30c:	9f 4f       	sbci	r25, 0xFF	; 255
     30e:	af 4f       	sbci	r26, 0xFF	; 255
     310:	bf 43       	sbci	r27, 0x3F	; 63
     312:	28 f3       	brcs	.-54     	; 0x2de <_fpadd_parts+0x1f4>
     314:	0b c0       	rjmp	.+22     	; 0x32c <_fpadd_parts+0x242>
     316:	91 83       	std	Z+1, r25	; 0x01
     318:	33 82       	std	Z+3, r3	; 0x03
     31a:	22 82       	std	Z+2, r2	; 0x02
     31c:	ea 0c       	add	r14, r10
     31e:	fb 1c       	adc	r15, r11
     320:	0c 1d       	adc	r16, r12
     322:	1d 1d       	adc	r17, r13
     324:	e4 82       	std	Z+4, r14	; 0x04
     326:	f5 82       	std	Z+5, r15	; 0x05
     328:	06 83       	std	Z+6, r16	; 0x06
     32a:	17 83       	std	Z+7, r17	; 0x07
     32c:	83 e0       	ldi	r24, 0x03	; 3
     32e:	80 83       	st	Z, r24
     330:	24 81       	ldd	r18, Z+4	; 0x04
     332:	35 81       	ldd	r19, Z+5	; 0x05
     334:	46 81       	ldd	r20, Z+6	; 0x06
     336:	57 81       	ldd	r21, Z+7	; 0x07
     338:	57 ff       	sbrs	r21, 7
     33a:	1a c0       	rjmp	.+52     	; 0x370 <_fpadd_parts+0x286>
     33c:	c9 01       	movw	r24, r18
     33e:	aa 27       	eor	r26, r26
     340:	97 fd       	sbrc	r25, 7
     342:	a0 95       	com	r26
     344:	ba 2f       	mov	r27, r26
     346:	81 70       	andi	r24, 0x01	; 1
     348:	90 70       	andi	r25, 0x00	; 0
     34a:	a0 70       	andi	r26, 0x00	; 0
     34c:	b0 70       	andi	r27, 0x00	; 0
     34e:	56 95       	lsr	r21
     350:	47 95       	ror	r20
     352:	37 95       	ror	r19
     354:	27 95       	ror	r18
     356:	82 2b       	or	r24, r18
     358:	93 2b       	or	r25, r19
     35a:	a4 2b       	or	r26, r20
     35c:	b5 2b       	or	r27, r21
     35e:	84 83       	std	Z+4, r24	; 0x04
     360:	95 83       	std	Z+5, r25	; 0x05
     362:	a6 83       	std	Z+6, r26	; 0x06
     364:	b7 83       	std	Z+7, r27	; 0x07
     366:	82 81       	ldd	r24, Z+2	; 0x02
     368:	93 81       	ldd	r25, Z+3	; 0x03
     36a:	01 96       	adiw	r24, 0x01	; 1
     36c:	93 83       	std	Z+3, r25	; 0x03
     36e:	82 83       	std	Z+2, r24	; 0x02
     370:	df 01       	movw	r26, r30
     372:	01 c0       	rjmp	.+2      	; 0x376 <_fpadd_parts+0x28c>
     374:	d2 01       	movw	r26, r4
     376:	cd 01       	movw	r24, r26
     378:	cd b7       	in	r28, 0x3d	; 61
     37a:	de b7       	in	r29, 0x3e	; 62
     37c:	e2 e1       	ldi	r30, 0x12	; 18
     37e:	0c 94 78 22 	jmp	0x44f0	; 0x44f0 <__epilogue_restores__>

00000382 <__subsf3>:
     382:	a0 e2       	ldi	r26, 0x20	; 32
     384:	b0 e0       	ldi	r27, 0x00	; 0
     386:	e7 ec       	ldi	r30, 0xC7	; 199
     388:	f1 e0       	ldi	r31, 0x01	; 1
     38a:	0c 94 68 22 	jmp	0x44d0	; 0x44d0 <__prologue_saves__+0x18>
     38e:	69 83       	std	Y+1, r22	; 0x01
     390:	7a 83       	std	Y+2, r23	; 0x02
     392:	8b 83       	std	Y+3, r24	; 0x03
     394:	9c 83       	std	Y+4, r25	; 0x04
     396:	2d 83       	std	Y+5, r18	; 0x05
     398:	3e 83       	std	Y+6, r19	; 0x06
     39a:	4f 83       	std	Y+7, r20	; 0x07
     39c:	58 87       	std	Y+8, r21	; 0x08
     39e:	e9 e0       	ldi	r30, 0x09	; 9
     3a0:	ee 2e       	mov	r14, r30
     3a2:	f1 2c       	mov	r15, r1
     3a4:	ec 0e       	add	r14, r28
     3a6:	fd 1e       	adc	r15, r29
     3a8:	ce 01       	movw	r24, r28
     3aa:	01 96       	adiw	r24, 0x01	; 1
     3ac:	b7 01       	movw	r22, r14
     3ae:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     3b2:	8e 01       	movw	r16, r28
     3b4:	0f 5e       	subi	r16, 0xEF	; 239
     3b6:	1f 4f       	sbci	r17, 0xFF	; 255
     3b8:	ce 01       	movw	r24, r28
     3ba:	05 96       	adiw	r24, 0x05	; 5
     3bc:	b8 01       	movw	r22, r16
     3be:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     3c2:	8a 89       	ldd	r24, Y+18	; 0x12
     3c4:	91 e0       	ldi	r25, 0x01	; 1
     3c6:	89 27       	eor	r24, r25
     3c8:	8a 8b       	std	Y+18, r24	; 0x12
     3ca:	c7 01       	movw	r24, r14
     3cc:	b8 01       	movw	r22, r16
     3ce:	ae 01       	movw	r20, r28
     3d0:	47 5e       	subi	r20, 0xE7	; 231
     3d2:	5f 4f       	sbci	r21, 0xFF	; 255
     3d4:	0e 94 75 00 	call	0xea	; 0xea <_fpadd_parts>
     3d8:	0e 94 fd 03 	call	0x7fa	; 0x7fa <__pack_f>
     3dc:	a0 96       	adiw	r28, 0x20	; 32
     3de:	e6 e0       	ldi	r30, 0x06	; 6
     3e0:	0c 94 84 22 	jmp	0x4508	; 0x4508 <__epilogue_restores__+0x18>

000003e4 <__addsf3>:
     3e4:	a0 e2       	ldi	r26, 0x20	; 32
     3e6:	b0 e0       	ldi	r27, 0x00	; 0
     3e8:	e8 ef       	ldi	r30, 0xF8	; 248
     3ea:	f1 e0       	ldi	r31, 0x01	; 1
     3ec:	0c 94 68 22 	jmp	0x44d0	; 0x44d0 <__prologue_saves__+0x18>
     3f0:	69 83       	std	Y+1, r22	; 0x01
     3f2:	7a 83       	std	Y+2, r23	; 0x02
     3f4:	8b 83       	std	Y+3, r24	; 0x03
     3f6:	9c 83       	std	Y+4, r25	; 0x04
     3f8:	2d 83       	std	Y+5, r18	; 0x05
     3fa:	3e 83       	std	Y+6, r19	; 0x06
     3fc:	4f 83       	std	Y+7, r20	; 0x07
     3fe:	58 87       	std	Y+8, r21	; 0x08
     400:	f9 e0       	ldi	r31, 0x09	; 9
     402:	ef 2e       	mov	r14, r31
     404:	f1 2c       	mov	r15, r1
     406:	ec 0e       	add	r14, r28
     408:	fd 1e       	adc	r15, r29
     40a:	ce 01       	movw	r24, r28
     40c:	01 96       	adiw	r24, 0x01	; 1
     40e:	b7 01       	movw	r22, r14
     410:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     414:	8e 01       	movw	r16, r28
     416:	0f 5e       	subi	r16, 0xEF	; 239
     418:	1f 4f       	sbci	r17, 0xFF	; 255
     41a:	ce 01       	movw	r24, r28
     41c:	05 96       	adiw	r24, 0x05	; 5
     41e:	b8 01       	movw	r22, r16
     420:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     424:	c7 01       	movw	r24, r14
     426:	b8 01       	movw	r22, r16
     428:	ae 01       	movw	r20, r28
     42a:	47 5e       	subi	r20, 0xE7	; 231
     42c:	5f 4f       	sbci	r21, 0xFF	; 255
     42e:	0e 94 75 00 	call	0xea	; 0xea <_fpadd_parts>
     432:	0e 94 fd 03 	call	0x7fa	; 0x7fa <__pack_f>
     436:	a0 96       	adiw	r28, 0x20	; 32
     438:	e6 e0       	ldi	r30, 0x06	; 6
     43a:	0c 94 84 22 	jmp	0x4508	; 0x4508 <__epilogue_restores__+0x18>

0000043e <__mulsf3>:
     43e:	a0 e2       	ldi	r26, 0x20	; 32
     440:	b0 e0       	ldi	r27, 0x00	; 0
     442:	e5 e2       	ldi	r30, 0x25	; 37
     444:	f2 e0       	ldi	r31, 0x02	; 2
     446:	0c 94 5c 22 	jmp	0x44b8	; 0x44b8 <__prologue_saves__>
     44a:	69 83       	std	Y+1, r22	; 0x01
     44c:	7a 83       	std	Y+2, r23	; 0x02
     44e:	8b 83       	std	Y+3, r24	; 0x03
     450:	9c 83       	std	Y+4, r25	; 0x04
     452:	2d 83       	std	Y+5, r18	; 0x05
     454:	3e 83       	std	Y+6, r19	; 0x06
     456:	4f 83       	std	Y+7, r20	; 0x07
     458:	58 87       	std	Y+8, r21	; 0x08
     45a:	ce 01       	movw	r24, r28
     45c:	01 96       	adiw	r24, 0x01	; 1
     45e:	be 01       	movw	r22, r28
     460:	67 5f       	subi	r22, 0xF7	; 247
     462:	7f 4f       	sbci	r23, 0xFF	; 255
     464:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     468:	ce 01       	movw	r24, r28
     46a:	05 96       	adiw	r24, 0x05	; 5
     46c:	be 01       	movw	r22, r28
     46e:	6f 5e       	subi	r22, 0xEF	; 239
     470:	7f 4f       	sbci	r23, 0xFF	; 255
     472:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     476:	99 85       	ldd	r25, Y+9	; 0x09
     478:	92 30       	cpi	r25, 0x02	; 2
     47a:	88 f0       	brcs	.+34     	; 0x49e <__mulsf3+0x60>
     47c:	89 89       	ldd	r24, Y+17	; 0x11
     47e:	82 30       	cpi	r24, 0x02	; 2
     480:	c8 f0       	brcs	.+50     	; 0x4b4 <__mulsf3+0x76>
     482:	94 30       	cpi	r25, 0x04	; 4
     484:	19 f4       	brne	.+6      	; 0x48c <__mulsf3+0x4e>
     486:	82 30       	cpi	r24, 0x02	; 2
     488:	51 f4       	brne	.+20     	; 0x49e <__mulsf3+0x60>
     48a:	04 c0       	rjmp	.+8      	; 0x494 <__mulsf3+0x56>
     48c:	84 30       	cpi	r24, 0x04	; 4
     48e:	29 f4       	brne	.+10     	; 0x49a <__mulsf3+0x5c>
     490:	92 30       	cpi	r25, 0x02	; 2
     492:	81 f4       	brne	.+32     	; 0x4b4 <__mulsf3+0x76>
     494:	8f e6       	ldi	r24, 0x6F	; 111
     496:	90 e0       	ldi	r25, 0x00	; 0
     498:	c6 c0       	rjmp	.+396    	; 0x626 <__mulsf3+0x1e8>
     49a:	92 30       	cpi	r25, 0x02	; 2
     49c:	49 f4       	brne	.+18     	; 0x4b0 <__mulsf3+0x72>
     49e:	20 e0       	ldi	r18, 0x00	; 0
     4a0:	9a 85       	ldd	r25, Y+10	; 0x0a
     4a2:	8a 89       	ldd	r24, Y+18	; 0x12
     4a4:	98 13       	cpse	r25, r24
     4a6:	21 e0       	ldi	r18, 0x01	; 1
     4a8:	2a 87       	std	Y+10, r18	; 0x0a
     4aa:	ce 01       	movw	r24, r28
     4ac:	09 96       	adiw	r24, 0x09	; 9
     4ae:	bb c0       	rjmp	.+374    	; 0x626 <__mulsf3+0x1e8>
     4b0:	82 30       	cpi	r24, 0x02	; 2
     4b2:	49 f4       	brne	.+18     	; 0x4c6 <__mulsf3+0x88>
     4b4:	20 e0       	ldi	r18, 0x00	; 0
     4b6:	9a 85       	ldd	r25, Y+10	; 0x0a
     4b8:	8a 89       	ldd	r24, Y+18	; 0x12
     4ba:	98 13       	cpse	r25, r24
     4bc:	21 e0       	ldi	r18, 0x01	; 1
     4be:	2a 8b       	std	Y+18, r18	; 0x12
     4c0:	ce 01       	movw	r24, r28
     4c2:	41 96       	adiw	r24, 0x11	; 17
     4c4:	b0 c0       	rjmp	.+352    	; 0x626 <__mulsf3+0x1e8>
     4c6:	2d 84       	ldd	r2, Y+13	; 0x0d
     4c8:	3e 84       	ldd	r3, Y+14	; 0x0e
     4ca:	4f 84       	ldd	r4, Y+15	; 0x0f
     4cc:	58 88       	ldd	r5, Y+16	; 0x10
     4ce:	6d 88       	ldd	r6, Y+21	; 0x15
     4d0:	7e 88       	ldd	r7, Y+22	; 0x16
     4d2:	8f 88       	ldd	r8, Y+23	; 0x17
     4d4:	98 8c       	ldd	r9, Y+24	; 0x18
     4d6:	ee 24       	eor	r14, r14
     4d8:	ff 24       	eor	r15, r15
     4da:	87 01       	movw	r16, r14
     4dc:	aa 24       	eor	r10, r10
     4de:	bb 24       	eor	r11, r11
     4e0:	65 01       	movw	r12, r10
     4e2:	40 e0       	ldi	r20, 0x00	; 0
     4e4:	50 e0       	ldi	r21, 0x00	; 0
     4e6:	60 e0       	ldi	r22, 0x00	; 0
     4e8:	70 e0       	ldi	r23, 0x00	; 0
     4ea:	e0 e0       	ldi	r30, 0x00	; 0
     4ec:	f0 e0       	ldi	r31, 0x00	; 0
     4ee:	c1 01       	movw	r24, r2
     4f0:	81 70       	andi	r24, 0x01	; 1
     4f2:	90 70       	andi	r25, 0x00	; 0
     4f4:	89 2b       	or	r24, r25
     4f6:	e9 f0       	breq	.+58     	; 0x532 <__mulsf3+0xf4>
     4f8:	e6 0c       	add	r14, r6
     4fa:	f7 1c       	adc	r15, r7
     4fc:	08 1d       	adc	r16, r8
     4fe:	19 1d       	adc	r17, r9
     500:	9a 01       	movw	r18, r20
     502:	ab 01       	movw	r20, r22
     504:	2a 0d       	add	r18, r10
     506:	3b 1d       	adc	r19, r11
     508:	4c 1d       	adc	r20, r12
     50a:	5d 1d       	adc	r21, r13
     50c:	80 e0       	ldi	r24, 0x00	; 0
     50e:	90 e0       	ldi	r25, 0x00	; 0
     510:	a0 e0       	ldi	r26, 0x00	; 0
     512:	b0 e0       	ldi	r27, 0x00	; 0
     514:	e6 14       	cp	r14, r6
     516:	f7 04       	cpc	r15, r7
     518:	08 05       	cpc	r16, r8
     51a:	19 05       	cpc	r17, r9
     51c:	20 f4       	brcc	.+8      	; 0x526 <__mulsf3+0xe8>
     51e:	81 e0       	ldi	r24, 0x01	; 1
     520:	90 e0       	ldi	r25, 0x00	; 0
     522:	a0 e0       	ldi	r26, 0x00	; 0
     524:	b0 e0       	ldi	r27, 0x00	; 0
     526:	ba 01       	movw	r22, r20
     528:	a9 01       	movw	r20, r18
     52a:	48 0f       	add	r20, r24
     52c:	59 1f       	adc	r21, r25
     52e:	6a 1f       	adc	r22, r26
     530:	7b 1f       	adc	r23, r27
     532:	aa 0c       	add	r10, r10
     534:	bb 1c       	adc	r11, r11
     536:	cc 1c       	adc	r12, r12
     538:	dd 1c       	adc	r13, r13
     53a:	97 fe       	sbrs	r9, 7
     53c:	08 c0       	rjmp	.+16     	; 0x54e <__mulsf3+0x110>
     53e:	81 e0       	ldi	r24, 0x01	; 1
     540:	90 e0       	ldi	r25, 0x00	; 0
     542:	a0 e0       	ldi	r26, 0x00	; 0
     544:	b0 e0       	ldi	r27, 0x00	; 0
     546:	a8 2a       	or	r10, r24
     548:	b9 2a       	or	r11, r25
     54a:	ca 2a       	or	r12, r26
     54c:	db 2a       	or	r13, r27
     54e:	31 96       	adiw	r30, 0x01	; 1
     550:	e0 32       	cpi	r30, 0x20	; 32
     552:	f1 05       	cpc	r31, r1
     554:	49 f0       	breq	.+18     	; 0x568 <__mulsf3+0x12a>
     556:	66 0c       	add	r6, r6
     558:	77 1c       	adc	r7, r7
     55a:	88 1c       	adc	r8, r8
     55c:	99 1c       	adc	r9, r9
     55e:	56 94       	lsr	r5
     560:	47 94       	ror	r4
     562:	37 94       	ror	r3
     564:	27 94       	ror	r2
     566:	c3 cf       	rjmp	.-122    	; 0x4ee <__mulsf3+0xb0>
     568:	fa 85       	ldd	r31, Y+10	; 0x0a
     56a:	ea 89       	ldd	r30, Y+18	; 0x12
     56c:	2b 89       	ldd	r18, Y+19	; 0x13
     56e:	3c 89       	ldd	r19, Y+20	; 0x14
     570:	8b 85       	ldd	r24, Y+11	; 0x0b
     572:	9c 85       	ldd	r25, Y+12	; 0x0c
     574:	28 0f       	add	r18, r24
     576:	39 1f       	adc	r19, r25
     578:	2e 5f       	subi	r18, 0xFE	; 254
     57a:	3f 4f       	sbci	r19, 0xFF	; 255
     57c:	17 c0       	rjmp	.+46     	; 0x5ac <__mulsf3+0x16e>
     57e:	ca 01       	movw	r24, r20
     580:	81 70       	andi	r24, 0x01	; 1
     582:	90 70       	andi	r25, 0x00	; 0
     584:	89 2b       	or	r24, r25
     586:	61 f0       	breq	.+24     	; 0x5a0 <__mulsf3+0x162>
     588:	16 95       	lsr	r17
     58a:	07 95       	ror	r16
     58c:	f7 94       	ror	r15
     58e:	e7 94       	ror	r14
     590:	80 e0       	ldi	r24, 0x00	; 0
     592:	90 e0       	ldi	r25, 0x00	; 0
     594:	a0 e0       	ldi	r26, 0x00	; 0
     596:	b0 e8       	ldi	r27, 0x80	; 128
     598:	e8 2a       	or	r14, r24
     59a:	f9 2a       	or	r15, r25
     59c:	0a 2b       	or	r16, r26
     59e:	1b 2b       	or	r17, r27
     5a0:	76 95       	lsr	r23
     5a2:	67 95       	ror	r22
     5a4:	57 95       	ror	r21
     5a6:	47 95       	ror	r20
     5a8:	2f 5f       	subi	r18, 0xFF	; 255
     5aa:	3f 4f       	sbci	r19, 0xFF	; 255
     5ac:	77 fd       	sbrc	r23, 7
     5ae:	e7 cf       	rjmp	.-50     	; 0x57e <__mulsf3+0x140>
     5b0:	0c c0       	rjmp	.+24     	; 0x5ca <__mulsf3+0x18c>
     5b2:	44 0f       	add	r20, r20
     5b4:	55 1f       	adc	r21, r21
     5b6:	66 1f       	adc	r22, r22
     5b8:	77 1f       	adc	r23, r23
     5ba:	17 fd       	sbrc	r17, 7
     5bc:	41 60       	ori	r20, 0x01	; 1
     5be:	ee 0c       	add	r14, r14
     5c0:	ff 1c       	adc	r15, r15
     5c2:	00 1f       	adc	r16, r16
     5c4:	11 1f       	adc	r17, r17
     5c6:	21 50       	subi	r18, 0x01	; 1
     5c8:	30 40       	sbci	r19, 0x00	; 0
     5ca:	40 30       	cpi	r20, 0x00	; 0
     5cc:	90 e0       	ldi	r25, 0x00	; 0
     5ce:	59 07       	cpc	r21, r25
     5d0:	90 e0       	ldi	r25, 0x00	; 0
     5d2:	69 07       	cpc	r22, r25
     5d4:	90 e4       	ldi	r25, 0x40	; 64
     5d6:	79 07       	cpc	r23, r25
     5d8:	60 f3       	brcs	.-40     	; 0x5b2 <__mulsf3+0x174>
     5da:	2b 8f       	std	Y+27, r18	; 0x1b
     5dc:	3c 8f       	std	Y+28, r19	; 0x1c
     5de:	db 01       	movw	r26, r22
     5e0:	ca 01       	movw	r24, r20
     5e2:	8f 77       	andi	r24, 0x7F	; 127
     5e4:	90 70       	andi	r25, 0x00	; 0
     5e6:	a0 70       	andi	r26, 0x00	; 0
     5e8:	b0 70       	andi	r27, 0x00	; 0
     5ea:	80 34       	cpi	r24, 0x40	; 64
     5ec:	91 05       	cpc	r25, r1
     5ee:	a1 05       	cpc	r26, r1
     5f0:	b1 05       	cpc	r27, r1
     5f2:	61 f4       	brne	.+24     	; 0x60c <__mulsf3+0x1ce>
     5f4:	47 fd       	sbrc	r20, 7
     5f6:	0a c0       	rjmp	.+20     	; 0x60c <__mulsf3+0x1ce>
     5f8:	e1 14       	cp	r14, r1
     5fa:	f1 04       	cpc	r15, r1
     5fc:	01 05       	cpc	r16, r1
     5fe:	11 05       	cpc	r17, r1
     600:	29 f0       	breq	.+10     	; 0x60c <__mulsf3+0x1ce>
     602:	40 5c       	subi	r20, 0xC0	; 192
     604:	5f 4f       	sbci	r21, 0xFF	; 255
     606:	6f 4f       	sbci	r22, 0xFF	; 255
     608:	7f 4f       	sbci	r23, 0xFF	; 255
     60a:	40 78       	andi	r20, 0x80	; 128
     60c:	1a 8e       	std	Y+26, r1	; 0x1a
     60e:	fe 17       	cp	r31, r30
     610:	11 f0       	breq	.+4      	; 0x616 <__mulsf3+0x1d8>
     612:	81 e0       	ldi	r24, 0x01	; 1
     614:	8a 8f       	std	Y+26, r24	; 0x1a
     616:	4d 8f       	std	Y+29, r20	; 0x1d
     618:	5e 8f       	std	Y+30, r21	; 0x1e
     61a:	6f 8f       	std	Y+31, r22	; 0x1f
     61c:	78 a3       	std	Y+32, r23	; 0x20
     61e:	83 e0       	ldi	r24, 0x03	; 3
     620:	89 8f       	std	Y+25, r24	; 0x19
     622:	ce 01       	movw	r24, r28
     624:	49 96       	adiw	r24, 0x19	; 25
     626:	0e 94 fd 03 	call	0x7fa	; 0x7fa <__pack_f>
     62a:	a0 96       	adiw	r28, 0x20	; 32
     62c:	e2 e1       	ldi	r30, 0x12	; 18
     62e:	0c 94 78 22 	jmp	0x44f0	; 0x44f0 <__epilogue_restores__>

00000632 <__gtsf2>:
     632:	a8 e1       	ldi	r26, 0x18	; 24
     634:	b0 e0       	ldi	r27, 0x00	; 0
     636:	ef e1       	ldi	r30, 0x1F	; 31
     638:	f3 e0       	ldi	r31, 0x03	; 3
     63a:	0c 94 68 22 	jmp	0x44d0	; 0x44d0 <__prologue_saves__+0x18>
     63e:	69 83       	std	Y+1, r22	; 0x01
     640:	7a 83       	std	Y+2, r23	; 0x02
     642:	8b 83       	std	Y+3, r24	; 0x03
     644:	9c 83       	std	Y+4, r25	; 0x04
     646:	2d 83       	std	Y+5, r18	; 0x05
     648:	3e 83       	std	Y+6, r19	; 0x06
     64a:	4f 83       	std	Y+7, r20	; 0x07
     64c:	58 87       	std	Y+8, r21	; 0x08
     64e:	89 e0       	ldi	r24, 0x09	; 9
     650:	e8 2e       	mov	r14, r24
     652:	f1 2c       	mov	r15, r1
     654:	ec 0e       	add	r14, r28
     656:	fd 1e       	adc	r15, r29
     658:	ce 01       	movw	r24, r28
     65a:	01 96       	adiw	r24, 0x01	; 1
     65c:	b7 01       	movw	r22, r14
     65e:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     662:	8e 01       	movw	r16, r28
     664:	0f 5e       	subi	r16, 0xEF	; 239
     666:	1f 4f       	sbci	r17, 0xFF	; 255
     668:	ce 01       	movw	r24, r28
     66a:	05 96       	adiw	r24, 0x05	; 5
     66c:	b8 01       	movw	r22, r16
     66e:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     672:	89 85       	ldd	r24, Y+9	; 0x09
     674:	82 30       	cpi	r24, 0x02	; 2
     676:	40 f0       	brcs	.+16     	; 0x688 <__gtsf2+0x56>
     678:	89 89       	ldd	r24, Y+17	; 0x11
     67a:	82 30       	cpi	r24, 0x02	; 2
     67c:	28 f0       	brcs	.+10     	; 0x688 <__gtsf2+0x56>
     67e:	c7 01       	movw	r24, r14
     680:	b8 01       	movw	r22, r16
     682:	0e 94 4a 05 	call	0xa94	; 0xa94 <__fpcmp_parts_f>
     686:	01 c0       	rjmp	.+2      	; 0x68a <__gtsf2+0x58>
     688:	8f ef       	ldi	r24, 0xFF	; 255
     68a:	68 96       	adiw	r28, 0x18	; 24
     68c:	e6 e0       	ldi	r30, 0x06	; 6
     68e:	0c 94 84 22 	jmp	0x4508	; 0x4508 <__epilogue_restores__+0x18>

00000692 <__gesf2>:
     692:	a8 e1       	ldi	r26, 0x18	; 24
     694:	b0 e0       	ldi	r27, 0x00	; 0
     696:	ef e4       	ldi	r30, 0x4F	; 79
     698:	f3 e0       	ldi	r31, 0x03	; 3
     69a:	0c 94 68 22 	jmp	0x44d0	; 0x44d0 <__prologue_saves__+0x18>
     69e:	69 83       	std	Y+1, r22	; 0x01
     6a0:	7a 83       	std	Y+2, r23	; 0x02
     6a2:	8b 83       	std	Y+3, r24	; 0x03
     6a4:	9c 83       	std	Y+4, r25	; 0x04
     6a6:	2d 83       	std	Y+5, r18	; 0x05
     6a8:	3e 83       	std	Y+6, r19	; 0x06
     6aa:	4f 83       	std	Y+7, r20	; 0x07
     6ac:	58 87       	std	Y+8, r21	; 0x08
     6ae:	89 e0       	ldi	r24, 0x09	; 9
     6b0:	e8 2e       	mov	r14, r24
     6b2:	f1 2c       	mov	r15, r1
     6b4:	ec 0e       	add	r14, r28
     6b6:	fd 1e       	adc	r15, r29
     6b8:	ce 01       	movw	r24, r28
     6ba:	01 96       	adiw	r24, 0x01	; 1
     6bc:	b7 01       	movw	r22, r14
     6be:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     6c2:	8e 01       	movw	r16, r28
     6c4:	0f 5e       	subi	r16, 0xEF	; 239
     6c6:	1f 4f       	sbci	r17, 0xFF	; 255
     6c8:	ce 01       	movw	r24, r28
     6ca:	05 96       	adiw	r24, 0x05	; 5
     6cc:	b8 01       	movw	r22, r16
     6ce:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     6d2:	89 85       	ldd	r24, Y+9	; 0x09
     6d4:	82 30       	cpi	r24, 0x02	; 2
     6d6:	40 f0       	brcs	.+16     	; 0x6e8 <__gesf2+0x56>
     6d8:	89 89       	ldd	r24, Y+17	; 0x11
     6da:	82 30       	cpi	r24, 0x02	; 2
     6dc:	28 f0       	brcs	.+10     	; 0x6e8 <__gesf2+0x56>
     6de:	c7 01       	movw	r24, r14
     6e0:	b8 01       	movw	r22, r16
     6e2:	0e 94 4a 05 	call	0xa94	; 0xa94 <__fpcmp_parts_f>
     6e6:	01 c0       	rjmp	.+2      	; 0x6ea <__gesf2+0x58>
     6e8:	8f ef       	ldi	r24, 0xFF	; 255
     6ea:	68 96       	adiw	r28, 0x18	; 24
     6ec:	e6 e0       	ldi	r30, 0x06	; 6
     6ee:	0c 94 84 22 	jmp	0x4508	; 0x4508 <__epilogue_restores__+0x18>

000006f2 <__ltsf2>:
     6f2:	a8 e1       	ldi	r26, 0x18	; 24
     6f4:	b0 e0       	ldi	r27, 0x00	; 0
     6f6:	ef e7       	ldi	r30, 0x7F	; 127
     6f8:	f3 e0       	ldi	r31, 0x03	; 3
     6fa:	0c 94 68 22 	jmp	0x44d0	; 0x44d0 <__prologue_saves__+0x18>
     6fe:	69 83       	std	Y+1, r22	; 0x01
     700:	7a 83       	std	Y+2, r23	; 0x02
     702:	8b 83       	std	Y+3, r24	; 0x03
     704:	9c 83       	std	Y+4, r25	; 0x04
     706:	2d 83       	std	Y+5, r18	; 0x05
     708:	3e 83       	std	Y+6, r19	; 0x06
     70a:	4f 83       	std	Y+7, r20	; 0x07
     70c:	58 87       	std	Y+8, r21	; 0x08
     70e:	89 e0       	ldi	r24, 0x09	; 9
     710:	e8 2e       	mov	r14, r24
     712:	f1 2c       	mov	r15, r1
     714:	ec 0e       	add	r14, r28
     716:	fd 1e       	adc	r15, r29
     718:	ce 01       	movw	r24, r28
     71a:	01 96       	adiw	r24, 0x01	; 1
     71c:	b7 01       	movw	r22, r14
     71e:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     722:	8e 01       	movw	r16, r28
     724:	0f 5e       	subi	r16, 0xEF	; 239
     726:	1f 4f       	sbci	r17, 0xFF	; 255
     728:	ce 01       	movw	r24, r28
     72a:	05 96       	adiw	r24, 0x05	; 5
     72c:	b8 01       	movw	r22, r16
     72e:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     732:	89 85       	ldd	r24, Y+9	; 0x09
     734:	82 30       	cpi	r24, 0x02	; 2
     736:	40 f0       	brcs	.+16     	; 0x748 <__ltsf2+0x56>
     738:	89 89       	ldd	r24, Y+17	; 0x11
     73a:	82 30       	cpi	r24, 0x02	; 2
     73c:	28 f0       	brcs	.+10     	; 0x748 <__ltsf2+0x56>
     73e:	c7 01       	movw	r24, r14
     740:	b8 01       	movw	r22, r16
     742:	0e 94 4a 05 	call	0xa94	; 0xa94 <__fpcmp_parts_f>
     746:	01 c0       	rjmp	.+2      	; 0x74a <__ltsf2+0x58>
     748:	81 e0       	ldi	r24, 0x01	; 1
     74a:	68 96       	adiw	r28, 0x18	; 24
     74c:	e6 e0       	ldi	r30, 0x06	; 6
     74e:	0c 94 84 22 	jmp	0x4508	; 0x4508 <__epilogue_restores__+0x18>

00000752 <__fixsfsi>:
     752:	ac e0       	ldi	r26, 0x0C	; 12
     754:	b0 e0       	ldi	r27, 0x00	; 0
     756:	ef ea       	ldi	r30, 0xAF	; 175
     758:	f3 e0       	ldi	r31, 0x03	; 3
     75a:	0c 94 6c 22 	jmp	0x44d8	; 0x44d8 <__prologue_saves__+0x20>
     75e:	69 83       	std	Y+1, r22	; 0x01
     760:	7a 83       	std	Y+2, r23	; 0x02
     762:	8b 83       	std	Y+3, r24	; 0x03
     764:	9c 83       	std	Y+4, r25	; 0x04
     766:	ce 01       	movw	r24, r28
     768:	01 96       	adiw	r24, 0x01	; 1
     76a:	be 01       	movw	r22, r28
     76c:	6b 5f       	subi	r22, 0xFB	; 251
     76e:	7f 4f       	sbci	r23, 0xFF	; 255
     770:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     774:	8d 81       	ldd	r24, Y+5	; 0x05
     776:	82 30       	cpi	r24, 0x02	; 2
     778:	61 f1       	breq	.+88     	; 0x7d2 <__fixsfsi+0x80>
     77a:	82 30       	cpi	r24, 0x02	; 2
     77c:	50 f1       	brcs	.+84     	; 0x7d2 <__fixsfsi+0x80>
     77e:	84 30       	cpi	r24, 0x04	; 4
     780:	21 f4       	brne	.+8      	; 0x78a <__fixsfsi+0x38>
     782:	8e 81       	ldd	r24, Y+6	; 0x06
     784:	88 23       	and	r24, r24
     786:	51 f1       	breq	.+84     	; 0x7dc <__fixsfsi+0x8a>
     788:	2e c0       	rjmp	.+92     	; 0x7e6 <__fixsfsi+0x94>
     78a:	2f 81       	ldd	r18, Y+7	; 0x07
     78c:	38 85       	ldd	r19, Y+8	; 0x08
     78e:	37 fd       	sbrc	r19, 7
     790:	20 c0       	rjmp	.+64     	; 0x7d2 <__fixsfsi+0x80>
     792:	6e 81       	ldd	r22, Y+6	; 0x06
     794:	2f 31       	cpi	r18, 0x1F	; 31
     796:	31 05       	cpc	r19, r1
     798:	1c f0       	brlt	.+6      	; 0x7a0 <__fixsfsi+0x4e>
     79a:	66 23       	and	r22, r22
     79c:	f9 f0       	breq	.+62     	; 0x7dc <__fixsfsi+0x8a>
     79e:	23 c0       	rjmp	.+70     	; 0x7e6 <__fixsfsi+0x94>
     7a0:	8e e1       	ldi	r24, 0x1E	; 30
     7a2:	90 e0       	ldi	r25, 0x00	; 0
     7a4:	82 1b       	sub	r24, r18
     7a6:	93 0b       	sbc	r25, r19
     7a8:	29 85       	ldd	r18, Y+9	; 0x09
     7aa:	3a 85       	ldd	r19, Y+10	; 0x0a
     7ac:	4b 85       	ldd	r20, Y+11	; 0x0b
     7ae:	5c 85       	ldd	r21, Y+12	; 0x0c
     7b0:	04 c0       	rjmp	.+8      	; 0x7ba <__fixsfsi+0x68>
     7b2:	56 95       	lsr	r21
     7b4:	47 95       	ror	r20
     7b6:	37 95       	ror	r19
     7b8:	27 95       	ror	r18
     7ba:	8a 95       	dec	r24
     7bc:	d2 f7       	brpl	.-12     	; 0x7b2 <__fixsfsi+0x60>
     7be:	66 23       	and	r22, r22
     7c0:	b1 f0       	breq	.+44     	; 0x7ee <__fixsfsi+0x9c>
     7c2:	50 95       	com	r21
     7c4:	40 95       	com	r20
     7c6:	30 95       	com	r19
     7c8:	21 95       	neg	r18
     7ca:	3f 4f       	sbci	r19, 0xFF	; 255
     7cc:	4f 4f       	sbci	r20, 0xFF	; 255
     7ce:	5f 4f       	sbci	r21, 0xFF	; 255
     7d0:	0e c0       	rjmp	.+28     	; 0x7ee <__fixsfsi+0x9c>
     7d2:	20 e0       	ldi	r18, 0x00	; 0
     7d4:	30 e0       	ldi	r19, 0x00	; 0
     7d6:	40 e0       	ldi	r20, 0x00	; 0
     7d8:	50 e0       	ldi	r21, 0x00	; 0
     7da:	09 c0       	rjmp	.+18     	; 0x7ee <__fixsfsi+0x9c>
     7dc:	2f ef       	ldi	r18, 0xFF	; 255
     7de:	3f ef       	ldi	r19, 0xFF	; 255
     7e0:	4f ef       	ldi	r20, 0xFF	; 255
     7e2:	5f e7       	ldi	r21, 0x7F	; 127
     7e4:	04 c0       	rjmp	.+8      	; 0x7ee <__fixsfsi+0x9c>
     7e6:	20 e0       	ldi	r18, 0x00	; 0
     7e8:	30 e0       	ldi	r19, 0x00	; 0
     7ea:	40 e0       	ldi	r20, 0x00	; 0
     7ec:	50 e8       	ldi	r21, 0x80	; 128
     7ee:	b9 01       	movw	r22, r18
     7f0:	ca 01       	movw	r24, r20
     7f2:	2c 96       	adiw	r28, 0x0c	; 12
     7f4:	e2 e0       	ldi	r30, 0x02	; 2
     7f6:	0c 94 88 22 	jmp	0x4510	; 0x4510 <__epilogue_restores__+0x20>

000007fa <__pack_f>:
     7fa:	df 92       	push	r13
     7fc:	ef 92       	push	r14
     7fe:	ff 92       	push	r15
     800:	0f 93       	push	r16
     802:	1f 93       	push	r17
     804:	fc 01       	movw	r30, r24
     806:	e4 80       	ldd	r14, Z+4	; 0x04
     808:	f5 80       	ldd	r15, Z+5	; 0x05
     80a:	06 81       	ldd	r16, Z+6	; 0x06
     80c:	17 81       	ldd	r17, Z+7	; 0x07
     80e:	d1 80       	ldd	r13, Z+1	; 0x01
     810:	80 81       	ld	r24, Z
     812:	82 30       	cpi	r24, 0x02	; 2
     814:	48 f4       	brcc	.+18     	; 0x828 <__pack_f+0x2e>
     816:	80 e0       	ldi	r24, 0x00	; 0
     818:	90 e0       	ldi	r25, 0x00	; 0
     81a:	a0 e1       	ldi	r26, 0x10	; 16
     81c:	b0 e0       	ldi	r27, 0x00	; 0
     81e:	e8 2a       	or	r14, r24
     820:	f9 2a       	or	r15, r25
     822:	0a 2b       	or	r16, r26
     824:	1b 2b       	or	r17, r27
     826:	a5 c0       	rjmp	.+330    	; 0x972 <__stack+0x113>
     828:	84 30       	cpi	r24, 0x04	; 4
     82a:	09 f4       	brne	.+2      	; 0x82e <__pack_f+0x34>
     82c:	9f c0       	rjmp	.+318    	; 0x96c <__stack+0x10d>
     82e:	82 30       	cpi	r24, 0x02	; 2
     830:	21 f4       	brne	.+8      	; 0x83a <__pack_f+0x40>
     832:	ee 24       	eor	r14, r14
     834:	ff 24       	eor	r15, r15
     836:	87 01       	movw	r16, r14
     838:	05 c0       	rjmp	.+10     	; 0x844 <__pack_f+0x4a>
     83a:	e1 14       	cp	r14, r1
     83c:	f1 04       	cpc	r15, r1
     83e:	01 05       	cpc	r16, r1
     840:	11 05       	cpc	r17, r1
     842:	19 f4       	brne	.+6      	; 0x84a <__pack_f+0x50>
     844:	e0 e0       	ldi	r30, 0x00	; 0
     846:	f0 e0       	ldi	r31, 0x00	; 0
     848:	96 c0       	rjmp	.+300    	; 0x976 <__stack+0x117>
     84a:	62 81       	ldd	r22, Z+2	; 0x02
     84c:	73 81       	ldd	r23, Z+3	; 0x03
     84e:	9f ef       	ldi	r25, 0xFF	; 255
     850:	62 38       	cpi	r22, 0x82	; 130
     852:	79 07       	cpc	r23, r25
     854:	0c f0       	brlt	.+2      	; 0x858 <__pack_f+0x5e>
     856:	5b c0       	rjmp	.+182    	; 0x90e <__stack+0xaf>
     858:	22 e8       	ldi	r18, 0x82	; 130
     85a:	3f ef       	ldi	r19, 0xFF	; 255
     85c:	26 1b       	sub	r18, r22
     85e:	37 0b       	sbc	r19, r23
     860:	2a 31       	cpi	r18, 0x1A	; 26
     862:	31 05       	cpc	r19, r1
     864:	2c f0       	brlt	.+10     	; 0x870 <__stack+0x11>
     866:	20 e0       	ldi	r18, 0x00	; 0
     868:	30 e0       	ldi	r19, 0x00	; 0
     86a:	40 e0       	ldi	r20, 0x00	; 0
     86c:	50 e0       	ldi	r21, 0x00	; 0
     86e:	2a c0       	rjmp	.+84     	; 0x8c4 <__stack+0x65>
     870:	b8 01       	movw	r22, r16
     872:	a7 01       	movw	r20, r14
     874:	02 2e       	mov	r0, r18
     876:	04 c0       	rjmp	.+8      	; 0x880 <__stack+0x21>
     878:	76 95       	lsr	r23
     87a:	67 95       	ror	r22
     87c:	57 95       	ror	r21
     87e:	47 95       	ror	r20
     880:	0a 94       	dec	r0
     882:	d2 f7       	brpl	.-12     	; 0x878 <__stack+0x19>
     884:	81 e0       	ldi	r24, 0x01	; 1
     886:	90 e0       	ldi	r25, 0x00	; 0
     888:	a0 e0       	ldi	r26, 0x00	; 0
     88a:	b0 e0       	ldi	r27, 0x00	; 0
     88c:	04 c0       	rjmp	.+8      	; 0x896 <__stack+0x37>
     88e:	88 0f       	add	r24, r24
     890:	99 1f       	adc	r25, r25
     892:	aa 1f       	adc	r26, r26
     894:	bb 1f       	adc	r27, r27
     896:	2a 95       	dec	r18
     898:	d2 f7       	brpl	.-12     	; 0x88e <__stack+0x2f>
     89a:	01 97       	sbiw	r24, 0x01	; 1
     89c:	a1 09       	sbc	r26, r1
     89e:	b1 09       	sbc	r27, r1
     8a0:	8e 21       	and	r24, r14
     8a2:	9f 21       	and	r25, r15
     8a4:	a0 23       	and	r26, r16
     8a6:	b1 23       	and	r27, r17
     8a8:	00 97       	sbiw	r24, 0x00	; 0
     8aa:	a1 05       	cpc	r26, r1
     8ac:	b1 05       	cpc	r27, r1
     8ae:	21 f0       	breq	.+8      	; 0x8b8 <__stack+0x59>
     8b0:	81 e0       	ldi	r24, 0x01	; 1
     8b2:	90 e0       	ldi	r25, 0x00	; 0
     8b4:	a0 e0       	ldi	r26, 0x00	; 0
     8b6:	b0 e0       	ldi	r27, 0x00	; 0
     8b8:	9a 01       	movw	r18, r20
     8ba:	ab 01       	movw	r20, r22
     8bc:	28 2b       	or	r18, r24
     8be:	39 2b       	or	r19, r25
     8c0:	4a 2b       	or	r20, r26
     8c2:	5b 2b       	or	r21, r27
     8c4:	da 01       	movw	r26, r20
     8c6:	c9 01       	movw	r24, r18
     8c8:	8f 77       	andi	r24, 0x7F	; 127
     8ca:	90 70       	andi	r25, 0x00	; 0
     8cc:	a0 70       	andi	r26, 0x00	; 0
     8ce:	b0 70       	andi	r27, 0x00	; 0
     8d0:	80 34       	cpi	r24, 0x40	; 64
     8d2:	91 05       	cpc	r25, r1
     8d4:	a1 05       	cpc	r26, r1
     8d6:	b1 05       	cpc	r27, r1
     8d8:	39 f4       	brne	.+14     	; 0x8e8 <__stack+0x89>
     8da:	27 ff       	sbrs	r18, 7
     8dc:	09 c0       	rjmp	.+18     	; 0x8f0 <__stack+0x91>
     8de:	20 5c       	subi	r18, 0xC0	; 192
     8e0:	3f 4f       	sbci	r19, 0xFF	; 255
     8e2:	4f 4f       	sbci	r20, 0xFF	; 255
     8e4:	5f 4f       	sbci	r21, 0xFF	; 255
     8e6:	04 c0       	rjmp	.+8      	; 0x8f0 <__stack+0x91>
     8e8:	21 5c       	subi	r18, 0xC1	; 193
     8ea:	3f 4f       	sbci	r19, 0xFF	; 255
     8ec:	4f 4f       	sbci	r20, 0xFF	; 255
     8ee:	5f 4f       	sbci	r21, 0xFF	; 255
     8f0:	e0 e0       	ldi	r30, 0x00	; 0
     8f2:	f0 e0       	ldi	r31, 0x00	; 0
     8f4:	20 30       	cpi	r18, 0x00	; 0
     8f6:	a0 e0       	ldi	r26, 0x00	; 0
     8f8:	3a 07       	cpc	r19, r26
     8fa:	a0 e0       	ldi	r26, 0x00	; 0
     8fc:	4a 07       	cpc	r20, r26
     8fe:	a0 e4       	ldi	r26, 0x40	; 64
     900:	5a 07       	cpc	r21, r26
     902:	10 f0       	brcs	.+4      	; 0x908 <__stack+0xa9>
     904:	e1 e0       	ldi	r30, 0x01	; 1
     906:	f0 e0       	ldi	r31, 0x00	; 0
     908:	79 01       	movw	r14, r18
     90a:	8a 01       	movw	r16, r20
     90c:	27 c0       	rjmp	.+78     	; 0x95c <__stack+0xfd>
     90e:	60 38       	cpi	r22, 0x80	; 128
     910:	71 05       	cpc	r23, r1
     912:	64 f5       	brge	.+88     	; 0x96c <__stack+0x10d>
     914:	fb 01       	movw	r30, r22
     916:	e1 58       	subi	r30, 0x81	; 129
     918:	ff 4f       	sbci	r31, 0xFF	; 255
     91a:	d8 01       	movw	r26, r16
     91c:	c7 01       	movw	r24, r14
     91e:	8f 77       	andi	r24, 0x7F	; 127
     920:	90 70       	andi	r25, 0x00	; 0
     922:	a0 70       	andi	r26, 0x00	; 0
     924:	b0 70       	andi	r27, 0x00	; 0
     926:	80 34       	cpi	r24, 0x40	; 64
     928:	91 05       	cpc	r25, r1
     92a:	a1 05       	cpc	r26, r1
     92c:	b1 05       	cpc	r27, r1
     92e:	39 f4       	brne	.+14     	; 0x93e <__stack+0xdf>
     930:	e7 fe       	sbrs	r14, 7
     932:	0d c0       	rjmp	.+26     	; 0x94e <__stack+0xef>
     934:	80 e4       	ldi	r24, 0x40	; 64
     936:	90 e0       	ldi	r25, 0x00	; 0
     938:	a0 e0       	ldi	r26, 0x00	; 0
     93a:	b0 e0       	ldi	r27, 0x00	; 0
     93c:	04 c0       	rjmp	.+8      	; 0x946 <__stack+0xe7>
     93e:	8f e3       	ldi	r24, 0x3F	; 63
     940:	90 e0       	ldi	r25, 0x00	; 0
     942:	a0 e0       	ldi	r26, 0x00	; 0
     944:	b0 e0       	ldi	r27, 0x00	; 0
     946:	e8 0e       	add	r14, r24
     948:	f9 1e       	adc	r15, r25
     94a:	0a 1f       	adc	r16, r26
     94c:	1b 1f       	adc	r17, r27
     94e:	17 ff       	sbrs	r17, 7
     950:	05 c0       	rjmp	.+10     	; 0x95c <__stack+0xfd>
     952:	16 95       	lsr	r17
     954:	07 95       	ror	r16
     956:	f7 94       	ror	r15
     958:	e7 94       	ror	r14
     95a:	31 96       	adiw	r30, 0x01	; 1
     95c:	87 e0       	ldi	r24, 0x07	; 7
     95e:	16 95       	lsr	r17
     960:	07 95       	ror	r16
     962:	f7 94       	ror	r15
     964:	e7 94       	ror	r14
     966:	8a 95       	dec	r24
     968:	d1 f7       	brne	.-12     	; 0x95e <__stack+0xff>
     96a:	05 c0       	rjmp	.+10     	; 0x976 <__stack+0x117>
     96c:	ee 24       	eor	r14, r14
     96e:	ff 24       	eor	r15, r15
     970:	87 01       	movw	r16, r14
     972:	ef ef       	ldi	r30, 0xFF	; 255
     974:	f0 e0       	ldi	r31, 0x00	; 0
     976:	6e 2f       	mov	r22, r30
     978:	67 95       	ror	r22
     97a:	66 27       	eor	r22, r22
     97c:	67 95       	ror	r22
     97e:	90 2f       	mov	r25, r16
     980:	9f 77       	andi	r25, 0x7F	; 127
     982:	d7 94       	ror	r13
     984:	dd 24       	eor	r13, r13
     986:	d7 94       	ror	r13
     988:	8e 2f       	mov	r24, r30
     98a:	86 95       	lsr	r24
     98c:	49 2f       	mov	r20, r25
     98e:	46 2b       	or	r20, r22
     990:	58 2f       	mov	r21, r24
     992:	5d 29       	or	r21, r13
     994:	b7 01       	movw	r22, r14
     996:	ca 01       	movw	r24, r20
     998:	1f 91       	pop	r17
     99a:	0f 91       	pop	r16
     99c:	ff 90       	pop	r15
     99e:	ef 90       	pop	r14
     9a0:	df 90       	pop	r13
     9a2:	08 95       	ret

000009a4 <__unpack_f>:
     9a4:	fc 01       	movw	r30, r24
     9a6:	db 01       	movw	r26, r22
     9a8:	40 81       	ld	r20, Z
     9aa:	51 81       	ldd	r21, Z+1	; 0x01
     9ac:	22 81       	ldd	r18, Z+2	; 0x02
     9ae:	62 2f       	mov	r22, r18
     9b0:	6f 77       	andi	r22, 0x7F	; 127
     9b2:	70 e0       	ldi	r23, 0x00	; 0
     9b4:	22 1f       	adc	r18, r18
     9b6:	22 27       	eor	r18, r18
     9b8:	22 1f       	adc	r18, r18
     9ba:	93 81       	ldd	r25, Z+3	; 0x03
     9bc:	89 2f       	mov	r24, r25
     9be:	88 0f       	add	r24, r24
     9c0:	82 2b       	or	r24, r18
     9c2:	28 2f       	mov	r18, r24
     9c4:	30 e0       	ldi	r19, 0x00	; 0
     9c6:	99 1f       	adc	r25, r25
     9c8:	99 27       	eor	r25, r25
     9ca:	99 1f       	adc	r25, r25
     9cc:	11 96       	adiw	r26, 0x01	; 1
     9ce:	9c 93       	st	X, r25
     9d0:	11 97       	sbiw	r26, 0x01	; 1
     9d2:	21 15       	cp	r18, r1
     9d4:	31 05       	cpc	r19, r1
     9d6:	a9 f5       	brne	.+106    	; 0xa42 <__unpack_f+0x9e>
     9d8:	41 15       	cp	r20, r1
     9da:	51 05       	cpc	r21, r1
     9dc:	61 05       	cpc	r22, r1
     9de:	71 05       	cpc	r23, r1
     9e0:	11 f4       	brne	.+4      	; 0x9e6 <__unpack_f+0x42>
     9e2:	82 e0       	ldi	r24, 0x02	; 2
     9e4:	37 c0       	rjmp	.+110    	; 0xa54 <__unpack_f+0xb0>
     9e6:	82 e8       	ldi	r24, 0x82	; 130
     9e8:	9f ef       	ldi	r25, 0xFF	; 255
     9ea:	13 96       	adiw	r26, 0x03	; 3
     9ec:	9c 93       	st	X, r25
     9ee:	8e 93       	st	-X, r24
     9f0:	12 97       	sbiw	r26, 0x02	; 2
     9f2:	9a 01       	movw	r18, r20
     9f4:	ab 01       	movw	r20, r22
     9f6:	67 e0       	ldi	r22, 0x07	; 7
     9f8:	22 0f       	add	r18, r18
     9fa:	33 1f       	adc	r19, r19
     9fc:	44 1f       	adc	r20, r20
     9fe:	55 1f       	adc	r21, r21
     a00:	6a 95       	dec	r22
     a02:	d1 f7       	brne	.-12     	; 0x9f8 <__unpack_f+0x54>
     a04:	83 e0       	ldi	r24, 0x03	; 3
     a06:	8c 93       	st	X, r24
     a08:	0d c0       	rjmp	.+26     	; 0xa24 <__unpack_f+0x80>
     a0a:	22 0f       	add	r18, r18
     a0c:	33 1f       	adc	r19, r19
     a0e:	44 1f       	adc	r20, r20
     a10:	55 1f       	adc	r21, r21
     a12:	12 96       	adiw	r26, 0x02	; 2
     a14:	8d 91       	ld	r24, X+
     a16:	9c 91       	ld	r25, X
     a18:	13 97       	sbiw	r26, 0x03	; 3
     a1a:	01 97       	sbiw	r24, 0x01	; 1
     a1c:	13 96       	adiw	r26, 0x03	; 3
     a1e:	9c 93       	st	X, r25
     a20:	8e 93       	st	-X, r24
     a22:	12 97       	sbiw	r26, 0x02	; 2
     a24:	20 30       	cpi	r18, 0x00	; 0
     a26:	80 e0       	ldi	r24, 0x00	; 0
     a28:	38 07       	cpc	r19, r24
     a2a:	80 e0       	ldi	r24, 0x00	; 0
     a2c:	48 07       	cpc	r20, r24
     a2e:	80 e4       	ldi	r24, 0x40	; 64
     a30:	58 07       	cpc	r21, r24
     a32:	58 f3       	brcs	.-42     	; 0xa0a <__unpack_f+0x66>
     a34:	14 96       	adiw	r26, 0x04	; 4
     a36:	2d 93       	st	X+, r18
     a38:	3d 93       	st	X+, r19
     a3a:	4d 93       	st	X+, r20
     a3c:	5c 93       	st	X, r21
     a3e:	17 97       	sbiw	r26, 0x07	; 7
     a40:	08 95       	ret
     a42:	2f 3f       	cpi	r18, 0xFF	; 255
     a44:	31 05       	cpc	r19, r1
     a46:	79 f4       	brne	.+30     	; 0xa66 <__unpack_f+0xc2>
     a48:	41 15       	cp	r20, r1
     a4a:	51 05       	cpc	r21, r1
     a4c:	61 05       	cpc	r22, r1
     a4e:	71 05       	cpc	r23, r1
     a50:	19 f4       	brne	.+6      	; 0xa58 <__unpack_f+0xb4>
     a52:	84 e0       	ldi	r24, 0x04	; 4
     a54:	8c 93       	st	X, r24
     a56:	08 95       	ret
     a58:	64 ff       	sbrs	r22, 4
     a5a:	03 c0       	rjmp	.+6      	; 0xa62 <__unpack_f+0xbe>
     a5c:	81 e0       	ldi	r24, 0x01	; 1
     a5e:	8c 93       	st	X, r24
     a60:	12 c0       	rjmp	.+36     	; 0xa86 <__unpack_f+0xe2>
     a62:	1c 92       	st	X, r1
     a64:	10 c0       	rjmp	.+32     	; 0xa86 <__unpack_f+0xe2>
     a66:	2f 57       	subi	r18, 0x7F	; 127
     a68:	30 40       	sbci	r19, 0x00	; 0
     a6a:	13 96       	adiw	r26, 0x03	; 3
     a6c:	3c 93       	st	X, r19
     a6e:	2e 93       	st	-X, r18
     a70:	12 97       	sbiw	r26, 0x02	; 2
     a72:	83 e0       	ldi	r24, 0x03	; 3
     a74:	8c 93       	st	X, r24
     a76:	87 e0       	ldi	r24, 0x07	; 7
     a78:	44 0f       	add	r20, r20
     a7a:	55 1f       	adc	r21, r21
     a7c:	66 1f       	adc	r22, r22
     a7e:	77 1f       	adc	r23, r23
     a80:	8a 95       	dec	r24
     a82:	d1 f7       	brne	.-12     	; 0xa78 <__unpack_f+0xd4>
     a84:	70 64       	ori	r23, 0x40	; 64
     a86:	14 96       	adiw	r26, 0x04	; 4
     a88:	4d 93       	st	X+, r20
     a8a:	5d 93       	st	X+, r21
     a8c:	6d 93       	st	X+, r22
     a8e:	7c 93       	st	X, r23
     a90:	17 97       	sbiw	r26, 0x07	; 7
     a92:	08 95       	ret

00000a94 <__fpcmp_parts_f>:
     a94:	1f 93       	push	r17
     a96:	dc 01       	movw	r26, r24
     a98:	fb 01       	movw	r30, r22
     a9a:	9c 91       	ld	r25, X
     a9c:	92 30       	cpi	r25, 0x02	; 2
     a9e:	08 f4       	brcc	.+2      	; 0xaa2 <__fpcmp_parts_f+0xe>
     aa0:	47 c0       	rjmp	.+142    	; 0xb30 <__fpcmp_parts_f+0x9c>
     aa2:	80 81       	ld	r24, Z
     aa4:	82 30       	cpi	r24, 0x02	; 2
     aa6:	08 f4       	brcc	.+2      	; 0xaaa <__fpcmp_parts_f+0x16>
     aa8:	43 c0       	rjmp	.+134    	; 0xb30 <__fpcmp_parts_f+0x9c>
     aaa:	94 30       	cpi	r25, 0x04	; 4
     aac:	51 f4       	brne	.+20     	; 0xac2 <__fpcmp_parts_f+0x2e>
     aae:	11 96       	adiw	r26, 0x01	; 1
     ab0:	1c 91       	ld	r17, X
     ab2:	84 30       	cpi	r24, 0x04	; 4
     ab4:	99 f5       	brne	.+102    	; 0xb1c <__fpcmp_parts_f+0x88>
     ab6:	81 81       	ldd	r24, Z+1	; 0x01
     ab8:	68 2f       	mov	r22, r24
     aba:	70 e0       	ldi	r23, 0x00	; 0
     abc:	61 1b       	sub	r22, r17
     abe:	71 09       	sbc	r23, r1
     ac0:	3f c0       	rjmp	.+126    	; 0xb40 <__fpcmp_parts_f+0xac>
     ac2:	84 30       	cpi	r24, 0x04	; 4
     ac4:	21 f0       	breq	.+8      	; 0xace <__fpcmp_parts_f+0x3a>
     ac6:	92 30       	cpi	r25, 0x02	; 2
     ac8:	31 f4       	brne	.+12     	; 0xad6 <__fpcmp_parts_f+0x42>
     aca:	82 30       	cpi	r24, 0x02	; 2
     acc:	b9 f1       	breq	.+110    	; 0xb3c <__fpcmp_parts_f+0xa8>
     ace:	81 81       	ldd	r24, Z+1	; 0x01
     ad0:	88 23       	and	r24, r24
     ad2:	89 f1       	breq	.+98     	; 0xb36 <__fpcmp_parts_f+0xa2>
     ad4:	2d c0       	rjmp	.+90     	; 0xb30 <__fpcmp_parts_f+0x9c>
     ad6:	11 96       	adiw	r26, 0x01	; 1
     ad8:	1c 91       	ld	r17, X
     ada:	11 97       	sbiw	r26, 0x01	; 1
     adc:	82 30       	cpi	r24, 0x02	; 2
     ade:	f1 f0       	breq	.+60     	; 0xb1c <__fpcmp_parts_f+0x88>
     ae0:	81 81       	ldd	r24, Z+1	; 0x01
     ae2:	18 17       	cp	r17, r24
     ae4:	d9 f4       	brne	.+54     	; 0xb1c <__fpcmp_parts_f+0x88>
     ae6:	12 96       	adiw	r26, 0x02	; 2
     ae8:	2d 91       	ld	r18, X+
     aea:	3c 91       	ld	r19, X
     aec:	13 97       	sbiw	r26, 0x03	; 3
     aee:	82 81       	ldd	r24, Z+2	; 0x02
     af0:	93 81       	ldd	r25, Z+3	; 0x03
     af2:	82 17       	cp	r24, r18
     af4:	93 07       	cpc	r25, r19
     af6:	94 f0       	brlt	.+36     	; 0xb1c <__fpcmp_parts_f+0x88>
     af8:	28 17       	cp	r18, r24
     afa:	39 07       	cpc	r19, r25
     afc:	bc f0       	brlt	.+46     	; 0xb2c <__fpcmp_parts_f+0x98>
     afe:	14 96       	adiw	r26, 0x04	; 4
     b00:	8d 91       	ld	r24, X+
     b02:	9d 91       	ld	r25, X+
     b04:	0d 90       	ld	r0, X+
     b06:	bc 91       	ld	r27, X
     b08:	a0 2d       	mov	r26, r0
     b0a:	24 81       	ldd	r18, Z+4	; 0x04
     b0c:	35 81       	ldd	r19, Z+5	; 0x05
     b0e:	46 81       	ldd	r20, Z+6	; 0x06
     b10:	57 81       	ldd	r21, Z+7	; 0x07
     b12:	28 17       	cp	r18, r24
     b14:	39 07       	cpc	r19, r25
     b16:	4a 07       	cpc	r20, r26
     b18:	5b 07       	cpc	r21, r27
     b1a:	18 f4       	brcc	.+6      	; 0xb22 <__fpcmp_parts_f+0x8e>
     b1c:	11 23       	and	r17, r17
     b1e:	41 f0       	breq	.+16     	; 0xb30 <__fpcmp_parts_f+0x9c>
     b20:	0a c0       	rjmp	.+20     	; 0xb36 <__fpcmp_parts_f+0xa2>
     b22:	82 17       	cp	r24, r18
     b24:	93 07       	cpc	r25, r19
     b26:	a4 07       	cpc	r26, r20
     b28:	b5 07       	cpc	r27, r21
     b2a:	40 f4       	brcc	.+16     	; 0xb3c <__fpcmp_parts_f+0xa8>
     b2c:	11 23       	and	r17, r17
     b2e:	19 f0       	breq	.+6      	; 0xb36 <__fpcmp_parts_f+0xa2>
     b30:	61 e0       	ldi	r22, 0x01	; 1
     b32:	70 e0       	ldi	r23, 0x00	; 0
     b34:	05 c0       	rjmp	.+10     	; 0xb40 <__fpcmp_parts_f+0xac>
     b36:	6f ef       	ldi	r22, 0xFF	; 255
     b38:	7f ef       	ldi	r23, 0xFF	; 255
     b3a:	02 c0       	rjmp	.+4      	; 0xb40 <__fpcmp_parts_f+0xac>
     b3c:	60 e0       	ldi	r22, 0x00	; 0
     b3e:	70 e0       	ldi	r23, 0x00	; 0
     b40:	cb 01       	movw	r24, r22
     b42:	1f 91       	pop	r17
     b44:	08 95       	ret

00000b46 <MDIO_voidSetPinDirection>:
#include "../Include/MCAL/DIO/DIO_Cfg.h"

#define F_CPU 8000000UL

void MDIO_voidSetPinDirection (DIO_PORT_e A_DIOPort,DIO_PIN_e A_PINID, DIO_DIRECTION_e A_PINDirection)
{
     b46:	df 93       	push	r29
     b48:	cf 93       	push	r28
     b4a:	cd b7       	in	r28, 0x3d	; 61
     b4c:	de b7       	in	r29, 0x3e	; 62
     b4e:	2d 97       	sbiw	r28, 0x0d	; 13
     b50:	0f b6       	in	r0, 0x3f	; 63
     b52:	f8 94       	cli
     b54:	de bf       	out	0x3e, r29	; 62
     b56:	0f be       	out	0x3f, r0	; 63
     b58:	cd bf       	out	0x3d, r28	; 61
     b5a:	89 83       	std	Y+1, r24	; 0x01
     b5c:	6a 83       	std	Y+2, r22	; 0x02
     b5e:	4b 83       	std	Y+3, r20	; 0x03
	// Input Validation
	if ((A_DIOPort <= DIO_PORTD) && (A_PINID <= PIN7) && (A_PINDirection <= DIO_OUTPUT))
     b60:	89 81       	ldd	r24, Y+1	; 0x01
     b62:	84 30       	cpi	r24, 0x04	; 4
     b64:	08 f0       	brcs	.+2      	; 0xb68 <MDIO_voidSetPinDirection+0x22>
     b66:	09 c1       	rjmp	.+530    	; 0xd7a <MDIO_voidSetPinDirection+0x234>
     b68:	8a 81       	ldd	r24, Y+2	; 0x02
     b6a:	88 30       	cpi	r24, 0x08	; 8
     b6c:	08 f0       	brcs	.+2      	; 0xb70 <MDIO_voidSetPinDirection+0x2a>
     b6e:	05 c1       	rjmp	.+522    	; 0xd7a <MDIO_voidSetPinDirection+0x234>
     b70:	8b 81       	ldd	r24, Y+3	; 0x03
     b72:	82 30       	cpi	r24, 0x02	; 2
     b74:	08 f0       	brcs	.+2      	; 0xb78 <MDIO_voidSetPinDirection+0x32>
     b76:	01 c1       	rjmp	.+514    	; 0xd7a <MDIO_voidSetPinDirection+0x234>
	{
		switch (A_DIOPort)
     b78:	89 81       	ldd	r24, Y+1	; 0x01
     b7a:	28 2f       	mov	r18, r24
     b7c:	30 e0       	ldi	r19, 0x00	; 0
     b7e:	3d 87       	std	Y+13, r19	; 0x0d
     b80:	2c 87       	std	Y+12, r18	; 0x0c
     b82:	8c 85       	ldd	r24, Y+12	; 0x0c
     b84:	9d 85       	ldd	r25, Y+13	; 0x0d
     b86:	81 30       	cpi	r24, 0x01	; 1
     b88:	91 05       	cpc	r25, r1
     b8a:	09 f4       	brne	.+2      	; 0xb8e <MDIO_voidSetPinDirection+0x48>
     b8c:	4f c0       	rjmp	.+158    	; 0xc2c <MDIO_voidSetPinDirection+0xe6>
     b8e:	2c 85       	ldd	r18, Y+12	; 0x0c
     b90:	3d 85       	ldd	r19, Y+13	; 0x0d
     b92:	22 30       	cpi	r18, 0x02	; 2
     b94:	31 05       	cpc	r19, r1
     b96:	2c f4       	brge	.+10     	; 0xba2 <MDIO_voidSetPinDirection+0x5c>
     b98:	8c 85       	ldd	r24, Y+12	; 0x0c
     b9a:	9d 85       	ldd	r25, Y+13	; 0x0d
     b9c:	00 97       	sbiw	r24, 0x00	; 0
     b9e:	71 f0       	breq	.+28     	; 0xbbc <MDIO_voidSetPinDirection+0x76>
     ba0:	ec c0       	rjmp	.+472    	; 0xd7a <MDIO_voidSetPinDirection+0x234>
     ba2:	2c 85       	ldd	r18, Y+12	; 0x0c
     ba4:	3d 85       	ldd	r19, Y+13	; 0x0d
     ba6:	22 30       	cpi	r18, 0x02	; 2
     ba8:	31 05       	cpc	r19, r1
     baa:	09 f4       	brne	.+2      	; 0xbae <MDIO_voidSetPinDirection+0x68>
     bac:	77 c0       	rjmp	.+238    	; 0xc9c <MDIO_voidSetPinDirection+0x156>
     bae:	8c 85       	ldd	r24, Y+12	; 0x0c
     bb0:	9d 85       	ldd	r25, Y+13	; 0x0d
     bb2:	83 30       	cpi	r24, 0x03	; 3
     bb4:	91 05       	cpc	r25, r1
     bb6:	09 f4       	brne	.+2      	; 0xbba <MDIO_voidSetPinDirection+0x74>
     bb8:	a9 c0       	rjmp	.+338    	; 0xd0c <MDIO_voidSetPinDirection+0x1c6>
     bba:	df c0       	rjmp	.+446    	; 0xd7a <MDIO_voidSetPinDirection+0x234>
		{
		case DIO_PORTA:
			switch (A_PINDirection)
     bbc:	8b 81       	ldd	r24, Y+3	; 0x03
     bbe:	28 2f       	mov	r18, r24
     bc0:	30 e0       	ldi	r19, 0x00	; 0
     bc2:	3b 87       	std	Y+11, r19	; 0x0b
     bc4:	2a 87       	std	Y+10, r18	; 0x0a
     bc6:	8a 85       	ldd	r24, Y+10	; 0x0a
     bc8:	9b 85       	ldd	r25, Y+11	; 0x0b
     bca:	00 97       	sbiw	r24, 0x00	; 0
     bcc:	31 f0       	breq	.+12     	; 0xbda <MDIO_voidSetPinDirection+0x94>
     bce:	2a 85       	ldd	r18, Y+10	; 0x0a
     bd0:	3b 85       	ldd	r19, Y+11	; 0x0b
     bd2:	21 30       	cpi	r18, 0x01	; 1
     bd4:	31 05       	cpc	r19, r1
     bd6:	b1 f0       	breq	.+44     	; 0xc04 <MDIO_voidSetPinDirection+0xbe>
     bd8:	d0 c0       	rjmp	.+416    	; 0xd7a <MDIO_voidSetPinDirection+0x234>
			{
			case DIO_INPUT:
				CLR_BIT(DDRA_REG,A_PINID);
     bda:	aa e3       	ldi	r26, 0x3A	; 58
     bdc:	b0 e0       	ldi	r27, 0x00	; 0
     bde:	ea e3       	ldi	r30, 0x3A	; 58
     be0:	f0 e0       	ldi	r31, 0x00	; 0
     be2:	80 81       	ld	r24, Z
     be4:	48 2f       	mov	r20, r24
     be6:	8a 81       	ldd	r24, Y+2	; 0x02
     be8:	28 2f       	mov	r18, r24
     bea:	30 e0       	ldi	r19, 0x00	; 0
     bec:	81 e0       	ldi	r24, 0x01	; 1
     bee:	90 e0       	ldi	r25, 0x00	; 0
     bf0:	02 2e       	mov	r0, r18
     bf2:	02 c0       	rjmp	.+4      	; 0xbf8 <MDIO_voidSetPinDirection+0xb2>
     bf4:	88 0f       	add	r24, r24
     bf6:	99 1f       	adc	r25, r25
     bf8:	0a 94       	dec	r0
     bfa:	e2 f7       	brpl	.-8      	; 0xbf4 <MDIO_voidSetPinDirection+0xae>
     bfc:	80 95       	com	r24
     bfe:	84 23       	and	r24, r20
     c00:	8c 93       	st	X, r24
     c02:	bb c0       	rjmp	.+374    	; 0xd7a <MDIO_voidSetPinDirection+0x234>
				break;
			case DIO_OUTPUT:
				SET_BIT(DDRA_REG,A_PINID);
     c04:	aa e3       	ldi	r26, 0x3A	; 58
     c06:	b0 e0       	ldi	r27, 0x00	; 0
     c08:	ea e3       	ldi	r30, 0x3A	; 58
     c0a:	f0 e0       	ldi	r31, 0x00	; 0
     c0c:	80 81       	ld	r24, Z
     c0e:	48 2f       	mov	r20, r24
     c10:	8a 81       	ldd	r24, Y+2	; 0x02
     c12:	28 2f       	mov	r18, r24
     c14:	30 e0       	ldi	r19, 0x00	; 0
     c16:	81 e0       	ldi	r24, 0x01	; 1
     c18:	90 e0       	ldi	r25, 0x00	; 0
     c1a:	02 2e       	mov	r0, r18
     c1c:	02 c0       	rjmp	.+4      	; 0xc22 <MDIO_voidSetPinDirection+0xdc>
     c1e:	88 0f       	add	r24, r24
     c20:	99 1f       	adc	r25, r25
     c22:	0a 94       	dec	r0
     c24:	e2 f7       	brpl	.-8      	; 0xc1e <MDIO_voidSetPinDirection+0xd8>
     c26:	84 2b       	or	r24, r20
     c28:	8c 93       	st	X, r24
     c2a:	a7 c0       	rjmp	.+334    	; 0xd7a <MDIO_voidSetPinDirection+0x234>
				break;
			}
			break;
			// *******************************************
		case DIO_PORTB:
			switch (A_PINDirection)
     c2c:	8b 81       	ldd	r24, Y+3	; 0x03
     c2e:	28 2f       	mov	r18, r24
     c30:	30 e0       	ldi	r19, 0x00	; 0
     c32:	39 87       	std	Y+9, r19	; 0x09
     c34:	28 87       	std	Y+8, r18	; 0x08
     c36:	88 85       	ldd	r24, Y+8	; 0x08
     c38:	99 85       	ldd	r25, Y+9	; 0x09
     c3a:	00 97       	sbiw	r24, 0x00	; 0
     c3c:	31 f0       	breq	.+12     	; 0xc4a <MDIO_voidSetPinDirection+0x104>
     c3e:	28 85       	ldd	r18, Y+8	; 0x08
     c40:	39 85       	ldd	r19, Y+9	; 0x09
     c42:	21 30       	cpi	r18, 0x01	; 1
     c44:	31 05       	cpc	r19, r1
     c46:	b1 f0       	breq	.+44     	; 0xc74 <MDIO_voidSetPinDirection+0x12e>
     c48:	98 c0       	rjmp	.+304    	; 0xd7a <MDIO_voidSetPinDirection+0x234>
			{
			case DIO_INPUT:
				CLR_BIT(DDRB_REG,A_PINID);
     c4a:	a7 e3       	ldi	r26, 0x37	; 55
     c4c:	b0 e0       	ldi	r27, 0x00	; 0
     c4e:	e7 e3       	ldi	r30, 0x37	; 55
     c50:	f0 e0       	ldi	r31, 0x00	; 0
     c52:	80 81       	ld	r24, Z
     c54:	48 2f       	mov	r20, r24
     c56:	8a 81       	ldd	r24, Y+2	; 0x02
     c58:	28 2f       	mov	r18, r24
     c5a:	30 e0       	ldi	r19, 0x00	; 0
     c5c:	81 e0       	ldi	r24, 0x01	; 1
     c5e:	90 e0       	ldi	r25, 0x00	; 0
     c60:	02 2e       	mov	r0, r18
     c62:	02 c0       	rjmp	.+4      	; 0xc68 <MDIO_voidSetPinDirection+0x122>
     c64:	88 0f       	add	r24, r24
     c66:	99 1f       	adc	r25, r25
     c68:	0a 94       	dec	r0
     c6a:	e2 f7       	brpl	.-8      	; 0xc64 <MDIO_voidSetPinDirection+0x11e>
     c6c:	80 95       	com	r24
     c6e:	84 23       	and	r24, r20
     c70:	8c 93       	st	X, r24
     c72:	83 c0       	rjmp	.+262    	; 0xd7a <MDIO_voidSetPinDirection+0x234>
				break;
			case DIO_OUTPUT:
				SET_BIT(DDRB_REG,A_PINID);
     c74:	a7 e3       	ldi	r26, 0x37	; 55
     c76:	b0 e0       	ldi	r27, 0x00	; 0
     c78:	e7 e3       	ldi	r30, 0x37	; 55
     c7a:	f0 e0       	ldi	r31, 0x00	; 0
     c7c:	80 81       	ld	r24, Z
     c7e:	48 2f       	mov	r20, r24
     c80:	8a 81       	ldd	r24, Y+2	; 0x02
     c82:	28 2f       	mov	r18, r24
     c84:	30 e0       	ldi	r19, 0x00	; 0
     c86:	81 e0       	ldi	r24, 0x01	; 1
     c88:	90 e0       	ldi	r25, 0x00	; 0
     c8a:	02 2e       	mov	r0, r18
     c8c:	02 c0       	rjmp	.+4      	; 0xc92 <MDIO_voidSetPinDirection+0x14c>
     c8e:	88 0f       	add	r24, r24
     c90:	99 1f       	adc	r25, r25
     c92:	0a 94       	dec	r0
     c94:	e2 f7       	brpl	.-8      	; 0xc8e <MDIO_voidSetPinDirection+0x148>
     c96:	84 2b       	or	r24, r20
     c98:	8c 93       	st	X, r24
     c9a:	6f c0       	rjmp	.+222    	; 0xd7a <MDIO_voidSetPinDirection+0x234>
				break;
			}
			break;
			// *******************************************
		case DIO_PORTC:
			switch (A_PINDirection)
     c9c:	8b 81       	ldd	r24, Y+3	; 0x03
     c9e:	28 2f       	mov	r18, r24
     ca0:	30 e0       	ldi	r19, 0x00	; 0
     ca2:	3f 83       	std	Y+7, r19	; 0x07
     ca4:	2e 83       	std	Y+6, r18	; 0x06
     ca6:	8e 81       	ldd	r24, Y+6	; 0x06
     ca8:	9f 81       	ldd	r25, Y+7	; 0x07
     caa:	00 97       	sbiw	r24, 0x00	; 0
     cac:	31 f0       	breq	.+12     	; 0xcba <MDIO_voidSetPinDirection+0x174>
     cae:	2e 81       	ldd	r18, Y+6	; 0x06
     cb0:	3f 81       	ldd	r19, Y+7	; 0x07
     cb2:	21 30       	cpi	r18, 0x01	; 1
     cb4:	31 05       	cpc	r19, r1
     cb6:	b1 f0       	breq	.+44     	; 0xce4 <MDIO_voidSetPinDirection+0x19e>
     cb8:	60 c0       	rjmp	.+192    	; 0xd7a <MDIO_voidSetPinDirection+0x234>
			{
			case DIO_INPUT:
				CLR_BIT(DDRC_REG,A_PINID);
     cba:	a4 e3       	ldi	r26, 0x34	; 52
     cbc:	b0 e0       	ldi	r27, 0x00	; 0
     cbe:	e4 e3       	ldi	r30, 0x34	; 52
     cc0:	f0 e0       	ldi	r31, 0x00	; 0
     cc2:	80 81       	ld	r24, Z
     cc4:	48 2f       	mov	r20, r24
     cc6:	8a 81       	ldd	r24, Y+2	; 0x02
     cc8:	28 2f       	mov	r18, r24
     cca:	30 e0       	ldi	r19, 0x00	; 0
     ccc:	81 e0       	ldi	r24, 0x01	; 1
     cce:	90 e0       	ldi	r25, 0x00	; 0
     cd0:	02 2e       	mov	r0, r18
     cd2:	02 c0       	rjmp	.+4      	; 0xcd8 <MDIO_voidSetPinDirection+0x192>
     cd4:	88 0f       	add	r24, r24
     cd6:	99 1f       	adc	r25, r25
     cd8:	0a 94       	dec	r0
     cda:	e2 f7       	brpl	.-8      	; 0xcd4 <MDIO_voidSetPinDirection+0x18e>
     cdc:	80 95       	com	r24
     cde:	84 23       	and	r24, r20
     ce0:	8c 93       	st	X, r24
     ce2:	4b c0       	rjmp	.+150    	; 0xd7a <MDIO_voidSetPinDirection+0x234>
				break;
			case DIO_OUTPUT:
				SET_BIT(DDRC_REG,A_PINID);
     ce4:	a4 e3       	ldi	r26, 0x34	; 52
     ce6:	b0 e0       	ldi	r27, 0x00	; 0
     ce8:	e4 e3       	ldi	r30, 0x34	; 52
     cea:	f0 e0       	ldi	r31, 0x00	; 0
     cec:	80 81       	ld	r24, Z
     cee:	48 2f       	mov	r20, r24
     cf0:	8a 81       	ldd	r24, Y+2	; 0x02
     cf2:	28 2f       	mov	r18, r24
     cf4:	30 e0       	ldi	r19, 0x00	; 0
     cf6:	81 e0       	ldi	r24, 0x01	; 1
     cf8:	90 e0       	ldi	r25, 0x00	; 0
     cfa:	02 2e       	mov	r0, r18
     cfc:	02 c0       	rjmp	.+4      	; 0xd02 <MDIO_voidSetPinDirection+0x1bc>
     cfe:	88 0f       	add	r24, r24
     d00:	99 1f       	adc	r25, r25
     d02:	0a 94       	dec	r0
     d04:	e2 f7       	brpl	.-8      	; 0xcfe <MDIO_voidSetPinDirection+0x1b8>
     d06:	84 2b       	or	r24, r20
     d08:	8c 93       	st	X, r24
     d0a:	37 c0       	rjmp	.+110    	; 0xd7a <MDIO_voidSetPinDirection+0x234>
				break;
			}
			break;
			// *******************************************
		case DIO_PORTD:
			switch (A_PINDirection)
     d0c:	8b 81       	ldd	r24, Y+3	; 0x03
     d0e:	28 2f       	mov	r18, r24
     d10:	30 e0       	ldi	r19, 0x00	; 0
     d12:	3d 83       	std	Y+5, r19	; 0x05
     d14:	2c 83       	std	Y+4, r18	; 0x04
     d16:	8c 81       	ldd	r24, Y+4	; 0x04
     d18:	9d 81       	ldd	r25, Y+5	; 0x05
     d1a:	00 97       	sbiw	r24, 0x00	; 0
     d1c:	31 f0       	breq	.+12     	; 0xd2a <MDIO_voidSetPinDirection+0x1e4>
     d1e:	2c 81       	ldd	r18, Y+4	; 0x04
     d20:	3d 81       	ldd	r19, Y+5	; 0x05
     d22:	21 30       	cpi	r18, 0x01	; 1
     d24:	31 05       	cpc	r19, r1
     d26:	b1 f0       	breq	.+44     	; 0xd54 <MDIO_voidSetPinDirection+0x20e>
     d28:	28 c0       	rjmp	.+80     	; 0xd7a <MDIO_voidSetPinDirection+0x234>
			{
			case DIO_INPUT:
				CLR_BIT(DDRD_REG,A_PINID);
     d2a:	a1 e3       	ldi	r26, 0x31	; 49
     d2c:	b0 e0       	ldi	r27, 0x00	; 0
     d2e:	e1 e3       	ldi	r30, 0x31	; 49
     d30:	f0 e0       	ldi	r31, 0x00	; 0
     d32:	80 81       	ld	r24, Z
     d34:	48 2f       	mov	r20, r24
     d36:	8a 81       	ldd	r24, Y+2	; 0x02
     d38:	28 2f       	mov	r18, r24
     d3a:	30 e0       	ldi	r19, 0x00	; 0
     d3c:	81 e0       	ldi	r24, 0x01	; 1
     d3e:	90 e0       	ldi	r25, 0x00	; 0
     d40:	02 2e       	mov	r0, r18
     d42:	02 c0       	rjmp	.+4      	; 0xd48 <MDIO_voidSetPinDirection+0x202>
     d44:	88 0f       	add	r24, r24
     d46:	99 1f       	adc	r25, r25
     d48:	0a 94       	dec	r0
     d4a:	e2 f7       	brpl	.-8      	; 0xd44 <MDIO_voidSetPinDirection+0x1fe>
     d4c:	80 95       	com	r24
     d4e:	84 23       	and	r24, r20
     d50:	8c 93       	st	X, r24
     d52:	13 c0       	rjmp	.+38     	; 0xd7a <MDIO_voidSetPinDirection+0x234>
				break;
			case DIO_OUTPUT:
				SET_BIT(DDRD_REG,A_PINID);
     d54:	a1 e3       	ldi	r26, 0x31	; 49
     d56:	b0 e0       	ldi	r27, 0x00	; 0
     d58:	e1 e3       	ldi	r30, 0x31	; 49
     d5a:	f0 e0       	ldi	r31, 0x00	; 0
     d5c:	80 81       	ld	r24, Z
     d5e:	48 2f       	mov	r20, r24
     d60:	8a 81       	ldd	r24, Y+2	; 0x02
     d62:	28 2f       	mov	r18, r24
     d64:	30 e0       	ldi	r19, 0x00	; 0
     d66:	81 e0       	ldi	r24, 0x01	; 1
     d68:	90 e0       	ldi	r25, 0x00	; 0
     d6a:	02 2e       	mov	r0, r18
     d6c:	02 c0       	rjmp	.+4      	; 0xd72 <MDIO_voidSetPinDirection+0x22c>
     d6e:	88 0f       	add	r24, r24
     d70:	99 1f       	adc	r25, r25
     d72:	0a 94       	dec	r0
     d74:	e2 f7       	brpl	.-8      	; 0xd6e <MDIO_voidSetPinDirection+0x228>
     d76:	84 2b       	or	r24, r20
     d78:	8c 93       	st	X, r24
	}
	else
	{
		// Do Nothing
	}
}
     d7a:	2d 96       	adiw	r28, 0x0d	; 13
     d7c:	0f b6       	in	r0, 0x3f	; 63
     d7e:	f8 94       	cli
     d80:	de bf       	out	0x3e, r29	; 62
     d82:	0f be       	out	0x3f, r0	; 63
     d84:	cd bf       	out	0x3d, r28	; 61
     d86:	cf 91       	pop	r28
     d88:	df 91       	pop	r29
     d8a:	08 95       	ret

00000d8c <MDIO_voidSetPinValue>:


void MDIO_voidSetPinValue (DIO_PORT_e A_DIOPort,DIO_PIN_e A_PINID, DIO_VALUE_e A_PINValue)
{
     d8c:	df 93       	push	r29
     d8e:	cf 93       	push	r28
     d90:	cd b7       	in	r28, 0x3d	; 61
     d92:	de b7       	in	r29, 0x3e	; 62
     d94:	2d 97       	sbiw	r28, 0x0d	; 13
     d96:	0f b6       	in	r0, 0x3f	; 63
     d98:	f8 94       	cli
     d9a:	de bf       	out	0x3e, r29	; 62
     d9c:	0f be       	out	0x3f, r0	; 63
     d9e:	cd bf       	out	0x3d, r28	; 61
     da0:	89 83       	std	Y+1, r24	; 0x01
     da2:	6a 83       	std	Y+2, r22	; 0x02
     da4:	4b 83       	std	Y+3, r20	; 0x03
	// Input Validation
	if ((A_DIOPort <= DIO_PORTD) && (A_PINID <= PIN7) && (A_PINValue <= DIO_SET))
     da6:	89 81       	ldd	r24, Y+1	; 0x01
     da8:	84 30       	cpi	r24, 0x04	; 4
     daa:	08 f0       	brcs	.+2      	; 0xdae <MDIO_voidSetPinValue+0x22>
     dac:	09 c1       	rjmp	.+530    	; 0xfc0 <MDIO_voidSetPinValue+0x234>
     dae:	8a 81       	ldd	r24, Y+2	; 0x02
     db0:	88 30       	cpi	r24, 0x08	; 8
     db2:	08 f0       	brcs	.+2      	; 0xdb6 <MDIO_voidSetPinValue+0x2a>
     db4:	05 c1       	rjmp	.+522    	; 0xfc0 <MDIO_voidSetPinValue+0x234>
     db6:	8b 81       	ldd	r24, Y+3	; 0x03
     db8:	82 30       	cpi	r24, 0x02	; 2
     dba:	08 f0       	brcs	.+2      	; 0xdbe <MDIO_voidSetPinValue+0x32>
     dbc:	01 c1       	rjmp	.+514    	; 0xfc0 <MDIO_voidSetPinValue+0x234>
	{
		switch (A_DIOPort)
     dbe:	89 81       	ldd	r24, Y+1	; 0x01
     dc0:	28 2f       	mov	r18, r24
     dc2:	30 e0       	ldi	r19, 0x00	; 0
     dc4:	3d 87       	std	Y+13, r19	; 0x0d
     dc6:	2c 87       	std	Y+12, r18	; 0x0c
     dc8:	8c 85       	ldd	r24, Y+12	; 0x0c
     dca:	9d 85       	ldd	r25, Y+13	; 0x0d
     dcc:	81 30       	cpi	r24, 0x01	; 1
     dce:	91 05       	cpc	r25, r1
     dd0:	09 f4       	brne	.+2      	; 0xdd4 <MDIO_voidSetPinValue+0x48>
     dd2:	4f c0       	rjmp	.+158    	; 0xe72 <MDIO_voidSetPinValue+0xe6>
     dd4:	2c 85       	ldd	r18, Y+12	; 0x0c
     dd6:	3d 85       	ldd	r19, Y+13	; 0x0d
     dd8:	22 30       	cpi	r18, 0x02	; 2
     dda:	31 05       	cpc	r19, r1
     ddc:	2c f4       	brge	.+10     	; 0xde8 <MDIO_voidSetPinValue+0x5c>
     dde:	8c 85       	ldd	r24, Y+12	; 0x0c
     de0:	9d 85       	ldd	r25, Y+13	; 0x0d
     de2:	00 97       	sbiw	r24, 0x00	; 0
     de4:	71 f0       	breq	.+28     	; 0xe02 <MDIO_voidSetPinValue+0x76>
     de6:	ec c0       	rjmp	.+472    	; 0xfc0 <MDIO_voidSetPinValue+0x234>
     de8:	2c 85       	ldd	r18, Y+12	; 0x0c
     dea:	3d 85       	ldd	r19, Y+13	; 0x0d
     dec:	22 30       	cpi	r18, 0x02	; 2
     dee:	31 05       	cpc	r19, r1
     df0:	09 f4       	brne	.+2      	; 0xdf4 <MDIO_voidSetPinValue+0x68>
     df2:	77 c0       	rjmp	.+238    	; 0xee2 <MDIO_voidSetPinValue+0x156>
     df4:	8c 85       	ldd	r24, Y+12	; 0x0c
     df6:	9d 85       	ldd	r25, Y+13	; 0x0d
     df8:	83 30       	cpi	r24, 0x03	; 3
     dfa:	91 05       	cpc	r25, r1
     dfc:	09 f4       	brne	.+2      	; 0xe00 <MDIO_voidSetPinValue+0x74>
     dfe:	a9 c0       	rjmp	.+338    	; 0xf52 <MDIO_voidSetPinValue+0x1c6>
     e00:	df c0       	rjmp	.+446    	; 0xfc0 <MDIO_voidSetPinValue+0x234>
		{
		case DIO_PORTA:
			switch (A_PINValue)
     e02:	8b 81       	ldd	r24, Y+3	; 0x03
     e04:	28 2f       	mov	r18, r24
     e06:	30 e0       	ldi	r19, 0x00	; 0
     e08:	3b 87       	std	Y+11, r19	; 0x0b
     e0a:	2a 87       	std	Y+10, r18	; 0x0a
     e0c:	8a 85       	ldd	r24, Y+10	; 0x0a
     e0e:	9b 85       	ldd	r25, Y+11	; 0x0b
     e10:	00 97       	sbiw	r24, 0x00	; 0
     e12:	31 f0       	breq	.+12     	; 0xe20 <MDIO_voidSetPinValue+0x94>
     e14:	2a 85       	ldd	r18, Y+10	; 0x0a
     e16:	3b 85       	ldd	r19, Y+11	; 0x0b
     e18:	21 30       	cpi	r18, 0x01	; 1
     e1a:	31 05       	cpc	r19, r1
     e1c:	b1 f0       	breq	.+44     	; 0xe4a <MDIO_voidSetPinValue+0xbe>
     e1e:	d0 c0       	rjmp	.+416    	; 0xfc0 <MDIO_voidSetPinValue+0x234>
			{
			case DIO_RESET:
				CLR_BIT(PORTA_REG,A_PINID);
     e20:	ab e3       	ldi	r26, 0x3B	; 59
     e22:	b0 e0       	ldi	r27, 0x00	; 0
     e24:	eb e3       	ldi	r30, 0x3B	; 59
     e26:	f0 e0       	ldi	r31, 0x00	; 0
     e28:	80 81       	ld	r24, Z
     e2a:	48 2f       	mov	r20, r24
     e2c:	8a 81       	ldd	r24, Y+2	; 0x02
     e2e:	28 2f       	mov	r18, r24
     e30:	30 e0       	ldi	r19, 0x00	; 0
     e32:	81 e0       	ldi	r24, 0x01	; 1
     e34:	90 e0       	ldi	r25, 0x00	; 0
     e36:	02 2e       	mov	r0, r18
     e38:	02 c0       	rjmp	.+4      	; 0xe3e <MDIO_voidSetPinValue+0xb2>
     e3a:	88 0f       	add	r24, r24
     e3c:	99 1f       	adc	r25, r25
     e3e:	0a 94       	dec	r0
     e40:	e2 f7       	brpl	.-8      	; 0xe3a <MDIO_voidSetPinValue+0xae>
     e42:	80 95       	com	r24
     e44:	84 23       	and	r24, r20
     e46:	8c 93       	st	X, r24
     e48:	bb c0       	rjmp	.+374    	; 0xfc0 <MDIO_voidSetPinValue+0x234>
				break;
			case DIO_SET:
				SET_BIT(PORTA_REG,A_PINID);
     e4a:	ab e3       	ldi	r26, 0x3B	; 59
     e4c:	b0 e0       	ldi	r27, 0x00	; 0
     e4e:	eb e3       	ldi	r30, 0x3B	; 59
     e50:	f0 e0       	ldi	r31, 0x00	; 0
     e52:	80 81       	ld	r24, Z
     e54:	48 2f       	mov	r20, r24
     e56:	8a 81       	ldd	r24, Y+2	; 0x02
     e58:	28 2f       	mov	r18, r24
     e5a:	30 e0       	ldi	r19, 0x00	; 0
     e5c:	81 e0       	ldi	r24, 0x01	; 1
     e5e:	90 e0       	ldi	r25, 0x00	; 0
     e60:	02 2e       	mov	r0, r18
     e62:	02 c0       	rjmp	.+4      	; 0xe68 <MDIO_voidSetPinValue+0xdc>
     e64:	88 0f       	add	r24, r24
     e66:	99 1f       	adc	r25, r25
     e68:	0a 94       	dec	r0
     e6a:	e2 f7       	brpl	.-8      	; 0xe64 <MDIO_voidSetPinValue+0xd8>
     e6c:	84 2b       	or	r24, r20
     e6e:	8c 93       	st	X, r24
     e70:	a7 c0       	rjmp	.+334    	; 0xfc0 <MDIO_voidSetPinValue+0x234>
				break;
			}
			break;
			// *******************************************
		case DIO_PORTB:
			switch (A_PINValue)
     e72:	8b 81       	ldd	r24, Y+3	; 0x03
     e74:	28 2f       	mov	r18, r24
     e76:	30 e0       	ldi	r19, 0x00	; 0
     e78:	39 87       	std	Y+9, r19	; 0x09
     e7a:	28 87       	std	Y+8, r18	; 0x08
     e7c:	88 85       	ldd	r24, Y+8	; 0x08
     e7e:	99 85       	ldd	r25, Y+9	; 0x09
     e80:	00 97       	sbiw	r24, 0x00	; 0
     e82:	31 f0       	breq	.+12     	; 0xe90 <MDIO_voidSetPinValue+0x104>
     e84:	28 85       	ldd	r18, Y+8	; 0x08
     e86:	39 85       	ldd	r19, Y+9	; 0x09
     e88:	21 30       	cpi	r18, 0x01	; 1
     e8a:	31 05       	cpc	r19, r1
     e8c:	b1 f0       	breq	.+44     	; 0xeba <MDIO_voidSetPinValue+0x12e>
     e8e:	98 c0       	rjmp	.+304    	; 0xfc0 <MDIO_voidSetPinValue+0x234>
			{
			case DIO_RESET:
				CLR_BIT(PORTB_REG,A_PINID);
     e90:	a8 e3       	ldi	r26, 0x38	; 56
     e92:	b0 e0       	ldi	r27, 0x00	; 0
     e94:	e8 e3       	ldi	r30, 0x38	; 56
     e96:	f0 e0       	ldi	r31, 0x00	; 0
     e98:	80 81       	ld	r24, Z
     e9a:	48 2f       	mov	r20, r24
     e9c:	8a 81       	ldd	r24, Y+2	; 0x02
     e9e:	28 2f       	mov	r18, r24
     ea0:	30 e0       	ldi	r19, 0x00	; 0
     ea2:	81 e0       	ldi	r24, 0x01	; 1
     ea4:	90 e0       	ldi	r25, 0x00	; 0
     ea6:	02 2e       	mov	r0, r18
     ea8:	02 c0       	rjmp	.+4      	; 0xeae <MDIO_voidSetPinValue+0x122>
     eaa:	88 0f       	add	r24, r24
     eac:	99 1f       	adc	r25, r25
     eae:	0a 94       	dec	r0
     eb0:	e2 f7       	brpl	.-8      	; 0xeaa <MDIO_voidSetPinValue+0x11e>
     eb2:	80 95       	com	r24
     eb4:	84 23       	and	r24, r20
     eb6:	8c 93       	st	X, r24
     eb8:	83 c0       	rjmp	.+262    	; 0xfc0 <MDIO_voidSetPinValue+0x234>
				break;
			case DIO_SET:
				SET_BIT(PORTB_REG,A_PINID);
     eba:	a8 e3       	ldi	r26, 0x38	; 56
     ebc:	b0 e0       	ldi	r27, 0x00	; 0
     ebe:	e8 e3       	ldi	r30, 0x38	; 56
     ec0:	f0 e0       	ldi	r31, 0x00	; 0
     ec2:	80 81       	ld	r24, Z
     ec4:	48 2f       	mov	r20, r24
     ec6:	8a 81       	ldd	r24, Y+2	; 0x02
     ec8:	28 2f       	mov	r18, r24
     eca:	30 e0       	ldi	r19, 0x00	; 0
     ecc:	81 e0       	ldi	r24, 0x01	; 1
     ece:	90 e0       	ldi	r25, 0x00	; 0
     ed0:	02 2e       	mov	r0, r18
     ed2:	02 c0       	rjmp	.+4      	; 0xed8 <MDIO_voidSetPinValue+0x14c>
     ed4:	88 0f       	add	r24, r24
     ed6:	99 1f       	adc	r25, r25
     ed8:	0a 94       	dec	r0
     eda:	e2 f7       	brpl	.-8      	; 0xed4 <MDIO_voidSetPinValue+0x148>
     edc:	84 2b       	or	r24, r20
     ede:	8c 93       	st	X, r24
     ee0:	6f c0       	rjmp	.+222    	; 0xfc0 <MDIO_voidSetPinValue+0x234>
				break;
			}
			break;
			// *******************************************
		case DIO_PORTC:
			switch (A_PINValue)
     ee2:	8b 81       	ldd	r24, Y+3	; 0x03
     ee4:	28 2f       	mov	r18, r24
     ee6:	30 e0       	ldi	r19, 0x00	; 0
     ee8:	3f 83       	std	Y+7, r19	; 0x07
     eea:	2e 83       	std	Y+6, r18	; 0x06
     eec:	8e 81       	ldd	r24, Y+6	; 0x06
     eee:	9f 81       	ldd	r25, Y+7	; 0x07
     ef0:	00 97       	sbiw	r24, 0x00	; 0
     ef2:	31 f0       	breq	.+12     	; 0xf00 <MDIO_voidSetPinValue+0x174>
     ef4:	2e 81       	ldd	r18, Y+6	; 0x06
     ef6:	3f 81       	ldd	r19, Y+7	; 0x07
     ef8:	21 30       	cpi	r18, 0x01	; 1
     efa:	31 05       	cpc	r19, r1
     efc:	b1 f0       	breq	.+44     	; 0xf2a <MDIO_voidSetPinValue+0x19e>
     efe:	60 c0       	rjmp	.+192    	; 0xfc0 <MDIO_voidSetPinValue+0x234>
			{
			case DIO_RESET:
				CLR_BIT(PORTC_REG,A_PINID);
     f00:	a5 e3       	ldi	r26, 0x35	; 53
     f02:	b0 e0       	ldi	r27, 0x00	; 0
     f04:	e5 e3       	ldi	r30, 0x35	; 53
     f06:	f0 e0       	ldi	r31, 0x00	; 0
     f08:	80 81       	ld	r24, Z
     f0a:	48 2f       	mov	r20, r24
     f0c:	8a 81       	ldd	r24, Y+2	; 0x02
     f0e:	28 2f       	mov	r18, r24
     f10:	30 e0       	ldi	r19, 0x00	; 0
     f12:	81 e0       	ldi	r24, 0x01	; 1
     f14:	90 e0       	ldi	r25, 0x00	; 0
     f16:	02 2e       	mov	r0, r18
     f18:	02 c0       	rjmp	.+4      	; 0xf1e <MDIO_voidSetPinValue+0x192>
     f1a:	88 0f       	add	r24, r24
     f1c:	99 1f       	adc	r25, r25
     f1e:	0a 94       	dec	r0
     f20:	e2 f7       	brpl	.-8      	; 0xf1a <MDIO_voidSetPinValue+0x18e>
     f22:	80 95       	com	r24
     f24:	84 23       	and	r24, r20
     f26:	8c 93       	st	X, r24
     f28:	4b c0       	rjmp	.+150    	; 0xfc0 <MDIO_voidSetPinValue+0x234>
				break;
			case DIO_SET:
				SET_BIT(PORTC_REG,A_PINID);
     f2a:	a5 e3       	ldi	r26, 0x35	; 53
     f2c:	b0 e0       	ldi	r27, 0x00	; 0
     f2e:	e5 e3       	ldi	r30, 0x35	; 53
     f30:	f0 e0       	ldi	r31, 0x00	; 0
     f32:	80 81       	ld	r24, Z
     f34:	48 2f       	mov	r20, r24
     f36:	8a 81       	ldd	r24, Y+2	; 0x02
     f38:	28 2f       	mov	r18, r24
     f3a:	30 e0       	ldi	r19, 0x00	; 0
     f3c:	81 e0       	ldi	r24, 0x01	; 1
     f3e:	90 e0       	ldi	r25, 0x00	; 0
     f40:	02 2e       	mov	r0, r18
     f42:	02 c0       	rjmp	.+4      	; 0xf48 <MDIO_voidSetPinValue+0x1bc>
     f44:	88 0f       	add	r24, r24
     f46:	99 1f       	adc	r25, r25
     f48:	0a 94       	dec	r0
     f4a:	e2 f7       	brpl	.-8      	; 0xf44 <MDIO_voidSetPinValue+0x1b8>
     f4c:	84 2b       	or	r24, r20
     f4e:	8c 93       	st	X, r24
     f50:	37 c0       	rjmp	.+110    	; 0xfc0 <MDIO_voidSetPinValue+0x234>
				break;
			}
			break;
			// *******************************************
		case DIO_PORTD:
			switch (A_PINValue)
     f52:	8b 81       	ldd	r24, Y+3	; 0x03
     f54:	28 2f       	mov	r18, r24
     f56:	30 e0       	ldi	r19, 0x00	; 0
     f58:	3d 83       	std	Y+5, r19	; 0x05
     f5a:	2c 83       	std	Y+4, r18	; 0x04
     f5c:	8c 81       	ldd	r24, Y+4	; 0x04
     f5e:	9d 81       	ldd	r25, Y+5	; 0x05
     f60:	00 97       	sbiw	r24, 0x00	; 0
     f62:	31 f0       	breq	.+12     	; 0xf70 <MDIO_voidSetPinValue+0x1e4>
     f64:	2c 81       	ldd	r18, Y+4	; 0x04
     f66:	3d 81       	ldd	r19, Y+5	; 0x05
     f68:	21 30       	cpi	r18, 0x01	; 1
     f6a:	31 05       	cpc	r19, r1
     f6c:	b1 f0       	breq	.+44     	; 0xf9a <MDIO_voidSetPinValue+0x20e>
     f6e:	28 c0       	rjmp	.+80     	; 0xfc0 <MDIO_voidSetPinValue+0x234>
			{
			case DIO_RESET:
				CLR_BIT(PORTD_REG,A_PINID);
     f70:	a2 e3       	ldi	r26, 0x32	; 50
     f72:	b0 e0       	ldi	r27, 0x00	; 0
     f74:	e2 e3       	ldi	r30, 0x32	; 50
     f76:	f0 e0       	ldi	r31, 0x00	; 0
     f78:	80 81       	ld	r24, Z
     f7a:	48 2f       	mov	r20, r24
     f7c:	8a 81       	ldd	r24, Y+2	; 0x02
     f7e:	28 2f       	mov	r18, r24
     f80:	30 e0       	ldi	r19, 0x00	; 0
     f82:	81 e0       	ldi	r24, 0x01	; 1
     f84:	90 e0       	ldi	r25, 0x00	; 0
     f86:	02 2e       	mov	r0, r18
     f88:	02 c0       	rjmp	.+4      	; 0xf8e <MDIO_voidSetPinValue+0x202>
     f8a:	88 0f       	add	r24, r24
     f8c:	99 1f       	adc	r25, r25
     f8e:	0a 94       	dec	r0
     f90:	e2 f7       	brpl	.-8      	; 0xf8a <MDIO_voidSetPinValue+0x1fe>
     f92:	80 95       	com	r24
     f94:	84 23       	and	r24, r20
     f96:	8c 93       	st	X, r24
     f98:	13 c0       	rjmp	.+38     	; 0xfc0 <MDIO_voidSetPinValue+0x234>
				break;
			case DIO_SET:
				SET_BIT(PORTD_REG,A_PINID);
     f9a:	a2 e3       	ldi	r26, 0x32	; 50
     f9c:	b0 e0       	ldi	r27, 0x00	; 0
     f9e:	e2 e3       	ldi	r30, 0x32	; 50
     fa0:	f0 e0       	ldi	r31, 0x00	; 0
     fa2:	80 81       	ld	r24, Z
     fa4:	48 2f       	mov	r20, r24
     fa6:	8a 81       	ldd	r24, Y+2	; 0x02
     fa8:	28 2f       	mov	r18, r24
     faa:	30 e0       	ldi	r19, 0x00	; 0
     fac:	81 e0       	ldi	r24, 0x01	; 1
     fae:	90 e0       	ldi	r25, 0x00	; 0
     fb0:	02 2e       	mov	r0, r18
     fb2:	02 c0       	rjmp	.+4      	; 0xfb8 <MDIO_voidSetPinValue+0x22c>
     fb4:	88 0f       	add	r24, r24
     fb6:	99 1f       	adc	r25, r25
     fb8:	0a 94       	dec	r0
     fba:	e2 f7       	brpl	.-8      	; 0xfb4 <MDIO_voidSetPinValue+0x228>
     fbc:	84 2b       	or	r24, r20
     fbe:	8c 93       	st	X, r24
	}
	else
	{
		// Do Nothing
	}
}
     fc0:	2d 96       	adiw	r28, 0x0d	; 13
     fc2:	0f b6       	in	r0, 0x3f	; 63
     fc4:	f8 94       	cli
     fc6:	de bf       	out	0x3e, r29	; 62
     fc8:	0f be       	out	0x3f, r0	; 63
     fca:	cd bf       	out	0x3d, r28	; 61
     fcc:	cf 91       	pop	r28
     fce:	df 91       	pop	r29
     fd0:	08 95       	ret

00000fd2 <MDIO_GetPinValue>:


DIO_VALUE_e MDIO_GetPinValue (DIO_PORT_e A_DIOPort,DIO_PIN_e A_PINID)
{
     fd2:	df 93       	push	r29
     fd4:	cf 93       	push	r28
     fd6:	00 d0       	rcall	.+0      	; 0xfd8 <MDIO_GetPinValue+0x6>
     fd8:	00 d0       	rcall	.+0      	; 0xfda <MDIO_GetPinValue+0x8>
     fda:	0f 92       	push	r0
     fdc:	cd b7       	in	r28, 0x3d	; 61
     fde:	de b7       	in	r29, 0x3e	; 62
     fe0:	8a 83       	std	Y+2, r24	; 0x02
     fe2:	6b 83       	std	Y+3, r22	; 0x03
	DIO_VALUE_e local_PINValue;
	if ((A_DIOPort <= DIO_PORTD) && (A_PINID <= PIN7))
     fe4:	8a 81       	ldd	r24, Y+2	; 0x02
     fe6:	84 30       	cpi	r24, 0x04	; 4
     fe8:	08 f0       	brcs	.+2      	; 0xfec <MDIO_GetPinValue+0x1a>
     fea:	6b c0       	rjmp	.+214    	; 0x10c2 <MDIO_GetPinValue+0xf0>
     fec:	8b 81       	ldd	r24, Y+3	; 0x03
     fee:	88 30       	cpi	r24, 0x08	; 8
     ff0:	08 f0       	brcs	.+2      	; 0xff4 <MDIO_GetPinValue+0x22>
     ff2:	67 c0       	rjmp	.+206    	; 0x10c2 <MDIO_GetPinValue+0xf0>
	{
		switch (A_DIOPort)
     ff4:	8a 81       	ldd	r24, Y+2	; 0x02
     ff6:	28 2f       	mov	r18, r24
     ff8:	30 e0       	ldi	r19, 0x00	; 0
     ffa:	3d 83       	std	Y+5, r19	; 0x05
     ffc:	2c 83       	std	Y+4, r18	; 0x04
     ffe:	4c 81       	ldd	r20, Y+4	; 0x04
    1000:	5d 81       	ldd	r21, Y+5	; 0x05
    1002:	41 30       	cpi	r20, 0x01	; 1
    1004:	51 05       	cpc	r21, r1
    1006:	41 f1       	breq	.+80     	; 0x1058 <MDIO_GetPinValue+0x86>
    1008:	8c 81       	ldd	r24, Y+4	; 0x04
    100a:	9d 81       	ldd	r25, Y+5	; 0x05
    100c:	82 30       	cpi	r24, 0x02	; 2
    100e:	91 05       	cpc	r25, r1
    1010:	34 f4       	brge	.+12     	; 0x101e <MDIO_GetPinValue+0x4c>
    1012:	2c 81       	ldd	r18, Y+4	; 0x04
    1014:	3d 81       	ldd	r19, Y+5	; 0x05
    1016:	21 15       	cp	r18, r1
    1018:	31 05       	cpc	r19, r1
    101a:	61 f0       	breq	.+24     	; 0x1034 <MDIO_GetPinValue+0x62>
    101c:	52 c0       	rjmp	.+164    	; 0x10c2 <MDIO_GetPinValue+0xf0>
    101e:	4c 81       	ldd	r20, Y+4	; 0x04
    1020:	5d 81       	ldd	r21, Y+5	; 0x05
    1022:	42 30       	cpi	r20, 0x02	; 2
    1024:	51 05       	cpc	r21, r1
    1026:	51 f1       	breq	.+84     	; 0x107c <MDIO_GetPinValue+0xaa>
    1028:	8c 81       	ldd	r24, Y+4	; 0x04
    102a:	9d 81       	ldd	r25, Y+5	; 0x05
    102c:	83 30       	cpi	r24, 0x03	; 3
    102e:	91 05       	cpc	r25, r1
    1030:	b9 f1       	breq	.+110    	; 0x10a0 <MDIO_GetPinValue+0xce>
    1032:	47 c0       	rjmp	.+142    	; 0x10c2 <MDIO_GetPinValue+0xf0>
		{
		case DIO_PORTA:
			local_PINValue = GET_BIT(PINA_REG,A_PINID);
    1034:	e9 e3       	ldi	r30, 0x39	; 57
    1036:	f0 e0       	ldi	r31, 0x00	; 0
    1038:	80 81       	ld	r24, Z
    103a:	28 2f       	mov	r18, r24
    103c:	30 e0       	ldi	r19, 0x00	; 0
    103e:	8b 81       	ldd	r24, Y+3	; 0x03
    1040:	88 2f       	mov	r24, r24
    1042:	90 e0       	ldi	r25, 0x00	; 0
    1044:	a9 01       	movw	r20, r18
    1046:	02 c0       	rjmp	.+4      	; 0x104c <MDIO_GetPinValue+0x7a>
    1048:	55 95       	asr	r21
    104a:	47 95       	ror	r20
    104c:	8a 95       	dec	r24
    104e:	e2 f7       	brpl	.-8      	; 0x1048 <MDIO_GetPinValue+0x76>
    1050:	ca 01       	movw	r24, r20
    1052:	81 70       	andi	r24, 0x01	; 1
    1054:	89 83       	std	Y+1, r24	; 0x01
    1056:	35 c0       	rjmp	.+106    	; 0x10c2 <MDIO_GetPinValue+0xf0>
			break;
		case DIO_PORTB:
			local_PINValue = GET_BIT(PINB_REG,A_PINID);
    1058:	e6 e3       	ldi	r30, 0x36	; 54
    105a:	f0 e0       	ldi	r31, 0x00	; 0
    105c:	80 81       	ld	r24, Z
    105e:	28 2f       	mov	r18, r24
    1060:	30 e0       	ldi	r19, 0x00	; 0
    1062:	8b 81       	ldd	r24, Y+3	; 0x03
    1064:	88 2f       	mov	r24, r24
    1066:	90 e0       	ldi	r25, 0x00	; 0
    1068:	a9 01       	movw	r20, r18
    106a:	02 c0       	rjmp	.+4      	; 0x1070 <MDIO_GetPinValue+0x9e>
    106c:	55 95       	asr	r21
    106e:	47 95       	ror	r20
    1070:	8a 95       	dec	r24
    1072:	e2 f7       	brpl	.-8      	; 0x106c <MDIO_GetPinValue+0x9a>
    1074:	ca 01       	movw	r24, r20
    1076:	81 70       	andi	r24, 0x01	; 1
    1078:	89 83       	std	Y+1, r24	; 0x01
    107a:	23 c0       	rjmp	.+70     	; 0x10c2 <MDIO_GetPinValue+0xf0>
			break;
		case DIO_PORTC:
			local_PINValue = GET_BIT(PINC_REG,A_PINID);
    107c:	e3 e3       	ldi	r30, 0x33	; 51
    107e:	f0 e0       	ldi	r31, 0x00	; 0
    1080:	80 81       	ld	r24, Z
    1082:	28 2f       	mov	r18, r24
    1084:	30 e0       	ldi	r19, 0x00	; 0
    1086:	8b 81       	ldd	r24, Y+3	; 0x03
    1088:	88 2f       	mov	r24, r24
    108a:	90 e0       	ldi	r25, 0x00	; 0
    108c:	a9 01       	movw	r20, r18
    108e:	02 c0       	rjmp	.+4      	; 0x1094 <MDIO_GetPinValue+0xc2>
    1090:	55 95       	asr	r21
    1092:	47 95       	ror	r20
    1094:	8a 95       	dec	r24
    1096:	e2 f7       	brpl	.-8      	; 0x1090 <MDIO_GetPinValue+0xbe>
    1098:	ca 01       	movw	r24, r20
    109a:	81 70       	andi	r24, 0x01	; 1
    109c:	89 83       	std	Y+1, r24	; 0x01
    109e:	11 c0       	rjmp	.+34     	; 0x10c2 <MDIO_GetPinValue+0xf0>
			break;
		case DIO_PORTD:
			local_PINValue = GET_BIT(PIND_REG,A_PINID);
    10a0:	e0 e3       	ldi	r30, 0x30	; 48
    10a2:	f0 e0       	ldi	r31, 0x00	; 0
    10a4:	80 81       	ld	r24, Z
    10a6:	28 2f       	mov	r18, r24
    10a8:	30 e0       	ldi	r19, 0x00	; 0
    10aa:	8b 81       	ldd	r24, Y+3	; 0x03
    10ac:	88 2f       	mov	r24, r24
    10ae:	90 e0       	ldi	r25, 0x00	; 0
    10b0:	a9 01       	movw	r20, r18
    10b2:	02 c0       	rjmp	.+4      	; 0x10b8 <MDIO_GetPinValue+0xe6>
    10b4:	55 95       	asr	r21
    10b6:	47 95       	ror	r20
    10b8:	8a 95       	dec	r24
    10ba:	e2 f7       	brpl	.-8      	; 0x10b4 <MDIO_GetPinValue+0xe2>
    10bc:	ca 01       	movw	r24, r20
    10be:	81 70       	andi	r24, 0x01	; 1
    10c0:	89 83       	std	Y+1, r24	; 0x01
			break;
		default:
			break;
		}
	}
	return local_PINValue;
    10c2:	89 81       	ldd	r24, Y+1	; 0x01
}
    10c4:	0f 90       	pop	r0
    10c6:	0f 90       	pop	r0
    10c8:	0f 90       	pop	r0
    10ca:	0f 90       	pop	r0
    10cc:	0f 90       	pop	r0
    10ce:	cf 91       	pop	r28
    10d0:	df 91       	pop	r29
    10d2:	08 95       	ret

000010d4 <MDIO_voidTogglePinValue>:

void MDIO_voidTogglePinValue (DIO_PORT_e A_DIOPort,DIO_PIN_e A_PINID)
{
    10d4:	df 93       	push	r29
    10d6:	cf 93       	push	r28
    10d8:	00 d0       	rcall	.+0      	; 0x10da <MDIO_voidTogglePinValue+0x6>
    10da:	00 d0       	rcall	.+0      	; 0x10dc <MDIO_voidTogglePinValue+0x8>
    10dc:	cd b7       	in	r28, 0x3d	; 61
    10de:	de b7       	in	r29, 0x3e	; 62
    10e0:	89 83       	std	Y+1, r24	; 0x01
    10e2:	6a 83       	std	Y+2, r22	; 0x02
	if ((A_DIOPort <= DIO_PORTD) && (A_PINID <= PIN7))
    10e4:	89 81       	ldd	r24, Y+1	; 0x01
    10e6:	84 30       	cpi	r24, 0x04	; 4
    10e8:	08 f0       	brcs	.+2      	; 0x10ec <MDIO_voidTogglePinValue+0x18>
    10ea:	72 c0       	rjmp	.+228    	; 0x11d0 <MDIO_voidTogglePinValue+0xfc>
    10ec:	8a 81       	ldd	r24, Y+2	; 0x02
    10ee:	88 30       	cpi	r24, 0x08	; 8
    10f0:	08 f0       	brcs	.+2      	; 0x10f4 <MDIO_voidTogglePinValue+0x20>
    10f2:	6e c0       	rjmp	.+220    	; 0x11d0 <MDIO_voidTogglePinValue+0xfc>
	{
		switch (A_DIOPort)
    10f4:	89 81       	ldd	r24, Y+1	; 0x01
    10f6:	28 2f       	mov	r18, r24
    10f8:	30 e0       	ldi	r19, 0x00	; 0
    10fa:	3c 83       	std	Y+4, r19	; 0x04
    10fc:	2b 83       	std	Y+3, r18	; 0x03
    10fe:	8b 81       	ldd	r24, Y+3	; 0x03
    1100:	9c 81       	ldd	r25, Y+4	; 0x04
    1102:	81 30       	cpi	r24, 0x01	; 1
    1104:	91 05       	cpc	r25, r1
    1106:	49 f1       	breq	.+82     	; 0x115a <MDIO_voidTogglePinValue+0x86>
    1108:	2b 81       	ldd	r18, Y+3	; 0x03
    110a:	3c 81       	ldd	r19, Y+4	; 0x04
    110c:	22 30       	cpi	r18, 0x02	; 2
    110e:	31 05       	cpc	r19, r1
    1110:	2c f4       	brge	.+10     	; 0x111c <MDIO_voidTogglePinValue+0x48>
    1112:	8b 81       	ldd	r24, Y+3	; 0x03
    1114:	9c 81       	ldd	r25, Y+4	; 0x04
    1116:	00 97       	sbiw	r24, 0x00	; 0
    1118:	61 f0       	breq	.+24     	; 0x1132 <MDIO_voidTogglePinValue+0x5e>
    111a:	5a c0       	rjmp	.+180    	; 0x11d0 <MDIO_voidTogglePinValue+0xfc>
    111c:	2b 81       	ldd	r18, Y+3	; 0x03
    111e:	3c 81       	ldd	r19, Y+4	; 0x04
    1120:	22 30       	cpi	r18, 0x02	; 2
    1122:	31 05       	cpc	r19, r1
    1124:	71 f1       	breq	.+92     	; 0x1182 <MDIO_voidTogglePinValue+0xae>
    1126:	8b 81       	ldd	r24, Y+3	; 0x03
    1128:	9c 81       	ldd	r25, Y+4	; 0x04
    112a:	83 30       	cpi	r24, 0x03	; 3
    112c:	91 05       	cpc	r25, r1
    112e:	e9 f1       	breq	.+122    	; 0x11aa <MDIO_voidTogglePinValue+0xd6>
    1130:	4f c0       	rjmp	.+158    	; 0x11d0 <MDIO_voidTogglePinValue+0xfc>
		{
		case DIO_PORTA:
			TOGGLE_BIT(PORTA_REG,A_PINID);
    1132:	ab e3       	ldi	r26, 0x3B	; 59
    1134:	b0 e0       	ldi	r27, 0x00	; 0
    1136:	eb e3       	ldi	r30, 0x3B	; 59
    1138:	f0 e0       	ldi	r31, 0x00	; 0
    113a:	80 81       	ld	r24, Z
    113c:	48 2f       	mov	r20, r24
    113e:	8a 81       	ldd	r24, Y+2	; 0x02
    1140:	28 2f       	mov	r18, r24
    1142:	30 e0       	ldi	r19, 0x00	; 0
    1144:	81 e0       	ldi	r24, 0x01	; 1
    1146:	90 e0       	ldi	r25, 0x00	; 0
    1148:	02 2e       	mov	r0, r18
    114a:	02 c0       	rjmp	.+4      	; 0x1150 <MDIO_voidTogglePinValue+0x7c>
    114c:	88 0f       	add	r24, r24
    114e:	99 1f       	adc	r25, r25
    1150:	0a 94       	dec	r0
    1152:	e2 f7       	brpl	.-8      	; 0x114c <MDIO_voidTogglePinValue+0x78>
    1154:	84 27       	eor	r24, r20
    1156:	8c 93       	st	X, r24
    1158:	3b c0       	rjmp	.+118    	; 0x11d0 <MDIO_voidTogglePinValue+0xfc>
			break;
		case DIO_PORTB:
			TOGGLE_BIT(PORTB_REG,A_PINID);
    115a:	a8 e3       	ldi	r26, 0x38	; 56
    115c:	b0 e0       	ldi	r27, 0x00	; 0
    115e:	e8 e3       	ldi	r30, 0x38	; 56
    1160:	f0 e0       	ldi	r31, 0x00	; 0
    1162:	80 81       	ld	r24, Z
    1164:	48 2f       	mov	r20, r24
    1166:	8a 81       	ldd	r24, Y+2	; 0x02
    1168:	28 2f       	mov	r18, r24
    116a:	30 e0       	ldi	r19, 0x00	; 0
    116c:	81 e0       	ldi	r24, 0x01	; 1
    116e:	90 e0       	ldi	r25, 0x00	; 0
    1170:	02 2e       	mov	r0, r18
    1172:	02 c0       	rjmp	.+4      	; 0x1178 <MDIO_voidTogglePinValue+0xa4>
    1174:	88 0f       	add	r24, r24
    1176:	99 1f       	adc	r25, r25
    1178:	0a 94       	dec	r0
    117a:	e2 f7       	brpl	.-8      	; 0x1174 <MDIO_voidTogglePinValue+0xa0>
    117c:	84 27       	eor	r24, r20
    117e:	8c 93       	st	X, r24
    1180:	27 c0       	rjmp	.+78     	; 0x11d0 <MDIO_voidTogglePinValue+0xfc>
			break;
		case DIO_PORTC:
			TOGGLE_BIT(PORTC_REG,A_PINID);
    1182:	a5 e3       	ldi	r26, 0x35	; 53
    1184:	b0 e0       	ldi	r27, 0x00	; 0
    1186:	e5 e3       	ldi	r30, 0x35	; 53
    1188:	f0 e0       	ldi	r31, 0x00	; 0
    118a:	80 81       	ld	r24, Z
    118c:	48 2f       	mov	r20, r24
    118e:	8a 81       	ldd	r24, Y+2	; 0x02
    1190:	28 2f       	mov	r18, r24
    1192:	30 e0       	ldi	r19, 0x00	; 0
    1194:	81 e0       	ldi	r24, 0x01	; 1
    1196:	90 e0       	ldi	r25, 0x00	; 0
    1198:	02 2e       	mov	r0, r18
    119a:	02 c0       	rjmp	.+4      	; 0x11a0 <MDIO_voidTogglePinValue+0xcc>
    119c:	88 0f       	add	r24, r24
    119e:	99 1f       	adc	r25, r25
    11a0:	0a 94       	dec	r0
    11a2:	e2 f7       	brpl	.-8      	; 0x119c <MDIO_voidTogglePinValue+0xc8>
    11a4:	84 27       	eor	r24, r20
    11a6:	8c 93       	st	X, r24
    11a8:	13 c0       	rjmp	.+38     	; 0x11d0 <MDIO_voidTogglePinValue+0xfc>
			break;
		case DIO_PORTD:
			TOGGLE_BIT(PORTD_REG,A_PINID);
    11aa:	a2 e3       	ldi	r26, 0x32	; 50
    11ac:	b0 e0       	ldi	r27, 0x00	; 0
    11ae:	e2 e3       	ldi	r30, 0x32	; 50
    11b0:	f0 e0       	ldi	r31, 0x00	; 0
    11b2:	80 81       	ld	r24, Z
    11b4:	48 2f       	mov	r20, r24
    11b6:	8a 81       	ldd	r24, Y+2	; 0x02
    11b8:	28 2f       	mov	r18, r24
    11ba:	30 e0       	ldi	r19, 0x00	; 0
    11bc:	81 e0       	ldi	r24, 0x01	; 1
    11be:	90 e0       	ldi	r25, 0x00	; 0
    11c0:	02 2e       	mov	r0, r18
    11c2:	02 c0       	rjmp	.+4      	; 0x11c8 <MDIO_voidTogglePinValue+0xf4>
    11c4:	88 0f       	add	r24, r24
    11c6:	99 1f       	adc	r25, r25
    11c8:	0a 94       	dec	r0
    11ca:	e2 f7       	brpl	.-8      	; 0x11c4 <MDIO_voidTogglePinValue+0xf0>
    11cc:	84 27       	eor	r24, r20
    11ce:	8c 93       	st	X, r24
			break;
		default:
			break;
		}
	}
}
    11d0:	0f 90       	pop	r0
    11d2:	0f 90       	pop	r0
    11d4:	0f 90       	pop	r0
    11d6:	0f 90       	pop	r0
    11d8:	cf 91       	pop	r28
    11da:	df 91       	pop	r29
    11dc:	08 95       	ret

000011de <MDIO_voidSetPortDirection>:

void MDIO_voidSetPortDirection (DIO_PORT_e A_DIOPort, u8 A_u8Direction)
{
    11de:	df 93       	push	r29
    11e0:	cf 93       	push	r28
    11e2:	00 d0       	rcall	.+0      	; 0x11e4 <MDIO_voidSetPortDirection+0x6>
    11e4:	00 d0       	rcall	.+0      	; 0x11e6 <MDIO_voidSetPortDirection+0x8>
    11e6:	cd b7       	in	r28, 0x3d	; 61
    11e8:	de b7       	in	r29, 0x3e	; 62
    11ea:	89 83       	std	Y+1, r24	; 0x01
    11ec:	6a 83       	std	Y+2, r22	; 0x02
	if ((A_DIOPort <= DIO_PORTD))
    11ee:	89 81       	ldd	r24, Y+1	; 0x01
    11f0:	84 30       	cpi	r24, 0x04	; 4
    11f2:	90 f5       	brcc	.+100    	; 0x1258 <MDIO_voidSetPortDirection+0x7a>
	{
		switch (A_DIOPort)
    11f4:	89 81       	ldd	r24, Y+1	; 0x01
    11f6:	28 2f       	mov	r18, r24
    11f8:	30 e0       	ldi	r19, 0x00	; 0
    11fa:	3c 83       	std	Y+4, r19	; 0x04
    11fc:	2b 83       	std	Y+3, r18	; 0x03
    11fe:	8b 81       	ldd	r24, Y+3	; 0x03
    1200:	9c 81       	ldd	r25, Y+4	; 0x04
    1202:	81 30       	cpi	r24, 0x01	; 1
    1204:	91 05       	cpc	r25, r1
    1206:	d1 f0       	breq	.+52     	; 0x123c <MDIO_voidSetPortDirection+0x5e>
    1208:	2b 81       	ldd	r18, Y+3	; 0x03
    120a:	3c 81       	ldd	r19, Y+4	; 0x04
    120c:	22 30       	cpi	r18, 0x02	; 2
    120e:	31 05       	cpc	r19, r1
    1210:	2c f4       	brge	.+10     	; 0x121c <MDIO_voidSetPortDirection+0x3e>
    1212:	8b 81       	ldd	r24, Y+3	; 0x03
    1214:	9c 81       	ldd	r25, Y+4	; 0x04
    1216:	00 97       	sbiw	r24, 0x00	; 0
    1218:	61 f0       	breq	.+24     	; 0x1232 <MDIO_voidSetPortDirection+0x54>
    121a:	1e c0       	rjmp	.+60     	; 0x1258 <MDIO_voidSetPortDirection+0x7a>
    121c:	2b 81       	ldd	r18, Y+3	; 0x03
    121e:	3c 81       	ldd	r19, Y+4	; 0x04
    1220:	22 30       	cpi	r18, 0x02	; 2
    1222:	31 05       	cpc	r19, r1
    1224:	81 f0       	breq	.+32     	; 0x1246 <MDIO_voidSetPortDirection+0x68>
    1226:	8b 81       	ldd	r24, Y+3	; 0x03
    1228:	9c 81       	ldd	r25, Y+4	; 0x04
    122a:	83 30       	cpi	r24, 0x03	; 3
    122c:	91 05       	cpc	r25, r1
    122e:	81 f0       	breq	.+32     	; 0x1250 <MDIO_voidSetPortDirection+0x72>
    1230:	13 c0       	rjmp	.+38     	; 0x1258 <MDIO_voidSetPortDirection+0x7a>
		{
		case DIO_PORTA:
			DDRA_REG = A_u8Direction;
    1232:	ea e3       	ldi	r30, 0x3A	; 58
    1234:	f0 e0       	ldi	r31, 0x00	; 0
    1236:	8a 81       	ldd	r24, Y+2	; 0x02
    1238:	80 83       	st	Z, r24
    123a:	0e c0       	rjmp	.+28     	; 0x1258 <MDIO_voidSetPortDirection+0x7a>
			break;
		case DIO_PORTB:
			DDRB_REG = A_u8Direction;
    123c:	e7 e3       	ldi	r30, 0x37	; 55
    123e:	f0 e0       	ldi	r31, 0x00	; 0
    1240:	8a 81       	ldd	r24, Y+2	; 0x02
    1242:	80 83       	st	Z, r24
    1244:	09 c0       	rjmp	.+18     	; 0x1258 <MDIO_voidSetPortDirection+0x7a>
			break;
		case DIO_PORTC:
			DDRC_REG = A_u8Direction;
    1246:	e4 e3       	ldi	r30, 0x34	; 52
    1248:	f0 e0       	ldi	r31, 0x00	; 0
    124a:	8a 81       	ldd	r24, Y+2	; 0x02
    124c:	80 83       	st	Z, r24
    124e:	04 c0       	rjmp	.+8      	; 0x1258 <MDIO_voidSetPortDirection+0x7a>
			break;
		case DIO_PORTD:
			DDRD_REG = A_u8Direction;
    1250:	e1 e3       	ldi	r30, 0x31	; 49
    1252:	f0 e0       	ldi	r31, 0x00	; 0
    1254:	8a 81       	ldd	r24, Y+2	; 0x02
    1256:	80 83       	st	Z, r24
			break;
		default:
			break;
		}
	}
}
    1258:	0f 90       	pop	r0
    125a:	0f 90       	pop	r0
    125c:	0f 90       	pop	r0
    125e:	0f 90       	pop	r0
    1260:	cf 91       	pop	r28
    1262:	df 91       	pop	r29
    1264:	08 95       	ret

00001266 <MDIO_voidSetPortValue>:

void MDIO_voidSetPortValue (DIO_PORT_e A_DIOPort, u8 A_u8Value)
{
    1266:	df 93       	push	r29
    1268:	cf 93       	push	r28
    126a:	00 d0       	rcall	.+0      	; 0x126c <MDIO_voidSetPortValue+0x6>
    126c:	00 d0       	rcall	.+0      	; 0x126e <MDIO_voidSetPortValue+0x8>
    126e:	cd b7       	in	r28, 0x3d	; 61
    1270:	de b7       	in	r29, 0x3e	; 62
    1272:	89 83       	std	Y+1, r24	; 0x01
    1274:	6a 83       	std	Y+2, r22	; 0x02
	if ((A_DIOPort <= DIO_PORTD))
    1276:	89 81       	ldd	r24, Y+1	; 0x01
    1278:	84 30       	cpi	r24, 0x04	; 4
    127a:	90 f5       	brcc	.+100    	; 0x12e0 <MDIO_voidSetPortValue+0x7a>
	{
		switch (A_DIOPort)
    127c:	89 81       	ldd	r24, Y+1	; 0x01
    127e:	28 2f       	mov	r18, r24
    1280:	30 e0       	ldi	r19, 0x00	; 0
    1282:	3c 83       	std	Y+4, r19	; 0x04
    1284:	2b 83       	std	Y+3, r18	; 0x03
    1286:	8b 81       	ldd	r24, Y+3	; 0x03
    1288:	9c 81       	ldd	r25, Y+4	; 0x04
    128a:	81 30       	cpi	r24, 0x01	; 1
    128c:	91 05       	cpc	r25, r1
    128e:	d1 f0       	breq	.+52     	; 0x12c4 <MDIO_voidSetPortValue+0x5e>
    1290:	2b 81       	ldd	r18, Y+3	; 0x03
    1292:	3c 81       	ldd	r19, Y+4	; 0x04
    1294:	22 30       	cpi	r18, 0x02	; 2
    1296:	31 05       	cpc	r19, r1
    1298:	2c f4       	brge	.+10     	; 0x12a4 <MDIO_voidSetPortValue+0x3e>
    129a:	8b 81       	ldd	r24, Y+3	; 0x03
    129c:	9c 81       	ldd	r25, Y+4	; 0x04
    129e:	00 97       	sbiw	r24, 0x00	; 0
    12a0:	61 f0       	breq	.+24     	; 0x12ba <MDIO_voidSetPortValue+0x54>
    12a2:	1e c0       	rjmp	.+60     	; 0x12e0 <MDIO_voidSetPortValue+0x7a>
    12a4:	2b 81       	ldd	r18, Y+3	; 0x03
    12a6:	3c 81       	ldd	r19, Y+4	; 0x04
    12a8:	22 30       	cpi	r18, 0x02	; 2
    12aa:	31 05       	cpc	r19, r1
    12ac:	81 f0       	breq	.+32     	; 0x12ce <MDIO_voidSetPortValue+0x68>
    12ae:	8b 81       	ldd	r24, Y+3	; 0x03
    12b0:	9c 81       	ldd	r25, Y+4	; 0x04
    12b2:	83 30       	cpi	r24, 0x03	; 3
    12b4:	91 05       	cpc	r25, r1
    12b6:	81 f0       	breq	.+32     	; 0x12d8 <MDIO_voidSetPortValue+0x72>
    12b8:	13 c0       	rjmp	.+38     	; 0x12e0 <MDIO_voidSetPortValue+0x7a>
		{
		case DIO_PORTA:
			PORTA_REG = A_u8Value;
    12ba:	eb e3       	ldi	r30, 0x3B	; 59
    12bc:	f0 e0       	ldi	r31, 0x00	; 0
    12be:	8a 81       	ldd	r24, Y+2	; 0x02
    12c0:	80 83       	st	Z, r24
    12c2:	0e c0       	rjmp	.+28     	; 0x12e0 <MDIO_voidSetPortValue+0x7a>
			break;
		case DIO_PORTB:
			PORTB_REG = A_u8Value;
    12c4:	e8 e3       	ldi	r30, 0x38	; 56
    12c6:	f0 e0       	ldi	r31, 0x00	; 0
    12c8:	8a 81       	ldd	r24, Y+2	; 0x02
    12ca:	80 83       	st	Z, r24
    12cc:	09 c0       	rjmp	.+18     	; 0x12e0 <MDIO_voidSetPortValue+0x7a>
			break;
		case DIO_PORTC:
			PORTC_REG = A_u8Value;
    12ce:	e5 e3       	ldi	r30, 0x35	; 53
    12d0:	f0 e0       	ldi	r31, 0x00	; 0
    12d2:	8a 81       	ldd	r24, Y+2	; 0x02
    12d4:	80 83       	st	Z, r24
    12d6:	04 c0       	rjmp	.+8      	; 0x12e0 <MDIO_voidSetPortValue+0x7a>
			break;
		case DIO_PORTD:
			PORTD_REG = A_u8Value;
    12d8:	e2 e3       	ldi	r30, 0x32	; 50
    12da:	f0 e0       	ldi	r31, 0x00	; 0
    12dc:	8a 81       	ldd	r24, Y+2	; 0x02
    12de:	80 83       	st	Z, r24
			break;
		default:
			break;
		}
	}
}
    12e0:	0f 90       	pop	r0
    12e2:	0f 90       	pop	r0
    12e4:	0f 90       	pop	r0
    12e6:	0f 90       	pop	r0
    12e8:	cf 91       	pop	r28
    12ea:	df 91       	pop	r29
    12ec:	08 95       	ret

000012ee <MDIO_voidInit>:


void MDIO_voidInit()
{
    12ee:	df 93       	push	r29
    12f0:	cf 93       	push	r28
    12f2:	cd b7       	in	r28, 0x3d	; 61
    12f4:	de b7       	in	r29, 0x3e	; 62

	DDRA_REG=CONC_BIT(PA7_INITIAL_DIRECTION,PA6_INITIAL_DIRECTION,PA5_INITIAL_DIRECTION,PA4_INITIAL_DIRECTION
    12f6:	ea e3       	ldi	r30, 0x3A	; 58
    12f8:	f0 e0       	ldi	r31, 0x00	; 0
    12fa:	87 e0       	ldi	r24, 0x07	; 7
    12fc:	80 83       	st	Z, r24
					 ,PA3_INITIAL_DIRECTION,PA2_INITIAL_DIRECTION,PA1_INITIAL_DIRECTION,PA0_INITIAL_DIRECTION);

	DDRB_REG=CONC_BIT(PB7_INITIAL_DIRECTION,PB6_INITIAL_DIRECTION,PB5_INITIAL_DIRECTION,PB4_INITIAL_DIRECTION
    12fe:	e7 e3       	ldi	r30, 0x37	; 55
    1300:	f0 e0       	ldi	r31, 0x00	; 0
    1302:	10 82       	st	Z, r1
					 ,PB3_INITIAL_DIRECTION,PB2_INITIAL_DIRECTION,PB1_INITIAL_DIRECTION,PB0_INITIAL_DIRECTION);

	DDRC_REG=CONC_BIT(PC7_INITIAL_DIRECTION,PC6_INITIAL_DIRECTION,PC5_INITIAL_DIRECTION,PC4_INITIAL_DIRECTION
    1304:	e4 e3       	ldi	r30, 0x34	; 52
    1306:	f0 e0       	ldi	r31, 0x00	; 0
    1308:	87 e0       	ldi	r24, 0x07	; 7
    130a:	80 83       	st	Z, r24
					 ,PC3_INITIAL_DIRECTION,PC2_INITIAL_DIRECTION,PC1_INITIAL_DIRECTION,PC0_INITIAL_DIRECTION);

	DDRD_REG=CONC_BIT(PD7_INITIAL_DIRECTION,PD6_INITIAL_DIRECTION,PD5_INITIAL_DIRECTION,PD4_INITIAL_DIRECTION
    130c:	e1 e3       	ldi	r30, 0x31	; 49
    130e:	f0 e0       	ldi	r31, 0x00	; 0
    1310:	8f ef       	ldi	r24, 0xFF	; 255
    1312:	80 83       	st	Z, r24
					 ,PD3_INITIAL_DIRECTION,PD2_INITIAL_DIRECTION,PD1_INITIAL_DIRECTION,PD0_INITIAL_DIRECTION);


	PORTA_REG=CONC_BIT(PA7_INITIAL_VALUE,PA6_INITIAL_VALUE,PA5_INITIAL_VALUE,PA4_INITIAL_VALUE
    1314:	eb e3       	ldi	r30, 0x3B	; 59
    1316:	f0 e0       	ldi	r31, 0x00	; 0
    1318:	10 82       	st	Z, r1
					 ,PA3_INITIAL_VALUE,PA2_INITIAL_VALUE,PA1_INITIAL_VALUE,PA0_INITIAL_VALUE);

	PORTB_REG=CONC_BIT(PB7_INITIAL_VALUE,PB6_INITIAL_VALUE,PB5_INITIAL_VALUE,PB4_INITIAL_VALUE
    131a:	e8 e3       	ldi	r30, 0x38	; 56
    131c:	f0 e0       	ldi	r31, 0x00	; 0
    131e:	10 82       	st	Z, r1
					 ,PB3_INITIAL_VALUE,PB2_INITIAL_VALUE,PB1_INITIAL_VALUE,PB0_INITIAL_VALUE);

	PORTC_REG=CONC_BIT(PC7_INITIAL_VALUE,PC6_INITIAL_VALUE,PC5_INITIAL_VALUE,PC4_INITIAL_VALUE
    1320:	e5 e3       	ldi	r30, 0x35	; 53
    1322:	f0 e0       	ldi	r31, 0x00	; 0
    1324:	10 82       	st	Z, r1
					 ,PC3_INITIAL_VALUE,PC2_INITIAL_VALUE,PC1_INITIAL_VALUE,PC0_INITIAL_VALUE);

	PORTD_REG=CONC_BIT(PD7_INITIAL_VALUE,PD6_INITIAL_VALUE,PD5_INITIAL_VALUE,PD4_INITIAL_VALUE
    1326:	e2 e3       	ldi	r30, 0x32	; 50
    1328:	f0 e0       	ldi	r31, 0x00	; 0
    132a:	84 e0       	ldi	r24, 0x04	; 4
    132c:	80 83       	st	Z, r24
					 ,PD3_INITIAL_VALUE,PD2_INITIAL_VALUE,PD1_INITIAL_VALUE,PD0_INITIAL_VALUE);
}
    132e:	cf 91       	pop	r28
    1330:	df 91       	pop	r29
    1332:	08 95       	ret

00001334 <MGI_voidEnable>:
#include "../Include/MCAL/GI/GI_Interface.h"
#include "../Include/MCAL/GI/GI_Private.h"
#include "../Include/MCAL/GI/GI_Cfg.h"

void MGI_voidEnable(void)
{
    1334:	df 93       	push	r29
    1336:	cf 93       	push	r28
    1338:	cd b7       	in	r28, 0x3d	; 61
    133a:	de b7       	in	r29, 0x3e	; 62
	SET_BIT(SREG , GLOBAL_INTERUPPT_ENABLE_BIT);
    133c:	af e5       	ldi	r26, 0x5F	; 95
    133e:	b0 e0       	ldi	r27, 0x00	; 0
    1340:	ef e5       	ldi	r30, 0x5F	; 95
    1342:	f0 e0       	ldi	r31, 0x00	; 0
    1344:	80 81       	ld	r24, Z
    1346:	80 68       	ori	r24, 0x80	; 128
    1348:	8c 93       	st	X, r24
}
    134a:	cf 91       	pop	r28
    134c:	df 91       	pop	r29
    134e:	08 95       	ret

00001350 <MGI_voidDisable>:

void MGI_voidDisable(void)
{
    1350:	df 93       	push	r29
    1352:	cf 93       	push	r28
    1354:	cd b7       	in	r28, 0x3d	; 61
    1356:	de b7       	in	r29, 0x3e	; 62
	CLR_BIT(SREG , GLOBAL_INTERUPPT_ENABLE_BIT);
    1358:	af e5       	ldi	r26, 0x5F	; 95
    135a:	b0 e0       	ldi	r27, 0x00	; 0
    135c:	ef e5       	ldi	r30, 0x5F	; 95
    135e:	f0 e0       	ldi	r31, 0x00	; 0
    1360:	80 81       	ld	r24, Z
    1362:	8f 77       	andi	r24, 0x7F	; 127
    1364:	8c 93       	st	X, r24
}
    1366:	cf 91       	pop	r28
    1368:	df 91       	pop	r29
    136a:	08 95       	ret

0000136c <HLCD_voidSendCommand>:

#define F_CPU 8000000UL


void HLCD_voidSendCommand (u8 A_u8Command)
{
    136c:	df 93       	push	r29
    136e:	cf 93       	push	r28
    1370:	cd b7       	in	r28, 0x3d	; 61
    1372:	de b7       	in	r29, 0x3e	; 62
    1374:	2f 97       	sbiw	r28, 0x0f	; 15
    1376:	0f b6       	in	r0, 0x3f	; 63
    1378:	f8 94       	cli
    137a:	de bf       	out	0x3e, r29	; 62
    137c:	0f be       	out	0x3f, r0	; 63
    137e:	cd bf       	out	0x3d, r28	; 61
    1380:	8f 87       	std	Y+15, r24	; 0x0f
	// Send Command --> (RS --> LOW) - (RW --> LOW)
	MDIO_voidSetPinValue(LCD_CTRL_PORT, LCD_RS_PIN, DIO_RESET);
    1382:	82 e0       	ldi	r24, 0x02	; 2
    1384:	60 e0       	ldi	r22, 0x00	; 0
    1386:	40 e0       	ldi	r20, 0x00	; 0
    1388:	0e 94 c6 06 	call	0xd8c	; 0xd8c <MDIO_voidSetPinValue>
	MDIO_voidSetPinValue(LCD_CTRL_PORT, LCD_RW_PIN, DIO_RESET);
    138c:	82 e0       	ldi	r24, 0x02	; 2
    138e:	61 e0       	ldi	r22, 0x01	; 1
    1390:	40 e0       	ldi	r20, 0x00	; 0
    1392:	0e 94 c6 06 	call	0xd8c	; 0xd8c <MDIO_voidSetPinValue>

	// Sending the command
	MDIO_voidSetPortValue(LCD_DATA_PORT, A_u8Command);
    1396:	83 e0       	ldi	r24, 0x03	; 3
    1398:	6f 85       	ldd	r22, Y+15	; 0x0f
    139a:	0e 94 33 09 	call	0x1266	; 0x1266 <MDIO_voidSetPortValue>

	// Apply Pulse on E Pin
	MDIO_voidSetPinValue(LCD_CTRL_PORT, LCD_E_PIN, DIO_SET);
    139e:	82 e0       	ldi	r24, 0x02	; 2
    13a0:	62 e0       	ldi	r22, 0x02	; 2
    13a2:	41 e0       	ldi	r20, 0x01	; 1
    13a4:	0e 94 c6 06 	call	0xd8c	; 0xd8c <MDIO_voidSetPinValue>
    13a8:	80 e0       	ldi	r24, 0x00	; 0
    13aa:	90 e0       	ldi	r25, 0x00	; 0
    13ac:	a0 e0       	ldi	r26, 0x00	; 0
    13ae:	b0 e4       	ldi	r27, 0x40	; 64
    13b0:	8b 87       	std	Y+11, r24	; 0x0b
    13b2:	9c 87       	std	Y+12, r25	; 0x0c
    13b4:	ad 87       	std	Y+13, r26	; 0x0d
    13b6:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    13b8:	6b 85       	ldd	r22, Y+11	; 0x0b
    13ba:	7c 85       	ldd	r23, Y+12	; 0x0c
    13bc:	8d 85       	ldd	r24, Y+13	; 0x0d
    13be:	9e 85       	ldd	r25, Y+14	; 0x0e
    13c0:	20 e0       	ldi	r18, 0x00	; 0
    13c2:	30 e0       	ldi	r19, 0x00	; 0
    13c4:	4a ef       	ldi	r20, 0xFA	; 250
    13c6:	54 e4       	ldi	r21, 0x44	; 68
    13c8:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    13cc:	dc 01       	movw	r26, r24
    13ce:	cb 01       	movw	r24, r22
    13d0:	8f 83       	std	Y+7, r24	; 0x07
    13d2:	98 87       	std	Y+8, r25	; 0x08
    13d4:	a9 87       	std	Y+9, r26	; 0x09
    13d6:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    13d8:	6f 81       	ldd	r22, Y+7	; 0x07
    13da:	78 85       	ldd	r23, Y+8	; 0x08
    13dc:	89 85       	ldd	r24, Y+9	; 0x09
    13de:	9a 85       	ldd	r25, Y+10	; 0x0a
    13e0:	20 e0       	ldi	r18, 0x00	; 0
    13e2:	30 e0       	ldi	r19, 0x00	; 0
    13e4:	40 e8       	ldi	r20, 0x80	; 128
    13e6:	5f e3       	ldi	r21, 0x3F	; 63
    13e8:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    13ec:	88 23       	and	r24, r24
    13ee:	2c f4       	brge	.+10     	; 0x13fa <HLCD_voidSendCommand+0x8e>
		__ticks = 1;
    13f0:	81 e0       	ldi	r24, 0x01	; 1
    13f2:	90 e0       	ldi	r25, 0x00	; 0
    13f4:	9e 83       	std	Y+6, r25	; 0x06
    13f6:	8d 83       	std	Y+5, r24	; 0x05
    13f8:	3f c0       	rjmp	.+126    	; 0x1478 <HLCD_voidSendCommand+0x10c>
	else if (__tmp > 65535)
    13fa:	6f 81       	ldd	r22, Y+7	; 0x07
    13fc:	78 85       	ldd	r23, Y+8	; 0x08
    13fe:	89 85       	ldd	r24, Y+9	; 0x09
    1400:	9a 85       	ldd	r25, Y+10	; 0x0a
    1402:	20 e0       	ldi	r18, 0x00	; 0
    1404:	3f ef       	ldi	r19, 0xFF	; 255
    1406:	4f e7       	ldi	r20, 0x7F	; 127
    1408:	57 e4       	ldi	r21, 0x47	; 71
    140a:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    140e:	18 16       	cp	r1, r24
    1410:	4c f5       	brge	.+82     	; 0x1464 <HLCD_voidSendCommand+0xf8>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    1412:	6b 85       	ldd	r22, Y+11	; 0x0b
    1414:	7c 85       	ldd	r23, Y+12	; 0x0c
    1416:	8d 85       	ldd	r24, Y+13	; 0x0d
    1418:	9e 85       	ldd	r25, Y+14	; 0x0e
    141a:	20 e0       	ldi	r18, 0x00	; 0
    141c:	30 e0       	ldi	r19, 0x00	; 0
    141e:	40 e2       	ldi	r20, 0x20	; 32
    1420:	51 e4       	ldi	r21, 0x41	; 65
    1422:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1426:	dc 01       	movw	r26, r24
    1428:	cb 01       	movw	r24, r22
    142a:	bc 01       	movw	r22, r24
    142c:	cd 01       	movw	r24, r26
    142e:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1432:	dc 01       	movw	r26, r24
    1434:	cb 01       	movw	r24, r22
    1436:	9e 83       	std	Y+6, r25	; 0x06
    1438:	8d 83       	std	Y+5, r24	; 0x05
    143a:	0f c0       	rjmp	.+30     	; 0x145a <HLCD_voidSendCommand+0xee>
    143c:	88 ec       	ldi	r24, 0xC8	; 200
    143e:	90 e0       	ldi	r25, 0x00	; 0
    1440:	9c 83       	std	Y+4, r25	; 0x04
    1442:	8b 83       	std	Y+3, r24	; 0x03
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    1444:	8b 81       	ldd	r24, Y+3	; 0x03
    1446:	9c 81       	ldd	r25, Y+4	; 0x04
    1448:	01 97       	sbiw	r24, 0x01	; 1
    144a:	f1 f7       	brne	.-4      	; 0x1448 <HLCD_voidSendCommand+0xdc>
    144c:	9c 83       	std	Y+4, r25	; 0x04
    144e:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1450:	8d 81       	ldd	r24, Y+5	; 0x05
    1452:	9e 81       	ldd	r25, Y+6	; 0x06
    1454:	01 97       	sbiw	r24, 0x01	; 1
    1456:	9e 83       	std	Y+6, r25	; 0x06
    1458:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    145a:	8d 81       	ldd	r24, Y+5	; 0x05
    145c:	9e 81       	ldd	r25, Y+6	; 0x06
    145e:	00 97       	sbiw	r24, 0x00	; 0
    1460:	69 f7       	brne	.-38     	; 0x143c <HLCD_voidSendCommand+0xd0>
    1462:	14 c0       	rjmp	.+40     	; 0x148c <HLCD_voidSendCommand+0x120>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    1464:	6f 81       	ldd	r22, Y+7	; 0x07
    1466:	78 85       	ldd	r23, Y+8	; 0x08
    1468:	89 85       	ldd	r24, Y+9	; 0x09
    146a:	9a 85       	ldd	r25, Y+10	; 0x0a
    146c:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1470:	dc 01       	movw	r26, r24
    1472:	cb 01       	movw	r24, r22
    1474:	9e 83       	std	Y+6, r25	; 0x06
    1476:	8d 83       	std	Y+5, r24	; 0x05
    1478:	8d 81       	ldd	r24, Y+5	; 0x05
    147a:	9e 81       	ldd	r25, Y+6	; 0x06
    147c:	9a 83       	std	Y+2, r25	; 0x02
    147e:	89 83       	std	Y+1, r24	; 0x01
    1480:	89 81       	ldd	r24, Y+1	; 0x01
    1482:	9a 81       	ldd	r25, Y+2	; 0x02
    1484:	01 97       	sbiw	r24, 0x01	; 1
    1486:	f1 f7       	brne	.-4      	; 0x1484 <HLCD_voidSendCommand+0x118>
    1488:	9a 83       	std	Y+2, r25	; 0x02
    148a:	89 83       	std	Y+1, r24	; 0x01
	_delay_ms(2);
	MDIO_voidSetPinValue(LCD_CTRL_PORT, LCD_E_PIN, DIO_RESET);
    148c:	82 e0       	ldi	r24, 0x02	; 2
    148e:	62 e0       	ldi	r22, 0x02	; 2
    1490:	40 e0       	ldi	r20, 0x00	; 0
    1492:	0e 94 c6 06 	call	0xd8c	; 0xd8c <MDIO_voidSetPinValue>
}
    1496:	2f 96       	adiw	r28, 0x0f	; 15
    1498:	0f b6       	in	r0, 0x3f	; 63
    149a:	f8 94       	cli
    149c:	de bf       	out	0x3e, r29	; 62
    149e:	0f be       	out	0x3f, r0	; 63
    14a0:	cd bf       	out	0x3d, r28	; 61
    14a2:	cf 91       	pop	r28
    14a4:	df 91       	pop	r29
    14a6:	08 95       	ret

000014a8 <HLCD_voidSendData>:

void HLCD_voidSendData (u8 A_u8Data)
{
    14a8:	df 93       	push	r29
    14aa:	cf 93       	push	r28
    14ac:	cd b7       	in	r28, 0x3d	; 61
    14ae:	de b7       	in	r29, 0x3e	; 62
    14b0:	2f 97       	sbiw	r28, 0x0f	; 15
    14b2:	0f b6       	in	r0, 0x3f	; 63
    14b4:	f8 94       	cli
    14b6:	de bf       	out	0x3e, r29	; 62
    14b8:	0f be       	out	0x3f, r0	; 63
    14ba:	cd bf       	out	0x3d, r28	; 61
    14bc:	8f 87       	std	Y+15, r24	; 0x0f
	// Send Data --> (RS --> HIGH) - (RW --> LOW)
	MDIO_voidSetPinValue(LCD_CTRL_PORT, LCD_RS_PIN, DIO_SET);
    14be:	82 e0       	ldi	r24, 0x02	; 2
    14c0:	60 e0       	ldi	r22, 0x00	; 0
    14c2:	41 e0       	ldi	r20, 0x01	; 1
    14c4:	0e 94 c6 06 	call	0xd8c	; 0xd8c <MDIO_voidSetPinValue>
	MDIO_voidSetPinValue(LCD_CTRL_PORT, LCD_RW_PIN, DIO_RESET);
    14c8:	82 e0       	ldi	r24, 0x02	; 2
    14ca:	61 e0       	ldi	r22, 0x01	; 1
    14cc:	40 e0       	ldi	r20, 0x00	; 0
    14ce:	0e 94 c6 06 	call	0xd8c	; 0xd8c <MDIO_voidSetPinValue>

	// Sending the command
	MDIO_voidSetPortValue(LCD_DATA_PORT, A_u8Data);
    14d2:	83 e0       	ldi	r24, 0x03	; 3
    14d4:	6f 85       	ldd	r22, Y+15	; 0x0f
    14d6:	0e 94 33 09 	call	0x1266	; 0x1266 <MDIO_voidSetPortValue>

	// Apply Pulse on E Pin
	MDIO_voidSetPinValue(LCD_CTRL_PORT, LCD_E_PIN, DIO_SET);
    14da:	82 e0       	ldi	r24, 0x02	; 2
    14dc:	62 e0       	ldi	r22, 0x02	; 2
    14de:	41 e0       	ldi	r20, 0x01	; 1
    14e0:	0e 94 c6 06 	call	0xd8c	; 0xd8c <MDIO_voidSetPinValue>
    14e4:	80 e0       	ldi	r24, 0x00	; 0
    14e6:	90 e0       	ldi	r25, 0x00	; 0
    14e8:	a0 e0       	ldi	r26, 0x00	; 0
    14ea:	b0 e4       	ldi	r27, 0x40	; 64
    14ec:	8b 87       	std	Y+11, r24	; 0x0b
    14ee:	9c 87       	std	Y+12, r25	; 0x0c
    14f0:	ad 87       	std	Y+13, r26	; 0x0d
    14f2:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    14f4:	6b 85       	ldd	r22, Y+11	; 0x0b
    14f6:	7c 85       	ldd	r23, Y+12	; 0x0c
    14f8:	8d 85       	ldd	r24, Y+13	; 0x0d
    14fa:	9e 85       	ldd	r25, Y+14	; 0x0e
    14fc:	20 e0       	ldi	r18, 0x00	; 0
    14fe:	30 e0       	ldi	r19, 0x00	; 0
    1500:	4a ef       	ldi	r20, 0xFA	; 250
    1502:	54 e4       	ldi	r21, 0x44	; 68
    1504:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1508:	dc 01       	movw	r26, r24
    150a:	cb 01       	movw	r24, r22
    150c:	8f 83       	std	Y+7, r24	; 0x07
    150e:	98 87       	std	Y+8, r25	; 0x08
    1510:	a9 87       	std	Y+9, r26	; 0x09
    1512:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    1514:	6f 81       	ldd	r22, Y+7	; 0x07
    1516:	78 85       	ldd	r23, Y+8	; 0x08
    1518:	89 85       	ldd	r24, Y+9	; 0x09
    151a:	9a 85       	ldd	r25, Y+10	; 0x0a
    151c:	20 e0       	ldi	r18, 0x00	; 0
    151e:	30 e0       	ldi	r19, 0x00	; 0
    1520:	40 e8       	ldi	r20, 0x80	; 128
    1522:	5f e3       	ldi	r21, 0x3F	; 63
    1524:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    1528:	88 23       	and	r24, r24
    152a:	2c f4       	brge	.+10     	; 0x1536 <HLCD_voidSendData+0x8e>
		__ticks = 1;
    152c:	81 e0       	ldi	r24, 0x01	; 1
    152e:	90 e0       	ldi	r25, 0x00	; 0
    1530:	9e 83       	std	Y+6, r25	; 0x06
    1532:	8d 83       	std	Y+5, r24	; 0x05
    1534:	3f c0       	rjmp	.+126    	; 0x15b4 <HLCD_voidSendData+0x10c>
	else if (__tmp > 65535)
    1536:	6f 81       	ldd	r22, Y+7	; 0x07
    1538:	78 85       	ldd	r23, Y+8	; 0x08
    153a:	89 85       	ldd	r24, Y+9	; 0x09
    153c:	9a 85       	ldd	r25, Y+10	; 0x0a
    153e:	20 e0       	ldi	r18, 0x00	; 0
    1540:	3f ef       	ldi	r19, 0xFF	; 255
    1542:	4f e7       	ldi	r20, 0x7F	; 127
    1544:	57 e4       	ldi	r21, 0x47	; 71
    1546:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    154a:	18 16       	cp	r1, r24
    154c:	4c f5       	brge	.+82     	; 0x15a0 <HLCD_voidSendData+0xf8>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    154e:	6b 85       	ldd	r22, Y+11	; 0x0b
    1550:	7c 85       	ldd	r23, Y+12	; 0x0c
    1552:	8d 85       	ldd	r24, Y+13	; 0x0d
    1554:	9e 85       	ldd	r25, Y+14	; 0x0e
    1556:	20 e0       	ldi	r18, 0x00	; 0
    1558:	30 e0       	ldi	r19, 0x00	; 0
    155a:	40 e2       	ldi	r20, 0x20	; 32
    155c:	51 e4       	ldi	r21, 0x41	; 65
    155e:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1562:	dc 01       	movw	r26, r24
    1564:	cb 01       	movw	r24, r22
    1566:	bc 01       	movw	r22, r24
    1568:	cd 01       	movw	r24, r26
    156a:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    156e:	dc 01       	movw	r26, r24
    1570:	cb 01       	movw	r24, r22
    1572:	9e 83       	std	Y+6, r25	; 0x06
    1574:	8d 83       	std	Y+5, r24	; 0x05
    1576:	0f c0       	rjmp	.+30     	; 0x1596 <HLCD_voidSendData+0xee>
    1578:	88 ec       	ldi	r24, 0xC8	; 200
    157a:	90 e0       	ldi	r25, 0x00	; 0
    157c:	9c 83       	std	Y+4, r25	; 0x04
    157e:	8b 83       	std	Y+3, r24	; 0x03
    1580:	8b 81       	ldd	r24, Y+3	; 0x03
    1582:	9c 81       	ldd	r25, Y+4	; 0x04
    1584:	01 97       	sbiw	r24, 0x01	; 1
    1586:	f1 f7       	brne	.-4      	; 0x1584 <HLCD_voidSendData+0xdc>
    1588:	9c 83       	std	Y+4, r25	; 0x04
    158a:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    158c:	8d 81       	ldd	r24, Y+5	; 0x05
    158e:	9e 81       	ldd	r25, Y+6	; 0x06
    1590:	01 97       	sbiw	r24, 0x01	; 1
    1592:	9e 83       	std	Y+6, r25	; 0x06
    1594:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1596:	8d 81       	ldd	r24, Y+5	; 0x05
    1598:	9e 81       	ldd	r25, Y+6	; 0x06
    159a:	00 97       	sbiw	r24, 0x00	; 0
    159c:	69 f7       	brne	.-38     	; 0x1578 <HLCD_voidSendData+0xd0>
    159e:	14 c0       	rjmp	.+40     	; 0x15c8 <HLCD_voidSendData+0x120>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    15a0:	6f 81       	ldd	r22, Y+7	; 0x07
    15a2:	78 85       	ldd	r23, Y+8	; 0x08
    15a4:	89 85       	ldd	r24, Y+9	; 0x09
    15a6:	9a 85       	ldd	r25, Y+10	; 0x0a
    15a8:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    15ac:	dc 01       	movw	r26, r24
    15ae:	cb 01       	movw	r24, r22
    15b0:	9e 83       	std	Y+6, r25	; 0x06
    15b2:	8d 83       	std	Y+5, r24	; 0x05
    15b4:	8d 81       	ldd	r24, Y+5	; 0x05
    15b6:	9e 81       	ldd	r25, Y+6	; 0x06
    15b8:	9a 83       	std	Y+2, r25	; 0x02
    15ba:	89 83       	std	Y+1, r24	; 0x01
    15bc:	89 81       	ldd	r24, Y+1	; 0x01
    15be:	9a 81       	ldd	r25, Y+2	; 0x02
    15c0:	01 97       	sbiw	r24, 0x01	; 1
    15c2:	f1 f7       	brne	.-4      	; 0x15c0 <HLCD_voidSendData+0x118>
    15c4:	9a 83       	std	Y+2, r25	; 0x02
    15c6:	89 83       	std	Y+1, r24	; 0x01
	_delay_ms(2);
	MDIO_voidSetPinValue(LCD_CTRL_PORT, LCD_E_PIN, DIO_RESET);
    15c8:	82 e0       	ldi	r24, 0x02	; 2
    15ca:	62 e0       	ldi	r22, 0x02	; 2
    15cc:	40 e0       	ldi	r20, 0x00	; 0
    15ce:	0e 94 c6 06 	call	0xd8c	; 0xd8c <MDIO_voidSetPinValue>
}
    15d2:	2f 96       	adiw	r28, 0x0f	; 15
    15d4:	0f b6       	in	r0, 0x3f	; 63
    15d6:	f8 94       	cli
    15d8:	de bf       	out	0x3e, r29	; 62
    15da:	0f be       	out	0x3f, r0	; 63
    15dc:	cd bf       	out	0x3d, r28	; 61
    15de:	cf 91       	pop	r28
    15e0:	df 91       	pop	r29
    15e2:	08 95       	ret

000015e4 <HLCD_voidInit>:

void HLCD_voidInit (void)
{
    15e4:	0f 93       	push	r16
    15e6:	1f 93       	push	r17
    15e8:	df 93       	push	r29
    15ea:	cf 93       	push	r28
    15ec:	cd b7       	in	r28, 0x3d	; 61
    15ee:	de b7       	in	r29, 0x3e	; 62
    15f0:	c6 54       	subi	r28, 0x46	; 70
    15f2:	d0 40       	sbci	r29, 0x00	; 0
    15f4:	0f b6       	in	r0, 0x3f	; 63
    15f6:	f8 94       	cli
    15f8:	de bf       	out	0x3e, r29	; 62
    15fa:	0f be       	out	0x3f, r0	; 63
    15fc:	cd bf       	out	0x3d, r28	; 61
    15fe:	fe 01       	movw	r30, r28
    1600:	ed 5b       	subi	r30, 0xBD	; 189
    1602:	ff 4f       	sbci	r31, 0xFF	; 255
    1604:	80 e0       	ldi	r24, 0x00	; 0
    1606:	90 e0       	ldi	r25, 0x00	; 0
    1608:	a0 ef       	ldi	r26, 0xF0	; 240
    160a:	b1 e4       	ldi	r27, 0x41	; 65
    160c:	80 83       	st	Z, r24
    160e:	91 83       	std	Z+1, r25	; 0x01
    1610:	a2 83       	std	Z+2, r26	; 0x02
    1612:	b3 83       	std	Z+3, r27	; 0x03
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    1614:	8e 01       	movw	r16, r28
    1616:	01 5c       	subi	r16, 0xC1	; 193
    1618:	1f 4f       	sbci	r17, 0xFF	; 255
    161a:	fe 01       	movw	r30, r28
    161c:	ed 5b       	subi	r30, 0xBD	; 189
    161e:	ff 4f       	sbci	r31, 0xFF	; 255
    1620:	60 81       	ld	r22, Z
    1622:	71 81       	ldd	r23, Z+1	; 0x01
    1624:	82 81       	ldd	r24, Z+2	; 0x02
    1626:	93 81       	ldd	r25, Z+3	; 0x03
    1628:	20 e0       	ldi	r18, 0x00	; 0
    162a:	30 e0       	ldi	r19, 0x00	; 0
    162c:	4a ef       	ldi	r20, 0xFA	; 250
    162e:	54 e4       	ldi	r21, 0x44	; 68
    1630:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1634:	dc 01       	movw	r26, r24
    1636:	cb 01       	movw	r24, r22
    1638:	f8 01       	movw	r30, r16
    163a:	80 83       	st	Z, r24
    163c:	91 83       	std	Z+1, r25	; 0x01
    163e:	a2 83       	std	Z+2, r26	; 0x02
    1640:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
    1642:	fe 01       	movw	r30, r28
    1644:	ff 96       	adiw	r30, 0x3f	; 63
    1646:	60 81       	ld	r22, Z
    1648:	71 81       	ldd	r23, Z+1	; 0x01
    164a:	82 81       	ldd	r24, Z+2	; 0x02
    164c:	93 81       	ldd	r25, Z+3	; 0x03
    164e:	20 e0       	ldi	r18, 0x00	; 0
    1650:	30 e0       	ldi	r19, 0x00	; 0
    1652:	40 e8       	ldi	r20, 0x80	; 128
    1654:	5f e3       	ldi	r21, 0x3F	; 63
    1656:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    165a:	88 23       	and	r24, r24
    165c:	2c f4       	brge	.+10     	; 0x1668 <HLCD_voidInit+0x84>
		__ticks = 1;
    165e:	81 e0       	ldi	r24, 0x01	; 1
    1660:	90 e0       	ldi	r25, 0x00	; 0
    1662:	9e af       	std	Y+62, r25	; 0x3e
    1664:	8d af       	std	Y+61, r24	; 0x3d
    1666:	46 c0       	rjmp	.+140    	; 0x16f4 <HLCD_voidInit+0x110>
	else if (__tmp > 65535)
    1668:	fe 01       	movw	r30, r28
    166a:	ff 96       	adiw	r30, 0x3f	; 63
    166c:	60 81       	ld	r22, Z
    166e:	71 81       	ldd	r23, Z+1	; 0x01
    1670:	82 81       	ldd	r24, Z+2	; 0x02
    1672:	93 81       	ldd	r25, Z+3	; 0x03
    1674:	20 e0       	ldi	r18, 0x00	; 0
    1676:	3f ef       	ldi	r19, 0xFF	; 255
    1678:	4f e7       	ldi	r20, 0x7F	; 127
    167a:	57 e4       	ldi	r21, 0x47	; 71
    167c:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    1680:	18 16       	cp	r1, r24
    1682:	64 f5       	brge	.+88     	; 0x16dc <HLCD_voidInit+0xf8>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    1684:	fe 01       	movw	r30, r28
    1686:	ed 5b       	subi	r30, 0xBD	; 189
    1688:	ff 4f       	sbci	r31, 0xFF	; 255
    168a:	60 81       	ld	r22, Z
    168c:	71 81       	ldd	r23, Z+1	; 0x01
    168e:	82 81       	ldd	r24, Z+2	; 0x02
    1690:	93 81       	ldd	r25, Z+3	; 0x03
    1692:	20 e0       	ldi	r18, 0x00	; 0
    1694:	30 e0       	ldi	r19, 0x00	; 0
    1696:	40 e2       	ldi	r20, 0x20	; 32
    1698:	51 e4       	ldi	r21, 0x41	; 65
    169a:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    169e:	dc 01       	movw	r26, r24
    16a0:	cb 01       	movw	r24, r22
    16a2:	bc 01       	movw	r22, r24
    16a4:	cd 01       	movw	r24, r26
    16a6:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    16aa:	dc 01       	movw	r26, r24
    16ac:	cb 01       	movw	r24, r22
    16ae:	9e af       	std	Y+62, r25	; 0x3e
    16b0:	8d af       	std	Y+61, r24	; 0x3d
    16b2:	0f c0       	rjmp	.+30     	; 0x16d2 <HLCD_voidInit+0xee>
    16b4:	88 ec       	ldi	r24, 0xC8	; 200
    16b6:	90 e0       	ldi	r25, 0x00	; 0
    16b8:	9c af       	std	Y+60, r25	; 0x3c
    16ba:	8b af       	std	Y+59, r24	; 0x3b
    16bc:	8b ad       	ldd	r24, Y+59	; 0x3b
    16be:	9c ad       	ldd	r25, Y+60	; 0x3c
    16c0:	01 97       	sbiw	r24, 0x01	; 1
    16c2:	f1 f7       	brne	.-4      	; 0x16c0 <HLCD_voidInit+0xdc>
    16c4:	9c af       	std	Y+60, r25	; 0x3c
    16c6:	8b af       	std	Y+59, r24	; 0x3b
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    16c8:	8d ad       	ldd	r24, Y+61	; 0x3d
    16ca:	9e ad       	ldd	r25, Y+62	; 0x3e
    16cc:	01 97       	sbiw	r24, 0x01	; 1
    16ce:	9e af       	std	Y+62, r25	; 0x3e
    16d0:	8d af       	std	Y+61, r24	; 0x3d
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    16d2:	8d ad       	ldd	r24, Y+61	; 0x3d
    16d4:	9e ad       	ldd	r25, Y+62	; 0x3e
    16d6:	00 97       	sbiw	r24, 0x00	; 0
    16d8:	69 f7       	brne	.-38     	; 0x16b4 <HLCD_voidInit+0xd0>
    16da:	16 c0       	rjmp	.+44     	; 0x1708 <HLCD_voidInit+0x124>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    16dc:	fe 01       	movw	r30, r28
    16de:	ff 96       	adiw	r30, 0x3f	; 63
    16e0:	60 81       	ld	r22, Z
    16e2:	71 81       	ldd	r23, Z+1	; 0x01
    16e4:	82 81       	ldd	r24, Z+2	; 0x02
    16e6:	93 81       	ldd	r25, Z+3	; 0x03
    16e8:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    16ec:	dc 01       	movw	r26, r24
    16ee:	cb 01       	movw	r24, r22
    16f0:	9e af       	std	Y+62, r25	; 0x3e
    16f2:	8d af       	std	Y+61, r24	; 0x3d
    16f4:	8d ad       	ldd	r24, Y+61	; 0x3d
    16f6:	9e ad       	ldd	r25, Y+62	; 0x3e
    16f8:	9a af       	std	Y+58, r25	; 0x3a
    16fa:	89 af       	std	Y+57, r24	; 0x39
    16fc:	89 ad       	ldd	r24, Y+57	; 0x39
    16fe:	9a ad       	ldd	r25, Y+58	; 0x3a
    1700:	01 97       	sbiw	r24, 0x01	; 1
    1702:	f1 f7       	brne	.-4      	; 0x1700 <HLCD_voidInit+0x11c>
    1704:	9a af       	std	Y+58, r25	; 0x3a
    1706:	89 af       	std	Y+57, r24	; 0x39
	// Wait for more than 30ms after V DD rises to 4.5V
	_delay_ms(30);

	// Function Set Command
	HLCD_voidSendCommand(FUNCTION_SET);
    1708:	88 e3       	ldi	r24, 0x38	; 56
    170a:	0e 94 b6 09 	call	0x136c	; 0x136c <HLCD_voidSendCommand>
    170e:	80 e0       	ldi	r24, 0x00	; 0
    1710:	90 e0       	ldi	r25, 0x00	; 0
    1712:	a0 e8       	ldi	r26, 0x80	; 128
    1714:	bf e3       	ldi	r27, 0x3F	; 63
    1716:	8d ab       	std	Y+53, r24	; 0x35
    1718:	9e ab       	std	Y+54, r25	; 0x36
    171a:	af ab       	std	Y+55, r26	; 0x37
    171c:	b8 af       	std	Y+56, r27	; 0x38
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    171e:	6d a9       	ldd	r22, Y+53	; 0x35
    1720:	7e a9       	ldd	r23, Y+54	; 0x36
    1722:	8f a9       	ldd	r24, Y+55	; 0x37
    1724:	98 ad       	ldd	r25, Y+56	; 0x38
    1726:	20 e0       	ldi	r18, 0x00	; 0
    1728:	30 e0       	ldi	r19, 0x00	; 0
    172a:	4a ef       	ldi	r20, 0xFA	; 250
    172c:	54 e4       	ldi	r21, 0x44	; 68
    172e:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1732:	dc 01       	movw	r26, r24
    1734:	cb 01       	movw	r24, r22
    1736:	89 ab       	std	Y+49, r24	; 0x31
    1738:	9a ab       	std	Y+50, r25	; 0x32
    173a:	ab ab       	std	Y+51, r26	; 0x33
    173c:	bc ab       	std	Y+52, r27	; 0x34
	if (__tmp < 1.0)
    173e:	69 a9       	ldd	r22, Y+49	; 0x31
    1740:	7a a9       	ldd	r23, Y+50	; 0x32
    1742:	8b a9       	ldd	r24, Y+51	; 0x33
    1744:	9c a9       	ldd	r25, Y+52	; 0x34
    1746:	20 e0       	ldi	r18, 0x00	; 0
    1748:	30 e0       	ldi	r19, 0x00	; 0
    174a:	40 e8       	ldi	r20, 0x80	; 128
    174c:	5f e3       	ldi	r21, 0x3F	; 63
    174e:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    1752:	88 23       	and	r24, r24
    1754:	2c f4       	brge	.+10     	; 0x1760 <HLCD_voidInit+0x17c>
		__ticks = 1;
    1756:	81 e0       	ldi	r24, 0x01	; 1
    1758:	90 e0       	ldi	r25, 0x00	; 0
    175a:	98 ab       	std	Y+48, r25	; 0x30
    175c:	8f a7       	std	Y+47, r24	; 0x2f
    175e:	3f c0       	rjmp	.+126    	; 0x17de <HLCD_voidInit+0x1fa>
	else if (__tmp > 65535)
    1760:	69 a9       	ldd	r22, Y+49	; 0x31
    1762:	7a a9       	ldd	r23, Y+50	; 0x32
    1764:	8b a9       	ldd	r24, Y+51	; 0x33
    1766:	9c a9       	ldd	r25, Y+52	; 0x34
    1768:	20 e0       	ldi	r18, 0x00	; 0
    176a:	3f ef       	ldi	r19, 0xFF	; 255
    176c:	4f e7       	ldi	r20, 0x7F	; 127
    176e:	57 e4       	ldi	r21, 0x47	; 71
    1770:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    1774:	18 16       	cp	r1, r24
    1776:	4c f5       	brge	.+82     	; 0x17ca <HLCD_voidInit+0x1e6>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    1778:	6d a9       	ldd	r22, Y+53	; 0x35
    177a:	7e a9       	ldd	r23, Y+54	; 0x36
    177c:	8f a9       	ldd	r24, Y+55	; 0x37
    177e:	98 ad       	ldd	r25, Y+56	; 0x38
    1780:	20 e0       	ldi	r18, 0x00	; 0
    1782:	30 e0       	ldi	r19, 0x00	; 0
    1784:	40 e2       	ldi	r20, 0x20	; 32
    1786:	51 e4       	ldi	r21, 0x41	; 65
    1788:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    178c:	dc 01       	movw	r26, r24
    178e:	cb 01       	movw	r24, r22
    1790:	bc 01       	movw	r22, r24
    1792:	cd 01       	movw	r24, r26
    1794:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1798:	dc 01       	movw	r26, r24
    179a:	cb 01       	movw	r24, r22
    179c:	98 ab       	std	Y+48, r25	; 0x30
    179e:	8f a7       	std	Y+47, r24	; 0x2f
    17a0:	0f c0       	rjmp	.+30     	; 0x17c0 <HLCD_voidInit+0x1dc>
    17a2:	88 ec       	ldi	r24, 0xC8	; 200
    17a4:	90 e0       	ldi	r25, 0x00	; 0
    17a6:	9e a7       	std	Y+46, r25	; 0x2e
    17a8:	8d a7       	std	Y+45, r24	; 0x2d
    17aa:	8d a5       	ldd	r24, Y+45	; 0x2d
    17ac:	9e a5       	ldd	r25, Y+46	; 0x2e
    17ae:	01 97       	sbiw	r24, 0x01	; 1
    17b0:	f1 f7       	brne	.-4      	; 0x17ae <HLCD_voidInit+0x1ca>
    17b2:	9e a7       	std	Y+46, r25	; 0x2e
    17b4:	8d a7       	std	Y+45, r24	; 0x2d
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    17b6:	8f a5       	ldd	r24, Y+47	; 0x2f
    17b8:	98 a9       	ldd	r25, Y+48	; 0x30
    17ba:	01 97       	sbiw	r24, 0x01	; 1
    17bc:	98 ab       	std	Y+48, r25	; 0x30
    17be:	8f a7       	std	Y+47, r24	; 0x2f
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    17c0:	8f a5       	ldd	r24, Y+47	; 0x2f
    17c2:	98 a9       	ldd	r25, Y+48	; 0x30
    17c4:	00 97       	sbiw	r24, 0x00	; 0
    17c6:	69 f7       	brne	.-38     	; 0x17a2 <HLCD_voidInit+0x1be>
    17c8:	14 c0       	rjmp	.+40     	; 0x17f2 <HLCD_voidInit+0x20e>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    17ca:	69 a9       	ldd	r22, Y+49	; 0x31
    17cc:	7a a9       	ldd	r23, Y+50	; 0x32
    17ce:	8b a9       	ldd	r24, Y+51	; 0x33
    17d0:	9c a9       	ldd	r25, Y+52	; 0x34
    17d2:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    17d6:	dc 01       	movw	r26, r24
    17d8:	cb 01       	movw	r24, r22
    17da:	98 ab       	std	Y+48, r25	; 0x30
    17dc:	8f a7       	std	Y+47, r24	; 0x2f
    17de:	8f a5       	ldd	r24, Y+47	; 0x2f
    17e0:	98 a9       	ldd	r25, Y+48	; 0x30
    17e2:	9c a7       	std	Y+44, r25	; 0x2c
    17e4:	8b a7       	std	Y+43, r24	; 0x2b
    17e6:	8b a5       	ldd	r24, Y+43	; 0x2b
    17e8:	9c a5       	ldd	r25, Y+44	; 0x2c
    17ea:	01 97       	sbiw	r24, 0x01	; 1
    17ec:	f1 f7       	brne	.-4      	; 0x17ea <HLCD_voidInit+0x206>
    17ee:	9c a7       	std	Y+44, r25	; 0x2c
    17f0:	8b a7       	std	Y+43, r24	; 0x2b
	//Wait for more than 39 us
	_delay_ms(1);

	// Display ON/OFF Control Command
	HLCD_voidSendCommand(DISPLAY_ON_OFF);
    17f2:	8f e0       	ldi	r24, 0x0F	; 15
    17f4:	0e 94 b6 09 	call	0x136c	; 0x136c <HLCD_voidSendCommand>
    17f8:	80 e0       	ldi	r24, 0x00	; 0
    17fa:	90 e0       	ldi	r25, 0x00	; 0
    17fc:	a0 e8       	ldi	r26, 0x80	; 128
    17fe:	bf e3       	ldi	r27, 0x3F	; 63
    1800:	8f a3       	std	Y+39, r24	; 0x27
    1802:	98 a7       	std	Y+40, r25	; 0x28
    1804:	a9 a7       	std	Y+41, r26	; 0x29
    1806:	ba a7       	std	Y+42, r27	; 0x2a
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    1808:	6f a1       	ldd	r22, Y+39	; 0x27
    180a:	78 a5       	ldd	r23, Y+40	; 0x28
    180c:	89 a5       	ldd	r24, Y+41	; 0x29
    180e:	9a a5       	ldd	r25, Y+42	; 0x2a
    1810:	20 e0       	ldi	r18, 0x00	; 0
    1812:	30 e0       	ldi	r19, 0x00	; 0
    1814:	4a ef       	ldi	r20, 0xFA	; 250
    1816:	54 e4       	ldi	r21, 0x44	; 68
    1818:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    181c:	dc 01       	movw	r26, r24
    181e:	cb 01       	movw	r24, r22
    1820:	8b a3       	std	Y+35, r24	; 0x23
    1822:	9c a3       	std	Y+36, r25	; 0x24
    1824:	ad a3       	std	Y+37, r26	; 0x25
    1826:	be a3       	std	Y+38, r27	; 0x26
	if (__tmp < 1.0)
    1828:	6b a1       	ldd	r22, Y+35	; 0x23
    182a:	7c a1       	ldd	r23, Y+36	; 0x24
    182c:	8d a1       	ldd	r24, Y+37	; 0x25
    182e:	9e a1       	ldd	r25, Y+38	; 0x26
    1830:	20 e0       	ldi	r18, 0x00	; 0
    1832:	30 e0       	ldi	r19, 0x00	; 0
    1834:	40 e8       	ldi	r20, 0x80	; 128
    1836:	5f e3       	ldi	r21, 0x3F	; 63
    1838:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    183c:	88 23       	and	r24, r24
    183e:	2c f4       	brge	.+10     	; 0x184a <HLCD_voidInit+0x266>
		__ticks = 1;
    1840:	81 e0       	ldi	r24, 0x01	; 1
    1842:	90 e0       	ldi	r25, 0x00	; 0
    1844:	9a a3       	std	Y+34, r25	; 0x22
    1846:	89 a3       	std	Y+33, r24	; 0x21
    1848:	3f c0       	rjmp	.+126    	; 0x18c8 <HLCD_voidInit+0x2e4>
	else if (__tmp > 65535)
    184a:	6b a1       	ldd	r22, Y+35	; 0x23
    184c:	7c a1       	ldd	r23, Y+36	; 0x24
    184e:	8d a1       	ldd	r24, Y+37	; 0x25
    1850:	9e a1       	ldd	r25, Y+38	; 0x26
    1852:	20 e0       	ldi	r18, 0x00	; 0
    1854:	3f ef       	ldi	r19, 0xFF	; 255
    1856:	4f e7       	ldi	r20, 0x7F	; 127
    1858:	57 e4       	ldi	r21, 0x47	; 71
    185a:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    185e:	18 16       	cp	r1, r24
    1860:	4c f5       	brge	.+82     	; 0x18b4 <HLCD_voidInit+0x2d0>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    1862:	6f a1       	ldd	r22, Y+39	; 0x27
    1864:	78 a5       	ldd	r23, Y+40	; 0x28
    1866:	89 a5       	ldd	r24, Y+41	; 0x29
    1868:	9a a5       	ldd	r25, Y+42	; 0x2a
    186a:	20 e0       	ldi	r18, 0x00	; 0
    186c:	30 e0       	ldi	r19, 0x00	; 0
    186e:	40 e2       	ldi	r20, 0x20	; 32
    1870:	51 e4       	ldi	r21, 0x41	; 65
    1872:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1876:	dc 01       	movw	r26, r24
    1878:	cb 01       	movw	r24, r22
    187a:	bc 01       	movw	r22, r24
    187c:	cd 01       	movw	r24, r26
    187e:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1882:	dc 01       	movw	r26, r24
    1884:	cb 01       	movw	r24, r22
    1886:	9a a3       	std	Y+34, r25	; 0x22
    1888:	89 a3       	std	Y+33, r24	; 0x21
    188a:	0f c0       	rjmp	.+30     	; 0x18aa <HLCD_voidInit+0x2c6>
    188c:	88 ec       	ldi	r24, 0xC8	; 200
    188e:	90 e0       	ldi	r25, 0x00	; 0
    1890:	98 a3       	std	Y+32, r25	; 0x20
    1892:	8f 8f       	std	Y+31, r24	; 0x1f
    1894:	8f 8d       	ldd	r24, Y+31	; 0x1f
    1896:	98 a1       	ldd	r25, Y+32	; 0x20
    1898:	01 97       	sbiw	r24, 0x01	; 1
    189a:	f1 f7       	brne	.-4      	; 0x1898 <HLCD_voidInit+0x2b4>
    189c:	98 a3       	std	Y+32, r25	; 0x20
    189e:	8f 8f       	std	Y+31, r24	; 0x1f
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    18a0:	89 a1       	ldd	r24, Y+33	; 0x21
    18a2:	9a a1       	ldd	r25, Y+34	; 0x22
    18a4:	01 97       	sbiw	r24, 0x01	; 1
    18a6:	9a a3       	std	Y+34, r25	; 0x22
    18a8:	89 a3       	std	Y+33, r24	; 0x21
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    18aa:	89 a1       	ldd	r24, Y+33	; 0x21
    18ac:	9a a1       	ldd	r25, Y+34	; 0x22
    18ae:	00 97       	sbiw	r24, 0x00	; 0
    18b0:	69 f7       	brne	.-38     	; 0x188c <HLCD_voidInit+0x2a8>
    18b2:	14 c0       	rjmp	.+40     	; 0x18dc <HLCD_voidInit+0x2f8>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    18b4:	6b a1       	ldd	r22, Y+35	; 0x23
    18b6:	7c a1       	ldd	r23, Y+36	; 0x24
    18b8:	8d a1       	ldd	r24, Y+37	; 0x25
    18ba:	9e a1       	ldd	r25, Y+38	; 0x26
    18bc:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    18c0:	dc 01       	movw	r26, r24
    18c2:	cb 01       	movw	r24, r22
    18c4:	9a a3       	std	Y+34, r25	; 0x22
    18c6:	89 a3       	std	Y+33, r24	; 0x21
    18c8:	89 a1       	ldd	r24, Y+33	; 0x21
    18ca:	9a a1       	ldd	r25, Y+34	; 0x22
    18cc:	9e 8f       	std	Y+30, r25	; 0x1e
    18ce:	8d 8f       	std	Y+29, r24	; 0x1d
    18d0:	8d 8d       	ldd	r24, Y+29	; 0x1d
    18d2:	9e 8d       	ldd	r25, Y+30	; 0x1e
    18d4:	01 97       	sbiw	r24, 0x01	; 1
    18d6:	f1 f7       	brne	.-4      	; 0x18d4 <HLCD_voidInit+0x2f0>
    18d8:	9e 8f       	std	Y+30, r25	; 0x1e
    18da:	8d 8f       	std	Y+29, r24	; 0x1d
	//Wait for more than 39 us
	_delay_ms(1);

	// Display Clear Command
	HLCD_voidSendCommand(DISPLAY_CLEAR);
    18dc:	81 e0       	ldi	r24, 0x01	; 1
    18de:	0e 94 b6 09 	call	0x136c	; 0x136c <HLCD_voidSendCommand>
    18e2:	80 e0       	ldi	r24, 0x00	; 0
    18e4:	90 e0       	ldi	r25, 0x00	; 0
    18e6:	a0 e0       	ldi	r26, 0x00	; 0
    18e8:	b0 e4       	ldi	r27, 0x40	; 64
    18ea:	89 8f       	std	Y+25, r24	; 0x19
    18ec:	9a 8f       	std	Y+26, r25	; 0x1a
    18ee:	ab 8f       	std	Y+27, r26	; 0x1b
    18f0:	bc 8f       	std	Y+28, r27	; 0x1c
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    18f2:	69 8d       	ldd	r22, Y+25	; 0x19
    18f4:	7a 8d       	ldd	r23, Y+26	; 0x1a
    18f6:	8b 8d       	ldd	r24, Y+27	; 0x1b
    18f8:	9c 8d       	ldd	r25, Y+28	; 0x1c
    18fa:	20 e0       	ldi	r18, 0x00	; 0
    18fc:	30 e0       	ldi	r19, 0x00	; 0
    18fe:	4a ef       	ldi	r20, 0xFA	; 250
    1900:	54 e4       	ldi	r21, 0x44	; 68
    1902:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1906:	dc 01       	movw	r26, r24
    1908:	cb 01       	movw	r24, r22
    190a:	8d 8b       	std	Y+21, r24	; 0x15
    190c:	9e 8b       	std	Y+22, r25	; 0x16
    190e:	af 8b       	std	Y+23, r26	; 0x17
    1910:	b8 8f       	std	Y+24, r27	; 0x18
	if (__tmp < 1.0)
    1912:	6d 89       	ldd	r22, Y+21	; 0x15
    1914:	7e 89       	ldd	r23, Y+22	; 0x16
    1916:	8f 89       	ldd	r24, Y+23	; 0x17
    1918:	98 8d       	ldd	r25, Y+24	; 0x18
    191a:	20 e0       	ldi	r18, 0x00	; 0
    191c:	30 e0       	ldi	r19, 0x00	; 0
    191e:	40 e8       	ldi	r20, 0x80	; 128
    1920:	5f e3       	ldi	r21, 0x3F	; 63
    1922:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    1926:	88 23       	and	r24, r24
    1928:	2c f4       	brge	.+10     	; 0x1934 <HLCD_voidInit+0x350>
		__ticks = 1;
    192a:	81 e0       	ldi	r24, 0x01	; 1
    192c:	90 e0       	ldi	r25, 0x00	; 0
    192e:	9c 8b       	std	Y+20, r25	; 0x14
    1930:	8b 8b       	std	Y+19, r24	; 0x13
    1932:	3f c0       	rjmp	.+126    	; 0x19b2 <HLCD_voidInit+0x3ce>
	else if (__tmp > 65535)
    1934:	6d 89       	ldd	r22, Y+21	; 0x15
    1936:	7e 89       	ldd	r23, Y+22	; 0x16
    1938:	8f 89       	ldd	r24, Y+23	; 0x17
    193a:	98 8d       	ldd	r25, Y+24	; 0x18
    193c:	20 e0       	ldi	r18, 0x00	; 0
    193e:	3f ef       	ldi	r19, 0xFF	; 255
    1940:	4f e7       	ldi	r20, 0x7F	; 127
    1942:	57 e4       	ldi	r21, 0x47	; 71
    1944:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    1948:	18 16       	cp	r1, r24
    194a:	4c f5       	brge	.+82     	; 0x199e <HLCD_voidInit+0x3ba>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    194c:	69 8d       	ldd	r22, Y+25	; 0x19
    194e:	7a 8d       	ldd	r23, Y+26	; 0x1a
    1950:	8b 8d       	ldd	r24, Y+27	; 0x1b
    1952:	9c 8d       	ldd	r25, Y+28	; 0x1c
    1954:	20 e0       	ldi	r18, 0x00	; 0
    1956:	30 e0       	ldi	r19, 0x00	; 0
    1958:	40 e2       	ldi	r20, 0x20	; 32
    195a:	51 e4       	ldi	r21, 0x41	; 65
    195c:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1960:	dc 01       	movw	r26, r24
    1962:	cb 01       	movw	r24, r22
    1964:	bc 01       	movw	r22, r24
    1966:	cd 01       	movw	r24, r26
    1968:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    196c:	dc 01       	movw	r26, r24
    196e:	cb 01       	movw	r24, r22
    1970:	9c 8b       	std	Y+20, r25	; 0x14
    1972:	8b 8b       	std	Y+19, r24	; 0x13
    1974:	0f c0       	rjmp	.+30     	; 0x1994 <HLCD_voidInit+0x3b0>
    1976:	88 ec       	ldi	r24, 0xC8	; 200
    1978:	90 e0       	ldi	r25, 0x00	; 0
    197a:	9a 8b       	std	Y+18, r25	; 0x12
    197c:	89 8b       	std	Y+17, r24	; 0x11
    197e:	89 89       	ldd	r24, Y+17	; 0x11
    1980:	9a 89       	ldd	r25, Y+18	; 0x12
    1982:	01 97       	sbiw	r24, 0x01	; 1
    1984:	f1 f7       	brne	.-4      	; 0x1982 <HLCD_voidInit+0x39e>
    1986:	9a 8b       	std	Y+18, r25	; 0x12
    1988:	89 8b       	std	Y+17, r24	; 0x11
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    198a:	8b 89       	ldd	r24, Y+19	; 0x13
    198c:	9c 89       	ldd	r25, Y+20	; 0x14
    198e:	01 97       	sbiw	r24, 0x01	; 1
    1990:	9c 8b       	std	Y+20, r25	; 0x14
    1992:	8b 8b       	std	Y+19, r24	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1994:	8b 89       	ldd	r24, Y+19	; 0x13
    1996:	9c 89       	ldd	r25, Y+20	; 0x14
    1998:	00 97       	sbiw	r24, 0x00	; 0
    199a:	69 f7       	brne	.-38     	; 0x1976 <HLCD_voidInit+0x392>
    199c:	14 c0       	rjmp	.+40     	; 0x19c6 <HLCD_voidInit+0x3e2>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    199e:	6d 89       	ldd	r22, Y+21	; 0x15
    19a0:	7e 89       	ldd	r23, Y+22	; 0x16
    19a2:	8f 89       	ldd	r24, Y+23	; 0x17
    19a4:	98 8d       	ldd	r25, Y+24	; 0x18
    19a6:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    19aa:	dc 01       	movw	r26, r24
    19ac:	cb 01       	movw	r24, r22
    19ae:	9c 8b       	std	Y+20, r25	; 0x14
    19b0:	8b 8b       	std	Y+19, r24	; 0x13
    19b2:	8b 89       	ldd	r24, Y+19	; 0x13
    19b4:	9c 89       	ldd	r25, Y+20	; 0x14
    19b6:	98 8b       	std	Y+16, r25	; 0x10
    19b8:	8f 87       	std	Y+15, r24	; 0x0f
    19ba:	8f 85       	ldd	r24, Y+15	; 0x0f
    19bc:	98 89       	ldd	r25, Y+16	; 0x10
    19be:	01 97       	sbiw	r24, 0x01	; 1
    19c0:	f1 f7       	brne	.-4      	; 0x19be <HLCD_voidInit+0x3da>
    19c2:	98 8b       	std	Y+16, r25	; 0x10
    19c4:	8f 87       	std	Y+15, r24	; 0x0f
	//Wait for more than 1.53ms
	_delay_ms(2);

	// Entry Mode Set Command
	HLCD_voidSendCommand(ENTRY_MODE_SET);
    19c6:	86 e0       	ldi	r24, 0x06	; 6
    19c8:	0e 94 b6 09 	call	0x136c	; 0x136c <HLCD_voidSendCommand>
    19cc:	80 e0       	ldi	r24, 0x00	; 0
    19ce:	90 e0       	ldi	r25, 0x00	; 0
    19d0:	a0 e8       	ldi	r26, 0x80	; 128
    19d2:	bf e3       	ldi	r27, 0x3F	; 63
    19d4:	8b 87       	std	Y+11, r24	; 0x0b
    19d6:	9c 87       	std	Y+12, r25	; 0x0c
    19d8:	ad 87       	std	Y+13, r26	; 0x0d
    19da:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    19dc:	6b 85       	ldd	r22, Y+11	; 0x0b
    19de:	7c 85       	ldd	r23, Y+12	; 0x0c
    19e0:	8d 85       	ldd	r24, Y+13	; 0x0d
    19e2:	9e 85       	ldd	r25, Y+14	; 0x0e
    19e4:	20 e0       	ldi	r18, 0x00	; 0
    19e6:	30 e0       	ldi	r19, 0x00	; 0
    19e8:	4a ef       	ldi	r20, 0xFA	; 250
    19ea:	54 e4       	ldi	r21, 0x44	; 68
    19ec:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    19f0:	dc 01       	movw	r26, r24
    19f2:	cb 01       	movw	r24, r22
    19f4:	8f 83       	std	Y+7, r24	; 0x07
    19f6:	98 87       	std	Y+8, r25	; 0x08
    19f8:	a9 87       	std	Y+9, r26	; 0x09
    19fa:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    19fc:	6f 81       	ldd	r22, Y+7	; 0x07
    19fe:	78 85       	ldd	r23, Y+8	; 0x08
    1a00:	89 85       	ldd	r24, Y+9	; 0x09
    1a02:	9a 85       	ldd	r25, Y+10	; 0x0a
    1a04:	20 e0       	ldi	r18, 0x00	; 0
    1a06:	30 e0       	ldi	r19, 0x00	; 0
    1a08:	40 e8       	ldi	r20, 0x80	; 128
    1a0a:	5f e3       	ldi	r21, 0x3F	; 63
    1a0c:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    1a10:	88 23       	and	r24, r24
    1a12:	2c f4       	brge	.+10     	; 0x1a1e <HLCD_voidInit+0x43a>
		__ticks = 1;
    1a14:	81 e0       	ldi	r24, 0x01	; 1
    1a16:	90 e0       	ldi	r25, 0x00	; 0
    1a18:	9e 83       	std	Y+6, r25	; 0x06
    1a1a:	8d 83       	std	Y+5, r24	; 0x05
    1a1c:	3f c0       	rjmp	.+126    	; 0x1a9c <HLCD_voidInit+0x4b8>
	else if (__tmp > 65535)
    1a1e:	6f 81       	ldd	r22, Y+7	; 0x07
    1a20:	78 85       	ldd	r23, Y+8	; 0x08
    1a22:	89 85       	ldd	r24, Y+9	; 0x09
    1a24:	9a 85       	ldd	r25, Y+10	; 0x0a
    1a26:	20 e0       	ldi	r18, 0x00	; 0
    1a28:	3f ef       	ldi	r19, 0xFF	; 255
    1a2a:	4f e7       	ldi	r20, 0x7F	; 127
    1a2c:	57 e4       	ldi	r21, 0x47	; 71
    1a2e:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    1a32:	18 16       	cp	r1, r24
    1a34:	4c f5       	brge	.+82     	; 0x1a88 <HLCD_voidInit+0x4a4>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    1a36:	6b 85       	ldd	r22, Y+11	; 0x0b
    1a38:	7c 85       	ldd	r23, Y+12	; 0x0c
    1a3a:	8d 85       	ldd	r24, Y+13	; 0x0d
    1a3c:	9e 85       	ldd	r25, Y+14	; 0x0e
    1a3e:	20 e0       	ldi	r18, 0x00	; 0
    1a40:	30 e0       	ldi	r19, 0x00	; 0
    1a42:	40 e2       	ldi	r20, 0x20	; 32
    1a44:	51 e4       	ldi	r21, 0x41	; 65
    1a46:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1a4a:	dc 01       	movw	r26, r24
    1a4c:	cb 01       	movw	r24, r22
    1a4e:	bc 01       	movw	r22, r24
    1a50:	cd 01       	movw	r24, r26
    1a52:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1a56:	dc 01       	movw	r26, r24
    1a58:	cb 01       	movw	r24, r22
    1a5a:	9e 83       	std	Y+6, r25	; 0x06
    1a5c:	8d 83       	std	Y+5, r24	; 0x05
    1a5e:	0f c0       	rjmp	.+30     	; 0x1a7e <HLCD_voidInit+0x49a>
    1a60:	88 ec       	ldi	r24, 0xC8	; 200
    1a62:	90 e0       	ldi	r25, 0x00	; 0
    1a64:	9c 83       	std	Y+4, r25	; 0x04
    1a66:	8b 83       	std	Y+3, r24	; 0x03
    1a68:	8b 81       	ldd	r24, Y+3	; 0x03
    1a6a:	9c 81       	ldd	r25, Y+4	; 0x04
    1a6c:	01 97       	sbiw	r24, 0x01	; 1
    1a6e:	f1 f7       	brne	.-4      	; 0x1a6c <HLCD_voidInit+0x488>
    1a70:	9c 83       	std	Y+4, r25	; 0x04
    1a72:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1a74:	8d 81       	ldd	r24, Y+5	; 0x05
    1a76:	9e 81       	ldd	r25, Y+6	; 0x06
    1a78:	01 97       	sbiw	r24, 0x01	; 1
    1a7a:	9e 83       	std	Y+6, r25	; 0x06
    1a7c:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1a7e:	8d 81       	ldd	r24, Y+5	; 0x05
    1a80:	9e 81       	ldd	r25, Y+6	; 0x06
    1a82:	00 97       	sbiw	r24, 0x00	; 0
    1a84:	69 f7       	brne	.-38     	; 0x1a60 <HLCD_voidInit+0x47c>
    1a86:	14 c0       	rjmp	.+40     	; 0x1ab0 <HLCD_voidInit+0x4cc>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    1a88:	6f 81       	ldd	r22, Y+7	; 0x07
    1a8a:	78 85       	ldd	r23, Y+8	; 0x08
    1a8c:	89 85       	ldd	r24, Y+9	; 0x09
    1a8e:	9a 85       	ldd	r25, Y+10	; 0x0a
    1a90:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1a94:	dc 01       	movw	r26, r24
    1a96:	cb 01       	movw	r24, r22
    1a98:	9e 83       	std	Y+6, r25	; 0x06
    1a9a:	8d 83       	std	Y+5, r24	; 0x05
    1a9c:	8d 81       	ldd	r24, Y+5	; 0x05
    1a9e:	9e 81       	ldd	r25, Y+6	; 0x06
    1aa0:	9a 83       	std	Y+2, r25	; 0x02
    1aa2:	89 83       	std	Y+1, r24	; 0x01
    1aa4:	89 81       	ldd	r24, Y+1	; 0x01
    1aa6:	9a 81       	ldd	r25, Y+2	; 0x02
    1aa8:	01 97       	sbiw	r24, 0x01	; 1
    1aaa:	f1 f7       	brne	.-4      	; 0x1aa8 <HLCD_voidInit+0x4c4>
    1aac:	9a 83       	std	Y+2, r25	; 0x02
    1aae:	89 83       	std	Y+1, r24	; 0x01
	//Wait for more than 39 us
	_delay_ms(1);
}
    1ab0:	ca 5b       	subi	r28, 0xBA	; 186
    1ab2:	df 4f       	sbci	r29, 0xFF	; 255
    1ab4:	0f b6       	in	r0, 0x3f	; 63
    1ab6:	f8 94       	cli
    1ab8:	de bf       	out	0x3e, r29	; 62
    1aba:	0f be       	out	0x3f, r0	; 63
    1abc:	cd bf       	out	0x3d, r28	; 61
    1abe:	cf 91       	pop	r28
    1ac0:	df 91       	pop	r29
    1ac2:	1f 91       	pop	r17
    1ac4:	0f 91       	pop	r16
    1ac6:	08 95       	ret

00001ac8 <HLCD_voidDisplayString>:

void HLCD_voidDisplayString (u8 * A_ptrToString)
{
    1ac8:	df 93       	push	r29
    1aca:	cf 93       	push	r28
    1acc:	00 d0       	rcall	.+0      	; 0x1ace <HLCD_voidDisplayString+0x6>
    1ace:	cd b7       	in	r28, 0x3d	; 61
    1ad0:	de b7       	in	r29, 0x3e	; 62
    1ad2:	9a 83       	std	Y+2, r25	; 0x02
    1ad4:	89 83       	std	Y+1, r24	; 0x01
    1ad6:	0b c0       	rjmp	.+22     	; 0x1aee <HLCD_voidDisplayString+0x26>
	while (*A_ptrToString > 0)
	{
		HLCD_voidSendData(*A_ptrToString++);
    1ad8:	e9 81       	ldd	r30, Y+1	; 0x01
    1ada:	fa 81       	ldd	r31, Y+2	; 0x02
    1adc:	20 81       	ld	r18, Z
    1ade:	89 81       	ldd	r24, Y+1	; 0x01
    1ae0:	9a 81       	ldd	r25, Y+2	; 0x02
    1ae2:	01 96       	adiw	r24, 0x01	; 1
    1ae4:	9a 83       	std	Y+2, r25	; 0x02
    1ae6:	89 83       	std	Y+1, r24	; 0x01
    1ae8:	82 2f       	mov	r24, r18
    1aea:	0e 94 54 0a 	call	0x14a8	; 0x14a8 <HLCD_voidSendData>
	_delay_ms(1);
}

void HLCD_voidDisplayString (u8 * A_ptrToString)
{
	while (*A_ptrToString > 0)
    1aee:	e9 81       	ldd	r30, Y+1	; 0x01
    1af0:	fa 81       	ldd	r31, Y+2	; 0x02
    1af2:	80 81       	ld	r24, Z
    1af4:	88 23       	and	r24, r24
    1af6:	81 f7       	brne	.-32     	; 0x1ad8 <HLCD_voidDisplayString+0x10>
	{
		HLCD_voidSendData(*A_ptrToString++);
	}
}
    1af8:	0f 90       	pop	r0
    1afa:	0f 90       	pop	r0
    1afc:	cf 91       	pop	r28
    1afe:	df 91       	pop	r29
    1b00:	08 95       	ret

00001b02 <HLCD_voidDisplayNumber>:

void HLCD_voidDisplayNumber (u32 A_u32Number)
{
    1b02:	ef 92       	push	r14
    1b04:	ff 92       	push	r15
    1b06:	0f 93       	push	r16
    1b08:	1f 93       	push	r17
    1b0a:	df 93       	push	r29
    1b0c:	cf 93       	push	r28
    1b0e:	cd b7       	in	r28, 0x3d	; 61
    1b10:	de b7       	in	r29, 0x3e	; 62
    1b12:	28 97       	sbiw	r28, 0x08	; 8
    1b14:	0f b6       	in	r0, 0x3f	; 63
    1b16:	f8 94       	cli
    1b18:	de bf       	out	0x3e, r29	; 62
    1b1a:	0f be       	out	0x3f, r0	; 63
    1b1c:	cd bf       	out	0x3d, r28	; 61
    1b1e:	6d 83       	std	Y+5, r22	; 0x05
    1b20:	7e 83       	std	Y+6, r23	; 0x06
    1b22:	8f 83       	std	Y+7, r24	; 0x07
    1b24:	98 87       	std	Y+8, r25	; 0x08
  u32 local_u32Number = 1;
    1b26:	81 e0       	ldi	r24, 0x01	; 1
    1b28:	90 e0       	ldi	r25, 0x00	; 0
    1b2a:	a0 e0       	ldi	r26, 0x00	; 0
    1b2c:	b0 e0       	ldi	r27, 0x00	; 0
    1b2e:	89 83       	std	Y+1, r24	; 0x01
    1b30:	9a 83       	std	Y+2, r25	; 0x02
    1b32:	ab 83       	std	Y+3, r26	; 0x03
    1b34:	bc 83       	std	Y+4, r27	; 0x04
  if (A_u32Number == 0)
    1b36:	8d 81       	ldd	r24, Y+5	; 0x05
    1b38:	9e 81       	ldd	r25, Y+6	; 0x06
    1b3a:	af 81       	ldd	r26, Y+7	; 0x07
    1b3c:	b8 85       	ldd	r27, Y+8	; 0x08
    1b3e:	00 97       	sbiw	r24, 0x00	; 0
    1b40:	a1 05       	cpc	r26, r1
    1b42:	b1 05       	cpc	r27, r1
    1b44:	d1 f5       	brne	.+116    	; 0x1bba <HLCD_voidDisplayNumber+0xb8>
  {
	  HLCD_voidSendData('0');
    1b46:	80 e3       	ldi	r24, 0x30	; 48
    1b48:	0e 94 54 0a 	call	0x14a8	; 0x14a8 <HLCD_voidSendData>
    1b4c:	6b c0       	rjmp	.+214    	; 0x1c24 <HLCD_voidDisplayNumber+0x122>
  }
  else
  {
	  while (A_u32Number != 0)
	  {
		  local_u32Number = ((local_u32Number*10)+(A_u32Number%10));
    1b4e:	89 81       	ldd	r24, Y+1	; 0x01
    1b50:	9a 81       	ldd	r25, Y+2	; 0x02
    1b52:	ab 81       	ldd	r26, Y+3	; 0x03
    1b54:	bc 81       	ldd	r27, Y+4	; 0x04
    1b56:	2a e0       	ldi	r18, 0x0A	; 10
    1b58:	30 e0       	ldi	r19, 0x00	; 0
    1b5a:	40 e0       	ldi	r20, 0x00	; 0
    1b5c:	50 e0       	ldi	r21, 0x00	; 0
    1b5e:	bc 01       	movw	r22, r24
    1b60:	cd 01       	movw	r24, r26
    1b62:	0e 94 1b 22 	call	0x4436	; 0x4436 <__mulsi3>
    1b66:	7b 01       	movw	r14, r22
    1b68:	8c 01       	movw	r16, r24
    1b6a:	8d 81       	ldd	r24, Y+5	; 0x05
    1b6c:	9e 81       	ldd	r25, Y+6	; 0x06
    1b6e:	af 81       	ldd	r26, Y+7	; 0x07
    1b70:	b8 85       	ldd	r27, Y+8	; 0x08
    1b72:	2a e0       	ldi	r18, 0x0A	; 10
    1b74:	30 e0       	ldi	r19, 0x00	; 0
    1b76:	40 e0       	ldi	r20, 0x00	; 0
    1b78:	50 e0       	ldi	r21, 0x00	; 0
    1b7a:	bc 01       	movw	r22, r24
    1b7c:	cd 01       	movw	r24, r26
    1b7e:	0e 94 3a 22 	call	0x4474	; 0x4474 <__udivmodsi4>
    1b82:	dc 01       	movw	r26, r24
    1b84:	cb 01       	movw	r24, r22
    1b86:	8e 0d       	add	r24, r14
    1b88:	9f 1d       	adc	r25, r15
    1b8a:	a0 1f       	adc	r26, r16
    1b8c:	b1 1f       	adc	r27, r17
    1b8e:	89 83       	std	Y+1, r24	; 0x01
    1b90:	9a 83       	std	Y+2, r25	; 0x02
    1b92:	ab 83       	std	Y+3, r26	; 0x03
    1b94:	bc 83       	std	Y+4, r27	; 0x04
		  A_u32Number = A_u32Number / 10;
    1b96:	8d 81       	ldd	r24, Y+5	; 0x05
    1b98:	9e 81       	ldd	r25, Y+6	; 0x06
    1b9a:	af 81       	ldd	r26, Y+7	; 0x07
    1b9c:	b8 85       	ldd	r27, Y+8	; 0x08
    1b9e:	2a e0       	ldi	r18, 0x0A	; 10
    1ba0:	30 e0       	ldi	r19, 0x00	; 0
    1ba2:	40 e0       	ldi	r20, 0x00	; 0
    1ba4:	50 e0       	ldi	r21, 0x00	; 0
    1ba6:	bc 01       	movw	r22, r24
    1ba8:	cd 01       	movw	r24, r26
    1baa:	0e 94 3a 22 	call	0x4474	; 0x4474 <__udivmodsi4>
    1bae:	da 01       	movw	r26, r20
    1bb0:	c9 01       	movw	r24, r18
    1bb2:	8d 83       	std	Y+5, r24	; 0x05
    1bb4:	9e 83       	std	Y+6, r25	; 0x06
    1bb6:	af 83       	std	Y+7, r26	; 0x07
    1bb8:	b8 87       	std	Y+8, r27	; 0x08
  {
	  HLCD_voidSendData('0');
  }
  else
  {
	  while (A_u32Number != 0)
    1bba:	8d 81       	ldd	r24, Y+5	; 0x05
    1bbc:	9e 81       	ldd	r25, Y+6	; 0x06
    1bbe:	af 81       	ldd	r26, Y+7	; 0x07
    1bc0:	b8 85       	ldd	r27, Y+8	; 0x08
    1bc2:	00 97       	sbiw	r24, 0x00	; 0
    1bc4:	a1 05       	cpc	r26, r1
    1bc6:	b1 05       	cpc	r27, r1
    1bc8:	11 f6       	brne	.-124    	; 0x1b4e <HLCD_voidDisplayNumber+0x4c>
    1bca:	23 c0       	rjmp	.+70     	; 0x1c12 <HLCD_voidDisplayNumber+0x110>
		  local_u32Number = ((local_u32Number*10)+(A_u32Number%10));
		  A_u32Number = A_u32Number / 10;
	  }
	  while (local_u32Number !=1)
	  {
		  HLCD_voidSendData((local_u32Number%10)+48);
    1bcc:	89 81       	ldd	r24, Y+1	; 0x01
    1bce:	9a 81       	ldd	r25, Y+2	; 0x02
    1bd0:	ab 81       	ldd	r26, Y+3	; 0x03
    1bd2:	bc 81       	ldd	r27, Y+4	; 0x04
    1bd4:	2a e0       	ldi	r18, 0x0A	; 10
    1bd6:	30 e0       	ldi	r19, 0x00	; 0
    1bd8:	40 e0       	ldi	r20, 0x00	; 0
    1bda:	50 e0       	ldi	r21, 0x00	; 0
    1bdc:	bc 01       	movw	r22, r24
    1bde:	cd 01       	movw	r24, r26
    1be0:	0e 94 3a 22 	call	0x4474	; 0x4474 <__udivmodsi4>
    1be4:	dc 01       	movw	r26, r24
    1be6:	cb 01       	movw	r24, r22
    1be8:	80 5d       	subi	r24, 0xD0	; 208
    1bea:	0e 94 54 0a 	call	0x14a8	; 0x14a8 <HLCD_voidSendData>
		  local_u32Number = local_u32Number /10;
    1bee:	89 81       	ldd	r24, Y+1	; 0x01
    1bf0:	9a 81       	ldd	r25, Y+2	; 0x02
    1bf2:	ab 81       	ldd	r26, Y+3	; 0x03
    1bf4:	bc 81       	ldd	r27, Y+4	; 0x04
    1bf6:	2a e0       	ldi	r18, 0x0A	; 10
    1bf8:	30 e0       	ldi	r19, 0x00	; 0
    1bfa:	40 e0       	ldi	r20, 0x00	; 0
    1bfc:	50 e0       	ldi	r21, 0x00	; 0
    1bfe:	bc 01       	movw	r22, r24
    1c00:	cd 01       	movw	r24, r26
    1c02:	0e 94 3a 22 	call	0x4474	; 0x4474 <__udivmodsi4>
    1c06:	da 01       	movw	r26, r20
    1c08:	c9 01       	movw	r24, r18
    1c0a:	89 83       	std	Y+1, r24	; 0x01
    1c0c:	9a 83       	std	Y+2, r25	; 0x02
    1c0e:	ab 83       	std	Y+3, r26	; 0x03
    1c10:	bc 83       	std	Y+4, r27	; 0x04
	  while (A_u32Number != 0)
	  {
		  local_u32Number = ((local_u32Number*10)+(A_u32Number%10));
		  A_u32Number = A_u32Number / 10;
	  }
	  while (local_u32Number !=1)
    1c12:	89 81       	ldd	r24, Y+1	; 0x01
    1c14:	9a 81       	ldd	r25, Y+2	; 0x02
    1c16:	ab 81       	ldd	r26, Y+3	; 0x03
    1c18:	bc 81       	ldd	r27, Y+4	; 0x04
    1c1a:	81 30       	cpi	r24, 0x01	; 1
    1c1c:	91 05       	cpc	r25, r1
    1c1e:	a1 05       	cpc	r26, r1
    1c20:	b1 05       	cpc	r27, r1
    1c22:	a1 f6       	brne	.-88     	; 0x1bcc <HLCD_voidDisplayNumber+0xca>
	  {
		  HLCD_voidSendData((local_u32Number%10)+48);
		  local_u32Number = local_u32Number /10;
	  }
  }
}
    1c24:	28 96       	adiw	r28, 0x08	; 8
    1c26:	0f b6       	in	r0, 0x3f	; 63
    1c28:	f8 94       	cli
    1c2a:	de bf       	out	0x3e, r29	; 62
    1c2c:	0f be       	out	0x3f, r0	; 63
    1c2e:	cd bf       	out	0x3d, r28	; 61
    1c30:	cf 91       	pop	r28
    1c32:	df 91       	pop	r29
    1c34:	1f 91       	pop	r17
    1c36:	0f 91       	pop	r16
    1c38:	ff 90       	pop	r15
    1c3a:	ef 90       	pop	r14
    1c3c:	08 95       	ret

00001c3e <HLED_voidTurnLEDOn>:
#include "../Include/HAL/LED/LED_Private.h"
#include "../Include/HAL/LED/LED_cfg.h"


void HLED_voidTurnLEDOn(DIO_PORT_e A_portID, DIO_PIN_e A_pinID)
{
    1c3e:	df 93       	push	r29
    1c40:	cf 93       	push	r28
    1c42:	00 d0       	rcall	.+0      	; 0x1c44 <HLED_voidTurnLEDOn+0x6>
    1c44:	cd b7       	in	r28, 0x3d	; 61
    1c46:	de b7       	in	r29, 0x3e	; 62
    1c48:	89 83       	std	Y+1, r24	; 0x01
    1c4a:	6a 83       	std	Y+2, r22	; 0x02
	MDIO_voidSetPinValue(A_portID ,A_pinID , DIO_SET);
    1c4c:	89 81       	ldd	r24, Y+1	; 0x01
    1c4e:	6a 81       	ldd	r22, Y+2	; 0x02
    1c50:	41 e0       	ldi	r20, 0x01	; 1
    1c52:	0e 94 c6 06 	call	0xd8c	; 0xd8c <MDIO_voidSetPinValue>
}
    1c56:	0f 90       	pop	r0
    1c58:	0f 90       	pop	r0
    1c5a:	cf 91       	pop	r28
    1c5c:	df 91       	pop	r29
    1c5e:	08 95       	ret

00001c60 <HLED_voidTurnLEDOff>:
void HLED_voidTurnLEDOff(DIO_PORT_e A_portID, DIO_PIN_e A_pinID)
{
    1c60:	df 93       	push	r29
    1c62:	cf 93       	push	r28
    1c64:	00 d0       	rcall	.+0      	; 0x1c66 <HLED_voidTurnLEDOff+0x6>
    1c66:	cd b7       	in	r28, 0x3d	; 61
    1c68:	de b7       	in	r29, 0x3e	; 62
    1c6a:	89 83       	std	Y+1, r24	; 0x01
    1c6c:	6a 83       	std	Y+2, r22	; 0x02
	MDIO_voidSetPinValue(A_portID ,A_pinID , DIO_RESET);
    1c6e:	89 81       	ldd	r24, Y+1	; 0x01
    1c70:	6a 81       	ldd	r22, Y+2	; 0x02
    1c72:	40 e0       	ldi	r20, 0x00	; 0
    1c74:	0e 94 c6 06 	call	0xd8c	; 0xd8c <MDIO_voidSetPinValue>
}
    1c78:	0f 90       	pop	r0
    1c7a:	0f 90       	pop	r0
    1c7c:	cf 91       	pop	r28
    1c7e:	df 91       	pop	r29
    1c80:	08 95       	ret

00001c82 <HLED_voidToggleLED>:
void HLED_voidToggleLED(DIO_PORT_e A_portID, DIO_PIN_e A_pinID)
{
    1c82:	df 93       	push	r29
    1c84:	cf 93       	push	r28
    1c86:	00 d0       	rcall	.+0      	; 0x1c88 <HLED_voidToggleLED+0x6>
    1c88:	cd b7       	in	r28, 0x3d	; 61
    1c8a:	de b7       	in	r29, 0x3e	; 62
    1c8c:	89 83       	std	Y+1, r24	; 0x01
    1c8e:	6a 83       	std	Y+2, r22	; 0x02
	MDIO_voidTogglePinValue(A_portID,A_pinID);
    1c90:	89 81       	ldd	r24, Y+1	; 0x01
    1c92:	6a 81       	ldd	r22, Y+2	; 0x02
    1c94:	0e 94 6a 08 	call	0x10d4	; 0x10d4 <MDIO_voidTogglePinValue>
}
    1c98:	0f 90       	pop	r0
    1c9a:	0f 90       	pop	r0
    1c9c:	cf 91       	pop	r28
    1c9e:	df 91       	pop	r29
    1ca0:	08 95       	ret

00001ca2 <main>:

void LCDTask1 (void *pv);
void LCDTask2 (void *pv);

int main()
{
    1ca2:	af 92       	push	r10
    1ca4:	bf 92       	push	r11
    1ca6:	cf 92       	push	r12
    1ca8:	df 92       	push	r13
    1caa:	ef 92       	push	r14
    1cac:	ff 92       	push	r15
    1cae:	0f 93       	push	r16
    1cb0:	df 93       	push	r29
    1cb2:	cf 93       	push	r28
    1cb4:	cd b7       	in	r28, 0x3d	; 61
    1cb6:	de b7       	in	r29, 0x3e	; 62
	MDIO_voidInit();
    1cb8:	0e 94 77 09 	call	0x12ee	; 0x12ee <MDIO_voidInit>
	MGI_voidEnable();
    1cbc:	0e 94 9a 09 	call	0x1334	; 0x1334 <MGI_voidEnable>
	HLCD_voidInit();
    1cc0:	0e 94 f2 0a 	call	0x15e4	; 0x15e4 <HLCD_voidInit>

	// Create 3 Tasks for Toggle LEDs
	xTaskCreate(LED_Toggle1,NULL,200,NULL,4,NULL);
    1cc4:	8e e2       	ldi	r24, 0x2E	; 46
    1cc6:	9f e0       	ldi	r25, 0x0F	; 15
    1cc8:	60 e0       	ldi	r22, 0x00	; 0
    1cca:	70 e0       	ldi	r23, 0x00	; 0
    1ccc:	48 ec       	ldi	r20, 0xC8	; 200
    1cce:	50 e0       	ldi	r21, 0x00	; 0
    1cd0:	20 e0       	ldi	r18, 0x00	; 0
    1cd2:	30 e0       	ldi	r19, 0x00	; 0
    1cd4:	04 e0       	ldi	r16, 0x04	; 4
    1cd6:	ee 24       	eor	r14, r14
    1cd8:	ff 24       	eor	r15, r15
    1cda:	cc 24       	eor	r12, r12
    1cdc:	dd 24       	eor	r13, r13
    1cde:	aa 24       	eor	r10, r10
    1ce0:	bb 24       	eor	r11, r11
    1ce2:	0e 94 30 1b 	call	0x3660	; 0x3660 <xTaskGenericCreate>
	xTaskCreate(LED_Toggle2,NULL,200,NULL,3,NULL);
    1ce6:	8e e3       	ldi	r24, 0x3E	; 62
    1ce8:	9f e0       	ldi	r25, 0x0F	; 15
    1cea:	60 e0       	ldi	r22, 0x00	; 0
    1cec:	70 e0       	ldi	r23, 0x00	; 0
    1cee:	48 ec       	ldi	r20, 0xC8	; 200
    1cf0:	50 e0       	ldi	r21, 0x00	; 0
    1cf2:	20 e0       	ldi	r18, 0x00	; 0
    1cf4:	30 e0       	ldi	r19, 0x00	; 0
    1cf6:	03 e0       	ldi	r16, 0x03	; 3
    1cf8:	ee 24       	eor	r14, r14
    1cfa:	ff 24       	eor	r15, r15
    1cfc:	cc 24       	eor	r12, r12
    1cfe:	dd 24       	eor	r13, r13
    1d00:	aa 24       	eor	r10, r10
    1d02:	bb 24       	eor	r11, r11
    1d04:	0e 94 30 1b 	call	0x3660	; 0x3660 <xTaskGenericCreate>
	xTaskCreate(LED_Toggle3,NULL,200,NULL,2,NULL);
    1d08:	8e e4       	ldi	r24, 0x4E	; 78
    1d0a:	9f e0       	ldi	r25, 0x0F	; 15
    1d0c:	60 e0       	ldi	r22, 0x00	; 0
    1d0e:	70 e0       	ldi	r23, 0x00	; 0
    1d10:	48 ec       	ldi	r20, 0xC8	; 200
    1d12:	50 e0       	ldi	r21, 0x00	; 0
    1d14:	20 e0       	ldi	r18, 0x00	; 0
    1d16:	30 e0       	ldi	r19, 0x00	; 0
    1d18:	02 e0       	ldi	r16, 0x02	; 2
    1d1a:	ee 24       	eor	r14, r14
    1d1c:	ff 24       	eor	r15, r15
    1d1e:	cc 24       	eor	r12, r12
    1d20:	dd 24       	eor	r13, r13
    1d22:	aa 24       	eor	r10, r10
    1d24:	bb 24       	eor	r11, r11
    1d26:	0e 94 30 1b 	call	0x3660	; 0x3660 <xTaskGenericCreate>

	//Create 2 Tasks for LCD
	xTaskCreate(LCDTask1,NULL,200,NULL,2,NULL);
    1d2a:	8e ed       	ldi	r24, 0xDE	; 222
    1d2c:	9e e0       	ldi	r25, 0x0E	; 14
    1d2e:	60 e0       	ldi	r22, 0x00	; 0
    1d30:	70 e0       	ldi	r23, 0x00	; 0
    1d32:	48 ec       	ldi	r20, 0xC8	; 200
    1d34:	50 e0       	ldi	r21, 0x00	; 0
    1d36:	20 e0       	ldi	r18, 0x00	; 0
    1d38:	30 e0       	ldi	r19, 0x00	; 0
    1d3a:	02 e0       	ldi	r16, 0x02	; 2
    1d3c:	ee 24       	eor	r14, r14
    1d3e:	ff 24       	eor	r15, r15
    1d40:	cc 24       	eor	r12, r12
    1d42:	dd 24       	eor	r13, r13
    1d44:	aa 24       	eor	r10, r10
    1d46:	bb 24       	eor	r11, r11
    1d48:	0e 94 30 1b 	call	0x3660	; 0x3660 <xTaskGenericCreate>
	xTaskCreate(LCDTask2,NULL,200,NULL,2,NULL);
    1d4c:	86 e0       	ldi	r24, 0x06	; 6
    1d4e:	9f e0       	ldi	r25, 0x0F	; 15
    1d50:	60 e0       	ldi	r22, 0x00	; 0
    1d52:	70 e0       	ldi	r23, 0x00	; 0
    1d54:	48 ec       	ldi	r20, 0xC8	; 200
    1d56:	50 e0       	ldi	r21, 0x00	; 0
    1d58:	20 e0       	ldi	r18, 0x00	; 0
    1d5a:	30 e0       	ldi	r19, 0x00	; 0
    1d5c:	02 e0       	ldi	r16, 0x02	; 2
    1d5e:	ee 24       	eor	r14, r14
    1d60:	ff 24       	eor	r15, r15
    1d62:	cc 24       	eor	r12, r12
    1d64:	dd 24       	eor	r13, r13
    1d66:	aa 24       	eor	r10, r10
    1d68:	bb 24       	eor	r11, r11
    1d6a:	0e 94 30 1b 	call	0x3660	; 0x3660 <xTaskGenericCreate>

	// Create Binary Semaphore
	vSemaphoreCreateBinary(LCD_Semaphore);
    1d6e:	81 e0       	ldi	r24, 0x01	; 1
    1d70:	60 e0       	ldi	r22, 0x00	; 0
    1d72:	0e 94 af 16 	call	0x2d5e	; 0x2d5e <xQueueCreate>
    1d76:	90 93 f6 06 	sts	0x06F6, r25
    1d7a:	80 93 f5 06 	sts	0x06F5, r24
    1d7e:	80 91 f5 06 	lds	r24, 0x06F5
    1d82:	90 91 f6 06 	lds	r25, 0x06F6
    1d86:	00 97       	sbiw	r24, 0x00	; 0
    1d88:	59 f0       	breq	.+22     	; 0x1da0 <main+0xfe>
    1d8a:	80 91 f5 06 	lds	r24, 0x06F5
    1d8e:	90 91 f6 06 	lds	r25, 0x06F6
    1d92:	60 e0       	ldi	r22, 0x00	; 0
    1d94:	70 e0       	ldi	r23, 0x00	; 0
    1d96:	40 e0       	ldi	r20, 0x00	; 0
    1d98:	50 e0       	ldi	r21, 0x00	; 0
    1d9a:	20 e0       	ldi	r18, 0x00	; 0
    1d9c:	0e 94 58 17 	call	0x2eb0	; 0x2eb0 <xQueueGenericSend>

	// Start FreeRTOS Scheduler
	vTaskStartScheduler();
    1da0:	0e 94 29 1d 	call	0x3a52	; 0x3a52 <vTaskStartScheduler>
    1da4:	80 e0       	ldi	r24, 0x00	; 0
    1da6:	90 e0       	ldi	r25, 0x00	; 0
}
    1da8:	cf 91       	pop	r28
    1daa:	df 91       	pop	r29
    1dac:	0f 91       	pop	r16
    1dae:	ff 90       	pop	r15
    1db0:	ef 90       	pop	r14
    1db2:	df 90       	pop	r13
    1db4:	cf 90       	pop	r12
    1db6:	bf 90       	pop	r11
    1db8:	af 90       	pop	r10
    1dba:	08 95       	ret

00001dbc <LCDTask1>:

void LCDTask1 (void *pv)
{
    1dbc:	df 93       	push	r29
    1dbe:	cf 93       	push	r28
    1dc0:	00 d0       	rcall	.+0      	; 0x1dc2 <LCDTask1+0x6>
    1dc2:	cd b7       	in	r28, 0x3d	; 61
    1dc4:	de b7       	in	r29, 0x3e	; 62
    1dc6:	9a 83       	std	Y+2, r25	; 0x02
    1dc8:	89 83       	std	Y+1, r24	; 0x01
	while(1)
	{
		if(xSemaphoreTake(LCD_Semaphore,portMAX_DELAY) == pdTRUE)
    1dca:	80 91 f5 06 	lds	r24, 0x06F5
    1dce:	90 91 f6 06 	lds	r25, 0x06F6
    1dd2:	60 e0       	ldi	r22, 0x00	; 0
    1dd4:	70 e0       	ldi	r23, 0x00	; 0
    1dd6:	4f ef       	ldi	r20, 0xFF	; 255
    1dd8:	5f ef       	ldi	r21, 0xFF	; 255
    1dda:	20 e0       	ldi	r18, 0x00	; 0
    1ddc:	0e 94 43 18 	call	0x3086	; 0x3086 <xQueueGenericReceive>
    1de0:	81 30       	cpi	r24, 0x01	; 1
    1de2:	79 f4       	brne	.+30     	; 0x1e02 <LCDTask1+0x46>
		{
			HLCD_voidDisplayString(" T1 ");
    1de4:	80 e6       	ldi	r24, 0x60	; 96
    1de6:	90 e0       	ldi	r25, 0x00	; 0
    1de8:	0e 94 64 0d 	call	0x1ac8	; 0x1ac8 <HLCD_voidDisplayString>
			xSemaphoreGive(LCD_Semaphore);
    1dec:	80 91 f5 06 	lds	r24, 0x06F5
    1df0:	90 91 f6 06 	lds	r25, 0x06F6
    1df4:	60 e0       	ldi	r22, 0x00	; 0
    1df6:	70 e0       	ldi	r23, 0x00	; 0
    1df8:	40 e0       	ldi	r20, 0x00	; 0
    1dfa:	50 e0       	ldi	r21, 0x00	; 0
    1dfc:	20 e0       	ldi	r18, 0x00	; 0
    1dfe:	0e 94 58 17 	call	0x2eb0	; 0x2eb0 <xQueueGenericSend>
		}
		vTaskDelay(1000);
    1e02:	88 ee       	ldi	r24, 0xE8	; 232
    1e04:	93 e0       	ldi	r25, 0x03	; 3
    1e06:	0e 94 f4 1c 	call	0x39e8	; 0x39e8 <vTaskDelay>
    1e0a:	df cf       	rjmp	.-66     	; 0x1dca <LCDTask1+0xe>

00001e0c <LCDTask2>:
	}
}

void LCDTask2 (void *pv)
{
    1e0c:	df 93       	push	r29
    1e0e:	cf 93       	push	r28
    1e10:	00 d0       	rcall	.+0      	; 0x1e12 <LCDTask2+0x6>
    1e12:	cd b7       	in	r28, 0x3d	; 61
    1e14:	de b7       	in	r29, 0x3e	; 62
    1e16:	9a 83       	std	Y+2, r25	; 0x02
    1e18:	89 83       	std	Y+1, r24	; 0x01
	while(1)
	{
		if(xSemaphoreTake(LCD_Semaphore,portMAX_DELAY) == pdTRUE)
    1e1a:	80 91 f5 06 	lds	r24, 0x06F5
    1e1e:	90 91 f6 06 	lds	r25, 0x06F6
    1e22:	60 e0       	ldi	r22, 0x00	; 0
    1e24:	70 e0       	ldi	r23, 0x00	; 0
    1e26:	4f ef       	ldi	r20, 0xFF	; 255
    1e28:	5f ef       	ldi	r21, 0xFF	; 255
    1e2a:	20 e0       	ldi	r18, 0x00	; 0
    1e2c:	0e 94 43 18 	call	0x3086	; 0x3086 <xQueueGenericReceive>
    1e30:	81 30       	cpi	r24, 0x01	; 1
    1e32:	79 f4       	brne	.+30     	; 0x1e52 <LCDTask2+0x46>
		{
			HLCD_voidDisplayString(" T2 ");
    1e34:	85 e6       	ldi	r24, 0x65	; 101
    1e36:	90 e0       	ldi	r25, 0x00	; 0
    1e38:	0e 94 64 0d 	call	0x1ac8	; 0x1ac8 <HLCD_voidDisplayString>
			xSemaphoreGive(LCD_Semaphore);
    1e3c:	80 91 f5 06 	lds	r24, 0x06F5
    1e40:	90 91 f6 06 	lds	r25, 0x06F6
    1e44:	60 e0       	ldi	r22, 0x00	; 0
    1e46:	70 e0       	ldi	r23, 0x00	; 0
    1e48:	40 e0       	ldi	r20, 0x00	; 0
    1e4a:	50 e0       	ldi	r21, 0x00	; 0
    1e4c:	20 e0       	ldi	r18, 0x00	; 0
    1e4e:	0e 94 58 17 	call	0x2eb0	; 0x2eb0 <xQueueGenericSend>
		}
		vTaskDelay(1000);
    1e52:	88 ee       	ldi	r24, 0xE8	; 232
    1e54:	93 e0       	ldi	r25, 0x03	; 3
    1e56:	0e 94 f4 1c 	call	0x39e8	; 0x39e8 <vTaskDelay>
    1e5a:	df cf       	rjmp	.-66     	; 0x1e1a <LCDTask2+0xe>

00001e5c <LED_Toggle1>:
	}
}

void LED_Toggle1 (void * pv)
{
    1e5c:	df 93       	push	r29
    1e5e:	cf 93       	push	r28
    1e60:	00 d0       	rcall	.+0      	; 0x1e62 <LED_Toggle1+0x6>
    1e62:	cd b7       	in	r28, 0x3d	; 61
    1e64:	de b7       	in	r29, 0x3e	; 62
    1e66:	9a 83       	std	Y+2, r25	; 0x02
    1e68:	89 83       	std	Y+1, r24	; 0x01

	while(1)
	{
		HLED_voidToggleLED(DIO_PORTA, PIN0);
    1e6a:	80 e0       	ldi	r24, 0x00	; 0
    1e6c:	60 e0       	ldi	r22, 0x00	; 0
    1e6e:	0e 94 41 0e 	call	0x1c82	; 0x1c82 <HLED_voidToggleLED>
		vTaskDelay(1000);
    1e72:	88 ee       	ldi	r24, 0xE8	; 232
    1e74:	93 e0       	ldi	r25, 0x03	; 3
    1e76:	0e 94 f4 1c 	call	0x39e8	; 0x39e8 <vTaskDelay>
    1e7a:	f7 cf       	rjmp	.-18     	; 0x1e6a <LED_Toggle1+0xe>

00001e7c <LED_Toggle2>:
	}
}

void LED_Toggle2 (void * pv)
{
    1e7c:	df 93       	push	r29
    1e7e:	cf 93       	push	r28
    1e80:	00 d0       	rcall	.+0      	; 0x1e82 <LED_Toggle2+0x6>
    1e82:	cd b7       	in	r28, 0x3d	; 61
    1e84:	de b7       	in	r29, 0x3e	; 62
    1e86:	9a 83       	std	Y+2, r25	; 0x02
    1e88:	89 83       	std	Y+1, r24	; 0x01

	while(1)
	{
		HLED_voidToggleLED(DIO_PORTA, PIN1);
    1e8a:	80 e0       	ldi	r24, 0x00	; 0
    1e8c:	61 e0       	ldi	r22, 0x01	; 1
    1e8e:	0e 94 41 0e 	call	0x1c82	; 0x1c82 <HLED_voidToggleLED>
		vTaskDelay(2000);
    1e92:	80 ed       	ldi	r24, 0xD0	; 208
    1e94:	97 e0       	ldi	r25, 0x07	; 7
    1e96:	0e 94 f4 1c 	call	0x39e8	; 0x39e8 <vTaskDelay>
    1e9a:	f7 cf       	rjmp	.-18     	; 0x1e8a <LED_Toggle2+0xe>

00001e9c <LED_Toggle3>:
	}
}

void LED_Toggle3 (void * pv)
{
    1e9c:	df 93       	push	r29
    1e9e:	cf 93       	push	r28
    1ea0:	00 d0       	rcall	.+0      	; 0x1ea2 <LED_Toggle3+0x6>
    1ea2:	cd b7       	in	r28, 0x3d	; 61
    1ea4:	de b7       	in	r29, 0x3e	; 62
    1ea6:	9a 83       	std	Y+2, r25	; 0x02
    1ea8:	89 83       	std	Y+1, r24	; 0x01

	while(1)
	{
		HLED_voidToggleLED(DIO_PORTA, PIN2);
    1eaa:	80 e0       	ldi	r24, 0x00	; 0
    1eac:	62 e0       	ldi	r22, 0x02	; 2
    1eae:	0e 94 41 0e 	call	0x1c82	; 0x1c82 <HLED_voidToggleLED>
		vTaskDelay(5000);
    1eb2:	88 e8       	ldi	r24, 0x88	; 136
    1eb4:	93 e1       	ldi	r25, 0x13	; 19
    1eb6:	0e 94 f4 1c 	call	0x39e8	; 0x39e8 <vTaskDelay>
    1eba:	f7 cf       	rjmp	.-18     	; 0x1eaa <LED_Toggle3+0xe>

00001ebc <xCoRoutineCreate>:
static void prvCheckDelayedList( void );

/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineCreate( crCOROUTINE_CODE pxCoRoutineCode, unsigned portBASE_TYPE uxPriority, unsigned portBASE_TYPE uxIndex )
{
    1ebc:	df 93       	push	r29
    1ebe:	cf 93       	push	r28
    1ec0:	cd b7       	in	r28, 0x3d	; 61
    1ec2:	de b7       	in	r29, 0x3e	; 62
    1ec4:	27 97       	sbiw	r28, 0x07	; 7
    1ec6:	0f b6       	in	r0, 0x3f	; 63
    1ec8:	f8 94       	cli
    1eca:	de bf       	out	0x3e, r29	; 62
    1ecc:	0f be       	out	0x3f, r0	; 63
    1ece:	cd bf       	out	0x3d, r28	; 61
    1ed0:	9d 83       	std	Y+5, r25	; 0x05
    1ed2:	8c 83       	std	Y+4, r24	; 0x04
    1ed4:	6e 83       	std	Y+6, r22	; 0x06
    1ed6:	4f 83       	std	Y+7, r20	; 0x07
signed portBASE_TYPE xReturn;
corCRCB *pxCoRoutine;

	/* Allocate the memory that will store the co-routine control block. */
	pxCoRoutine = ( corCRCB * ) pvPortMalloc( sizeof( corCRCB ) );
    1ed8:	8a e1       	ldi	r24, 0x1A	; 26
    1eda:	90 e0       	ldi	r25, 0x00	; 0
    1edc:	0e 94 36 12 	call	0x246c	; 0x246c <pvPortMalloc>
    1ee0:	9a 83       	std	Y+2, r25	; 0x02
    1ee2:	89 83       	std	Y+1, r24	; 0x01
	if( pxCoRoutine )
    1ee4:	89 81       	ldd	r24, Y+1	; 0x01
    1ee6:	9a 81       	ldd	r25, Y+2	; 0x02
    1ee8:	00 97       	sbiw	r24, 0x00	; 0
    1eea:	09 f4       	brne	.+2      	; 0x1eee <xCoRoutineCreate+0x32>
    1eec:	6f c0       	rjmp	.+222    	; 0x1fcc <xCoRoutineCreate+0x110>
	{
		/* If pxCurrentCoRoutine is NULL then this is the first co-routine to
		be created and the co-routine data structures need initialising. */
		if( pxCurrentCoRoutine == NULL )
    1eee:	80 91 7a 00 	lds	r24, 0x007A
    1ef2:	90 91 7b 00 	lds	r25, 0x007B
    1ef6:	00 97       	sbiw	r24, 0x00	; 0
    1ef8:	41 f4       	brne	.+16     	; 0x1f0a <xCoRoutineCreate+0x4e>
		{
			pxCurrentCoRoutine = pxCoRoutine;
    1efa:	89 81       	ldd	r24, Y+1	; 0x01
    1efc:	9a 81       	ldd	r25, Y+2	; 0x02
    1efe:	90 93 7b 00 	sts	0x007B, r25
    1f02:	80 93 7a 00 	sts	0x007A, r24
			prvInitialiseCoRoutineLists();
    1f06:	0e 94 c5 11 	call	0x238a	; 0x238a <prvInitialiseCoRoutineLists>
		}

		/* Check the priority is within limits. */
		if( uxPriority >= configMAX_CO_ROUTINE_PRIORITIES )
    1f0a:	8e 81       	ldd	r24, Y+6	; 0x06
    1f0c:	82 30       	cpi	r24, 0x02	; 2
    1f0e:	10 f0       	brcs	.+4      	; 0x1f14 <xCoRoutineCreate+0x58>
		{
			uxPriority = configMAX_CO_ROUTINE_PRIORITIES - 1;
    1f10:	81 e0       	ldi	r24, 0x01	; 1
    1f12:	8e 83       	std	Y+6, r24	; 0x06
		}

		/* Fill out the co-routine control block from the function parameters. */
		pxCoRoutine->uxState = corINITIAL_STATE;
    1f14:	e9 81       	ldd	r30, Y+1	; 0x01
    1f16:	fa 81       	ldd	r31, Y+2	; 0x02
    1f18:	11 8e       	std	Z+25, r1	; 0x19
    1f1a:	10 8e       	std	Z+24, r1	; 0x18
		pxCoRoutine->uxPriority = uxPriority;
    1f1c:	e9 81       	ldd	r30, Y+1	; 0x01
    1f1e:	fa 81       	ldd	r31, Y+2	; 0x02
    1f20:	8e 81       	ldd	r24, Y+6	; 0x06
    1f22:	86 8b       	std	Z+22, r24	; 0x16
		pxCoRoutine->uxIndex = uxIndex;
    1f24:	e9 81       	ldd	r30, Y+1	; 0x01
    1f26:	fa 81       	ldd	r31, Y+2	; 0x02
    1f28:	8f 81       	ldd	r24, Y+7	; 0x07
    1f2a:	87 8b       	std	Z+23, r24	; 0x17
		pxCoRoutine->pxCoRoutineFunction = pxCoRoutineCode;
    1f2c:	e9 81       	ldd	r30, Y+1	; 0x01
    1f2e:	fa 81       	ldd	r31, Y+2	; 0x02
    1f30:	8c 81       	ldd	r24, Y+4	; 0x04
    1f32:	9d 81       	ldd	r25, Y+5	; 0x05
    1f34:	91 83       	std	Z+1, r25	; 0x01
    1f36:	80 83       	st	Z, r24

		/* Initialise all the other co-routine control block parameters. */
		vListInitialiseItem( &( pxCoRoutine->xGenericListItem ) );
    1f38:	89 81       	ldd	r24, Y+1	; 0x01
    1f3a:	9a 81       	ldd	r25, Y+2	; 0x02
    1f3c:	02 96       	adiw	r24, 0x02	; 2
    1f3e:	0e 94 cc 12 	call	0x2598	; 0x2598 <vListInitialiseItem>
		vListInitialiseItem( &( pxCoRoutine->xEventListItem ) );
    1f42:	89 81       	ldd	r24, Y+1	; 0x01
    1f44:	9a 81       	ldd	r25, Y+2	; 0x02
    1f46:	0c 96       	adiw	r24, 0x0c	; 12
    1f48:	0e 94 cc 12 	call	0x2598	; 0x2598 <vListInitialiseItem>

		/* Set the co-routine control block as a link back from the xListItem.
		This is so we can get back to the containing CRCB from a generic item
		in a list. */
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xGenericListItem ), pxCoRoutine );
    1f4c:	e9 81       	ldd	r30, Y+1	; 0x01
    1f4e:	fa 81       	ldd	r31, Y+2	; 0x02
    1f50:	89 81       	ldd	r24, Y+1	; 0x01
    1f52:	9a 81       	ldd	r25, Y+2	; 0x02
    1f54:	91 87       	std	Z+9, r25	; 0x09
    1f56:	80 87       	std	Z+8, r24	; 0x08
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xEventListItem ), pxCoRoutine );
    1f58:	e9 81       	ldd	r30, Y+1	; 0x01
    1f5a:	fa 81       	ldd	r31, Y+2	; 0x02
    1f5c:	89 81       	ldd	r24, Y+1	; 0x01
    1f5e:	9a 81       	ldd	r25, Y+2	; 0x02
    1f60:	93 8b       	std	Z+19, r25	; 0x13
    1f62:	82 8b       	std	Z+18, r24	; 0x12
	
		/* Event lists are always in priority order. */
		listSET_LIST_ITEM_VALUE( &( pxCoRoutine->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
    1f64:	8e 81       	ldd	r24, Y+6	; 0x06
    1f66:	28 2f       	mov	r18, r24
    1f68:	30 e0       	ldi	r19, 0x00	; 0
    1f6a:	85 e0       	ldi	r24, 0x05	; 5
    1f6c:	90 e0       	ldi	r25, 0x00	; 0
    1f6e:	82 1b       	sub	r24, r18
    1f70:	93 0b       	sbc	r25, r19
    1f72:	e9 81       	ldd	r30, Y+1	; 0x01
    1f74:	fa 81       	ldd	r31, Y+2	; 0x02
    1f76:	95 87       	std	Z+13, r25	; 0x0d
    1f78:	84 87       	std	Z+12, r24	; 0x0c
		
		/* Now the co-routine has been initialised it can be added to the ready
		list at the correct priority. */
		prvAddCoRoutineToReadyQueue( pxCoRoutine );
    1f7a:	e9 81       	ldd	r30, Y+1	; 0x01
    1f7c:	fa 81       	ldd	r31, Y+2	; 0x02
    1f7e:	96 89       	ldd	r25, Z+22	; 0x16
    1f80:	80 91 7c 00 	lds	r24, 0x007C
    1f84:	89 17       	cp	r24, r25
    1f86:	28 f4       	brcc	.+10     	; 0x1f92 <xCoRoutineCreate+0xd6>
    1f88:	e9 81       	ldd	r30, Y+1	; 0x01
    1f8a:	fa 81       	ldd	r31, Y+2	; 0x02
    1f8c:	86 89       	ldd	r24, Z+22	; 0x16
    1f8e:	80 93 7c 00 	sts	0x007C, r24
    1f92:	e9 81       	ldd	r30, Y+1	; 0x01
    1f94:	fa 81       	ldd	r31, Y+2	; 0x02
    1f96:	86 89       	ldd	r24, Z+22	; 0x16
    1f98:	28 2f       	mov	r18, r24
    1f9a:	30 e0       	ldi	r19, 0x00	; 0
    1f9c:	c9 01       	movw	r24, r18
    1f9e:	88 0f       	add	r24, r24
    1fa0:	99 1f       	adc	r25, r25
    1fa2:	88 0f       	add	r24, r24
    1fa4:	99 1f       	adc	r25, r25
    1fa6:	88 0f       	add	r24, r24
    1fa8:	99 1f       	adc	r25, r25
    1faa:	82 0f       	add	r24, r18
    1fac:	93 1f       	adc	r25, r19
    1fae:	ac 01       	movw	r20, r24
    1fb0:	4d 57       	subi	r20, 0x7D	; 125
    1fb2:	5f 4f       	sbci	r21, 0xFF	; 255
    1fb4:	89 81       	ldd	r24, Y+1	; 0x01
    1fb6:	9a 81       	ldd	r25, Y+2	; 0x02
    1fb8:	9c 01       	movw	r18, r24
    1fba:	2e 5f       	subi	r18, 0xFE	; 254
    1fbc:	3f 4f       	sbci	r19, 0xFF	; 255
    1fbe:	ca 01       	movw	r24, r20
    1fc0:	b9 01       	movw	r22, r18
    1fc2:	0e 94 dc 12 	call	0x25b8	; 0x25b8 <vListInsertEnd>

		xReturn = pdPASS;
    1fc6:	81 e0       	ldi	r24, 0x01	; 1
    1fc8:	8b 83       	std	Y+3, r24	; 0x03
    1fca:	02 c0       	rjmp	.+4      	; 0x1fd0 <xCoRoutineCreate+0x114>
	}
	else
	{		
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    1fcc:	8f ef       	ldi	r24, 0xFF	; 255
    1fce:	8b 83       	std	Y+3, r24	; 0x03
	}
	
	return xReturn;	
    1fd0:	8b 81       	ldd	r24, Y+3	; 0x03
}
    1fd2:	27 96       	adiw	r28, 0x07	; 7
    1fd4:	0f b6       	in	r0, 0x3f	; 63
    1fd6:	f8 94       	cli
    1fd8:	de bf       	out	0x3e, r29	; 62
    1fda:	0f be       	out	0x3f, r0	; 63
    1fdc:	cd bf       	out	0x3d, r28	; 61
    1fde:	cf 91       	pop	r28
    1fe0:	df 91       	pop	r29
    1fe2:	08 95       	ret

00001fe4 <vCoRoutineAddToDelayedList>:
/*-----------------------------------------------------------*/

void vCoRoutineAddToDelayedList( portTickType xTicksToDelay, xList *pxEventList )
{
    1fe4:	df 93       	push	r29
    1fe6:	cf 93       	push	r28
    1fe8:	00 d0       	rcall	.+0      	; 0x1fea <vCoRoutineAddToDelayedList+0x6>
    1fea:	00 d0       	rcall	.+0      	; 0x1fec <vCoRoutineAddToDelayedList+0x8>
    1fec:	00 d0       	rcall	.+0      	; 0x1fee <vCoRoutineAddToDelayedList+0xa>
    1fee:	cd b7       	in	r28, 0x3d	; 61
    1ff0:	de b7       	in	r29, 0x3e	; 62
    1ff2:	9c 83       	std	Y+4, r25	; 0x04
    1ff4:	8b 83       	std	Y+3, r24	; 0x03
    1ff6:	7e 83       	std	Y+6, r23	; 0x06
    1ff8:	6d 83       	std	Y+5, r22	; 0x05
portTickType xTimeToWake;

	/* Calculate the time to wake - this may overflow but this is
	not a problem. */
	xTimeToWake = xCoRoutineTickCount + xTicksToDelay;
    1ffa:	20 91 7d 00 	lds	r18, 0x007D
    1ffe:	30 91 7e 00 	lds	r19, 0x007E
    2002:	8b 81       	ldd	r24, Y+3	; 0x03
    2004:	9c 81       	ldd	r25, Y+4	; 0x04
    2006:	82 0f       	add	r24, r18
    2008:	93 1f       	adc	r25, r19
    200a:	9a 83       	std	Y+2, r25	; 0x02
    200c:	89 83       	std	Y+1, r24	; 0x01

	/* We must remove ourselves from the ready list before adding
	ourselves to the blocked list as the same list item is used for
	both lists. */
	vListRemove( ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    200e:	80 91 7a 00 	lds	r24, 0x007A
    2012:	90 91 7b 00 	lds	r25, 0x007B
    2016:	02 96       	adiw	r24, 0x02	; 2
    2018:	0e 94 94 13 	call	0x2728	; 0x2728 <vListRemove>

	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentCoRoutine->xGenericListItem ), xTimeToWake );
    201c:	e0 91 7a 00 	lds	r30, 0x007A
    2020:	f0 91 7b 00 	lds	r31, 0x007B
    2024:	89 81       	ldd	r24, Y+1	; 0x01
    2026:	9a 81       	ldd	r25, Y+2	; 0x02
    2028:	93 83       	std	Z+3, r25	; 0x03
    202a:	82 83       	std	Z+2, r24	; 0x02

	if( xTimeToWake < xCoRoutineTickCount )
    202c:	20 91 7d 00 	lds	r18, 0x007D
    2030:	30 91 7e 00 	lds	r19, 0x007E
    2034:	89 81       	ldd	r24, Y+1	; 0x01
    2036:	9a 81       	ldd	r25, Y+2	; 0x02
    2038:	82 17       	cp	r24, r18
    203a:	93 07       	cpc	r25, r19
    203c:	70 f4       	brcc	.+28     	; 0x205a <vCoRoutineAddToDelayedList+0x76>
	{
		/* Wake time has overflowed.  Place this item in the
		overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    203e:	80 91 a9 00 	lds	r24, 0x00A9
    2042:	90 91 aa 00 	lds	r25, 0x00AA
    2046:	20 91 7a 00 	lds	r18, 0x007A
    204a:	30 91 7b 00 	lds	r19, 0x007B
    204e:	2e 5f       	subi	r18, 0xFE	; 254
    2050:	3f 4f       	sbci	r19, 0xFF	; 255
    2052:	b9 01       	movw	r22, r18
    2054:	0e 94 28 13 	call	0x2650	; 0x2650 <vListInsert>
    2058:	0d c0       	rjmp	.+26     	; 0x2074 <vCoRoutineAddToDelayedList+0x90>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the
		current block list. */
		vListInsert( ( xList * ) pxDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    205a:	80 91 a7 00 	lds	r24, 0x00A7
    205e:	90 91 a8 00 	lds	r25, 0x00A8
    2062:	20 91 7a 00 	lds	r18, 0x007A
    2066:	30 91 7b 00 	lds	r19, 0x007B
    206a:	2e 5f       	subi	r18, 0xFE	; 254
    206c:	3f 4f       	sbci	r19, 0xFF	; 255
    206e:	b9 01       	movw	r22, r18
    2070:	0e 94 28 13 	call	0x2650	; 0x2650 <vListInsert>
	}

	if( pxEventList )
    2074:	8d 81       	ldd	r24, Y+5	; 0x05
    2076:	9e 81       	ldd	r25, Y+6	; 0x06
    2078:	00 97       	sbiw	r24, 0x00	; 0
    207a:	61 f0       	breq	.+24     	; 0x2094 <vCoRoutineAddToDelayedList+0xb0>
	{
		/* Also add the co-routine to an event list.  If this is done then the
		function must be called with interrupts disabled. */
		vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
    207c:	80 91 7a 00 	lds	r24, 0x007A
    2080:	90 91 7b 00 	lds	r25, 0x007B
    2084:	9c 01       	movw	r18, r24
    2086:	24 5f       	subi	r18, 0xF4	; 244
    2088:	3f 4f       	sbci	r19, 0xFF	; 255
    208a:	8d 81       	ldd	r24, Y+5	; 0x05
    208c:	9e 81       	ldd	r25, Y+6	; 0x06
    208e:	b9 01       	movw	r22, r18
    2090:	0e 94 28 13 	call	0x2650	; 0x2650 <vListInsert>
	}
}
    2094:	26 96       	adiw	r28, 0x06	; 6
    2096:	0f b6       	in	r0, 0x3f	; 63
    2098:	f8 94       	cli
    209a:	de bf       	out	0x3e, r29	; 62
    209c:	0f be       	out	0x3f, r0	; 63
    209e:	cd bf       	out	0x3d, r28	; 61
    20a0:	cf 91       	pop	r28
    20a2:	df 91       	pop	r29
    20a4:	08 95       	ret

000020a6 <prvCheckPendingReadyList>:
/*-----------------------------------------------------------*/

static void prvCheckPendingReadyList( void )
{
    20a6:	df 93       	push	r29
    20a8:	cf 93       	push	r28
    20aa:	00 d0       	rcall	.+0      	; 0x20ac <prvCheckPendingReadyList+0x6>
    20ac:	cd b7       	in	r28, 0x3d	; 61
    20ae:	de b7       	in	r29, 0x3e	; 62
    20b0:	3a c0       	rjmp	.+116    	; 0x2126 <prvCheckPendingReadyList+0x80>
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
	{
		corCRCB *pxUnblockedCRCB;

		/* The pending ready list can be accessed by an ISR. */
		portDISABLE_INTERRUPTS();
    20b2:	f8 94       	cli
		{	
			pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( (&xPendingReadyCoRoutineList) );			
    20b4:	e0 91 b0 00 	lds	r30, 0x00B0
    20b8:	f0 91 b1 00 	lds	r31, 0x00B1
    20bc:	86 81       	ldd	r24, Z+6	; 0x06
    20be:	97 81       	ldd	r25, Z+7	; 0x07
    20c0:	9a 83       	std	Y+2, r25	; 0x02
    20c2:	89 83       	std	Y+1, r24	; 0x01
			vListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    20c4:	89 81       	ldd	r24, Y+1	; 0x01
    20c6:	9a 81       	ldd	r25, Y+2	; 0x02
    20c8:	0c 96       	adiw	r24, 0x0c	; 12
    20ca:	0e 94 94 13 	call	0x2728	; 0x2728 <vListRemove>
		}
		portENABLE_INTERRUPTS();
    20ce:	78 94       	sei

		vListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
    20d0:	89 81       	ldd	r24, Y+1	; 0x01
    20d2:	9a 81       	ldd	r25, Y+2	; 0x02
    20d4:	02 96       	adiw	r24, 0x02	; 2
    20d6:	0e 94 94 13 	call	0x2728	; 0x2728 <vListRemove>
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );	
    20da:	e9 81       	ldd	r30, Y+1	; 0x01
    20dc:	fa 81       	ldd	r31, Y+2	; 0x02
    20de:	96 89       	ldd	r25, Z+22	; 0x16
    20e0:	80 91 7c 00 	lds	r24, 0x007C
    20e4:	89 17       	cp	r24, r25
    20e6:	28 f4       	brcc	.+10     	; 0x20f2 <prvCheckPendingReadyList+0x4c>
    20e8:	e9 81       	ldd	r30, Y+1	; 0x01
    20ea:	fa 81       	ldd	r31, Y+2	; 0x02
    20ec:	86 89       	ldd	r24, Z+22	; 0x16
    20ee:	80 93 7c 00 	sts	0x007C, r24
    20f2:	e9 81       	ldd	r30, Y+1	; 0x01
    20f4:	fa 81       	ldd	r31, Y+2	; 0x02
    20f6:	86 89       	ldd	r24, Z+22	; 0x16
    20f8:	28 2f       	mov	r18, r24
    20fa:	30 e0       	ldi	r19, 0x00	; 0
    20fc:	c9 01       	movw	r24, r18
    20fe:	88 0f       	add	r24, r24
    2100:	99 1f       	adc	r25, r25
    2102:	88 0f       	add	r24, r24
    2104:	99 1f       	adc	r25, r25
    2106:	88 0f       	add	r24, r24
    2108:	99 1f       	adc	r25, r25
    210a:	82 0f       	add	r24, r18
    210c:	93 1f       	adc	r25, r19
    210e:	ac 01       	movw	r20, r24
    2110:	4d 57       	subi	r20, 0x7D	; 125
    2112:	5f 4f       	sbci	r21, 0xFF	; 255
    2114:	89 81       	ldd	r24, Y+1	; 0x01
    2116:	9a 81       	ldd	r25, Y+2	; 0x02
    2118:	9c 01       	movw	r18, r24
    211a:	2e 5f       	subi	r18, 0xFE	; 254
    211c:	3f 4f       	sbci	r19, 0xFF	; 255
    211e:	ca 01       	movw	r24, r20
    2120:	b9 01       	movw	r22, r18
    2122:	0e 94 dc 12 	call	0x25b8	; 0x25b8 <vListInsertEnd>
static void prvCheckPendingReadyList( void )
{
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
    2126:	80 91 ab 00 	lds	r24, 0x00AB
    212a:	88 23       	and	r24, r24
    212c:	09 f0       	breq	.+2      	; 0x2130 <prvCheckPendingReadyList+0x8a>
    212e:	c1 cf       	rjmp	.-126    	; 0x20b2 <prvCheckPendingReadyList+0xc>
		portENABLE_INTERRUPTS();

		vListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );	
	}
}
    2130:	0f 90       	pop	r0
    2132:	0f 90       	pop	r0
    2134:	cf 91       	pop	r28
    2136:	df 91       	pop	r29
    2138:	08 95       	ret

0000213a <prvCheckDelayedList>:
/*-----------------------------------------------------------*/

static void prvCheckDelayedList( void )
{
    213a:	df 93       	push	r29
    213c:	cf 93       	push	r28
    213e:	00 d0       	rcall	.+0      	; 0x2140 <prvCheckDelayedList+0x6>
    2140:	00 d0       	rcall	.+0      	; 0x2142 <prvCheckDelayedList+0x8>
    2142:	cd b7       	in	r28, 0x3d	; 61
    2144:	de b7       	in	r29, 0x3e	; 62
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
    2146:	0e 94 02 1e 	call	0x3c04	; 0x3c04 <xTaskGetTickCount>
    214a:	20 91 7f 00 	lds	r18, 0x007F
    214e:	30 91 80 00 	lds	r19, 0x0080
    2152:	82 1b       	sub	r24, r18
    2154:	93 0b       	sbc	r25, r19
    2156:	90 93 82 00 	sts	0x0082, r25
    215a:	80 93 81 00 	sts	0x0081, r24
    215e:	85 c0       	rjmp	.+266    	; 0x226a <prvCheckDelayedList+0x130>
	while( xPassedTicks )
	{
		xCoRoutineTickCount++;
    2160:	80 91 7d 00 	lds	r24, 0x007D
    2164:	90 91 7e 00 	lds	r25, 0x007E
    2168:	01 96       	adiw	r24, 0x01	; 1
    216a:	90 93 7e 00 	sts	0x007E, r25
    216e:	80 93 7d 00 	sts	0x007D, r24
		xPassedTicks--;
    2172:	80 91 81 00 	lds	r24, 0x0081
    2176:	90 91 82 00 	lds	r25, 0x0082
    217a:	01 97       	sbiw	r24, 0x01	; 1
    217c:	90 93 82 00 	sts	0x0082, r25
    2180:	80 93 81 00 	sts	0x0081, r24

		/* If the tick count has overflowed we need to swap the ready lists. */
		if( xCoRoutineTickCount == 0 )
    2184:	80 91 7d 00 	lds	r24, 0x007D
    2188:	90 91 7e 00 	lds	r25, 0x007E
    218c:	00 97       	sbiw	r24, 0x00	; 0
    218e:	09 f0       	breq	.+2      	; 0x2192 <prvCheckDelayedList+0x58>
    2190:	64 c0       	rjmp	.+200    	; 0x225a <prvCheckDelayedList+0x120>
		{
			xList * pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.  If there are
			any items in pxDelayedCoRoutineList here then there is an error! */
			pxTemp = pxDelayedCoRoutineList;
    2192:	80 91 a7 00 	lds	r24, 0x00A7
    2196:	90 91 a8 00 	lds	r25, 0x00A8
    219a:	9a 83       	std	Y+2, r25	; 0x02
    219c:	89 83       	std	Y+1, r24	; 0x01
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
    219e:	80 91 a9 00 	lds	r24, 0x00A9
    21a2:	90 91 aa 00 	lds	r25, 0x00AA
    21a6:	90 93 a8 00 	sts	0x00A8, r25
    21aa:	80 93 a7 00 	sts	0x00A7, r24
			pxOverflowDelayedCoRoutineList = pxTemp;
    21ae:	89 81       	ldd	r24, Y+1	; 0x01
    21b0:	9a 81       	ldd	r25, Y+2	; 0x02
    21b2:	90 93 aa 00 	sts	0x00AA, r25
    21b6:	80 93 a9 00 	sts	0x00A9, r24
    21ba:	4f c0       	rjmp	.+158    	; 0x225a <prvCheckDelayedList+0x120>
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
		{
			pxCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList );
    21bc:	e0 91 a7 00 	lds	r30, 0x00A7
    21c0:	f0 91 a8 00 	lds	r31, 0x00A8
    21c4:	05 80       	ldd	r0, Z+5	; 0x05
    21c6:	f6 81       	ldd	r31, Z+6	; 0x06
    21c8:	e0 2d       	mov	r30, r0
    21ca:	86 81       	ldd	r24, Z+6	; 0x06
    21cc:	97 81       	ldd	r25, Z+7	; 0x07
    21ce:	9c 83       	std	Y+4, r25	; 0x04
    21d0:	8b 83       	std	Y+3, r24	; 0x03

			if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )				
    21d2:	eb 81       	ldd	r30, Y+3	; 0x03
    21d4:	fc 81       	ldd	r31, Y+4	; 0x04
    21d6:	22 81       	ldd	r18, Z+2	; 0x02
    21d8:	33 81       	ldd	r19, Z+3	; 0x03
    21da:	80 91 7d 00 	lds	r24, 0x007D
    21de:	90 91 7e 00 	lds	r25, 0x007E
    21e2:	82 17       	cp	r24, r18
    21e4:	93 07       	cpc	r25, r19
    21e6:	08 f4       	brcc	.+2      	; 0x21ea <prvCheckDelayedList+0xb0>
    21e8:	40 c0       	rjmp	.+128    	; 0x226a <prvCheckDelayedList+0x130>
			{			
				/* Timeout not yet expired. */																			
				break;																				
			}																						

			portDISABLE_INTERRUPTS();
    21ea:	f8 94       	cli
				/* The event could have occurred just before this critical
				section.  If this is the case then the generic list item will
				have been moved to the pending ready list and the following
				line is still valid.  Also the pvContainer parameter will have
				been set to NULL so the following lines are also valid. */
				vListRemove( &( pxCRCB->xGenericListItem ) );											
    21ec:	8b 81       	ldd	r24, Y+3	; 0x03
    21ee:	9c 81       	ldd	r25, Y+4	; 0x04
    21f0:	02 96       	adiw	r24, 0x02	; 2
    21f2:	0e 94 94 13 	call	0x2728	; 0x2728 <vListRemove>

				/* Is the co-routine waiting on an event also? */												
				if( pxCRCB->xEventListItem.pvContainer )													
    21f6:	eb 81       	ldd	r30, Y+3	; 0x03
    21f8:	fc 81       	ldd	r31, Y+4	; 0x04
    21fa:	84 89       	ldd	r24, Z+20	; 0x14
    21fc:	95 89       	ldd	r25, Z+21	; 0x15
    21fe:	00 97       	sbiw	r24, 0x00	; 0
    2200:	29 f0       	breq	.+10     	; 0x220c <prvCheckDelayedList+0xd2>
				{															
					vListRemove( &( pxCRCB->xEventListItem ) );											
    2202:	8b 81       	ldd	r24, Y+3	; 0x03
    2204:	9c 81       	ldd	r25, Y+4	; 0x04
    2206:	0c 96       	adiw	r24, 0x0c	; 12
    2208:	0e 94 94 13 	call	0x2728	; 0x2728 <vListRemove>
				}
			}
			portENABLE_INTERRUPTS();
    220c:	78 94       	sei

			prvAddCoRoutineToReadyQueue( pxCRCB );													
    220e:	eb 81       	ldd	r30, Y+3	; 0x03
    2210:	fc 81       	ldd	r31, Y+4	; 0x04
    2212:	96 89       	ldd	r25, Z+22	; 0x16
    2214:	80 91 7c 00 	lds	r24, 0x007C
    2218:	89 17       	cp	r24, r25
    221a:	28 f4       	brcc	.+10     	; 0x2226 <prvCheckDelayedList+0xec>
    221c:	eb 81       	ldd	r30, Y+3	; 0x03
    221e:	fc 81       	ldd	r31, Y+4	; 0x04
    2220:	86 89       	ldd	r24, Z+22	; 0x16
    2222:	80 93 7c 00 	sts	0x007C, r24
    2226:	eb 81       	ldd	r30, Y+3	; 0x03
    2228:	fc 81       	ldd	r31, Y+4	; 0x04
    222a:	86 89       	ldd	r24, Z+22	; 0x16
    222c:	28 2f       	mov	r18, r24
    222e:	30 e0       	ldi	r19, 0x00	; 0
    2230:	c9 01       	movw	r24, r18
    2232:	88 0f       	add	r24, r24
    2234:	99 1f       	adc	r25, r25
    2236:	88 0f       	add	r24, r24
    2238:	99 1f       	adc	r25, r25
    223a:	88 0f       	add	r24, r24
    223c:	99 1f       	adc	r25, r25
    223e:	82 0f       	add	r24, r18
    2240:	93 1f       	adc	r25, r19
    2242:	ac 01       	movw	r20, r24
    2244:	4d 57       	subi	r20, 0x7D	; 125
    2246:	5f 4f       	sbci	r21, 0xFF	; 255
    2248:	8b 81       	ldd	r24, Y+3	; 0x03
    224a:	9c 81       	ldd	r25, Y+4	; 0x04
    224c:	9c 01       	movw	r18, r24
    224e:	2e 5f       	subi	r18, 0xFE	; 254
    2250:	3f 4f       	sbci	r19, 0xFF	; 255
    2252:	ca 01       	movw	r24, r20
    2254:	b9 01       	movw	r22, r18
    2256:	0e 94 dc 12 	call	0x25b8	; 0x25b8 <vListInsertEnd>
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
			pxOverflowDelayedCoRoutineList = pxTemp;
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
    225a:	e0 91 a7 00 	lds	r30, 0x00A7
    225e:	f0 91 a8 00 	lds	r31, 0x00A8
    2262:	80 81       	ld	r24, Z
    2264:	88 23       	and	r24, r24
    2266:	09 f0       	breq	.+2      	; 0x226a <prvCheckDelayedList+0x130>
    2268:	a9 cf       	rjmp	.-174    	; 0x21bc <prvCheckDelayedList+0x82>
static void prvCheckDelayedList( void )
{
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
	while( xPassedTicks )
    226a:	80 91 81 00 	lds	r24, 0x0081
    226e:	90 91 82 00 	lds	r25, 0x0082
    2272:	00 97       	sbiw	r24, 0x00	; 0
    2274:	09 f0       	breq	.+2      	; 0x2278 <prvCheckDelayedList+0x13e>
    2276:	74 cf       	rjmp	.-280    	; 0x2160 <prvCheckDelayedList+0x26>

			prvAddCoRoutineToReadyQueue( pxCRCB );													
		}																									
	}

	xLastTickCount = xCoRoutineTickCount;
    2278:	80 91 7d 00 	lds	r24, 0x007D
    227c:	90 91 7e 00 	lds	r25, 0x007E
    2280:	90 93 80 00 	sts	0x0080, r25
    2284:	80 93 7f 00 	sts	0x007F, r24
}
    2288:	0f 90       	pop	r0
    228a:	0f 90       	pop	r0
    228c:	0f 90       	pop	r0
    228e:	0f 90       	pop	r0
    2290:	cf 91       	pop	r28
    2292:	df 91       	pop	r29
    2294:	08 95       	ret

00002296 <vCoRoutineSchedule>:
/*-----------------------------------------------------------*/

void vCoRoutineSchedule( void )
{
    2296:	df 93       	push	r29
    2298:	cf 93       	push	r28
    229a:	00 d0       	rcall	.+0      	; 0x229c <vCoRoutineSchedule+0x6>
    229c:	cd b7       	in	r28, 0x3d	; 61
    229e:	de b7       	in	r29, 0x3e	; 62
	/* See if any co-routines readied by events need moving to the ready lists. */
	prvCheckPendingReadyList();
    22a0:	0e 94 53 10 	call	0x20a6	; 0x20a6 <prvCheckPendingReadyList>

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();
    22a4:	0e 94 9d 10 	call	0x213a	; 0x213a <prvCheckDelayedList>
    22a8:	0a c0       	rjmp	.+20     	; 0x22be <vCoRoutineSchedule+0x28>

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
	{
		if( uxTopCoRoutineReadyPriority == 0 )
    22aa:	80 91 7c 00 	lds	r24, 0x007C
    22ae:	88 23       	and	r24, r24
    22b0:	09 f4       	brne	.+2      	; 0x22b4 <vCoRoutineSchedule+0x1e>
    22b2:	66 c0       	rjmp	.+204    	; 0x2380 <vCoRoutineSchedule+0xea>
		{
			/* No more co-routines to check. */
			return;
		}
		--uxTopCoRoutineReadyPriority;
    22b4:	80 91 7c 00 	lds	r24, 0x007C
    22b8:	81 50       	subi	r24, 0x01	; 1
    22ba:	80 93 7c 00 	sts	0x007C, r24

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
    22be:	80 91 7c 00 	lds	r24, 0x007C
    22c2:	28 2f       	mov	r18, r24
    22c4:	30 e0       	ldi	r19, 0x00	; 0
    22c6:	c9 01       	movw	r24, r18
    22c8:	88 0f       	add	r24, r24
    22ca:	99 1f       	adc	r25, r25
    22cc:	88 0f       	add	r24, r24
    22ce:	99 1f       	adc	r25, r25
    22d0:	88 0f       	add	r24, r24
    22d2:	99 1f       	adc	r25, r25
    22d4:	82 0f       	add	r24, r18
    22d6:	93 1f       	adc	r25, r19
    22d8:	fc 01       	movw	r30, r24
    22da:	ed 57       	subi	r30, 0x7D	; 125
    22dc:	ff 4f       	sbci	r31, 0xFF	; 255
    22de:	80 81       	ld	r24, Z
    22e0:	88 23       	and	r24, r24
    22e2:	19 f3       	breq	.-58     	; 0x22aa <vCoRoutineSchedule+0x14>
		--uxTopCoRoutineReadyPriority;
	}

	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
	 of the	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );
    22e4:	80 91 7c 00 	lds	r24, 0x007C
    22e8:	28 2f       	mov	r18, r24
    22ea:	30 e0       	ldi	r19, 0x00	; 0
    22ec:	c9 01       	movw	r24, r18
    22ee:	88 0f       	add	r24, r24
    22f0:	99 1f       	adc	r25, r25
    22f2:	88 0f       	add	r24, r24
    22f4:	99 1f       	adc	r25, r25
    22f6:	88 0f       	add	r24, r24
    22f8:	99 1f       	adc	r25, r25
    22fa:	82 0f       	add	r24, r18
    22fc:	93 1f       	adc	r25, r19
    22fe:	8d 57       	subi	r24, 0x7D	; 125
    2300:	9f 4f       	sbci	r25, 0xFF	; 255
    2302:	9a 83       	std	Y+2, r25	; 0x02
    2304:	89 83       	std	Y+1, r24	; 0x01
    2306:	e9 81       	ldd	r30, Y+1	; 0x01
    2308:	fa 81       	ldd	r31, Y+2	; 0x02
    230a:	01 80       	ldd	r0, Z+1	; 0x01
    230c:	f2 81       	ldd	r31, Z+2	; 0x02
    230e:	e0 2d       	mov	r30, r0
    2310:	82 81       	ldd	r24, Z+2	; 0x02
    2312:	93 81       	ldd	r25, Z+3	; 0x03
    2314:	e9 81       	ldd	r30, Y+1	; 0x01
    2316:	fa 81       	ldd	r31, Y+2	; 0x02
    2318:	92 83       	std	Z+2, r25	; 0x02
    231a:	81 83       	std	Z+1, r24	; 0x01
    231c:	e9 81       	ldd	r30, Y+1	; 0x01
    231e:	fa 81       	ldd	r31, Y+2	; 0x02
    2320:	21 81       	ldd	r18, Z+1	; 0x01
    2322:	32 81       	ldd	r19, Z+2	; 0x02
    2324:	89 81       	ldd	r24, Y+1	; 0x01
    2326:	9a 81       	ldd	r25, Y+2	; 0x02
    2328:	03 96       	adiw	r24, 0x03	; 3
    232a:	28 17       	cp	r18, r24
    232c:	39 07       	cpc	r19, r25
    232e:	59 f4       	brne	.+22     	; 0x2346 <vCoRoutineSchedule+0xb0>
    2330:	e9 81       	ldd	r30, Y+1	; 0x01
    2332:	fa 81       	ldd	r31, Y+2	; 0x02
    2334:	01 80       	ldd	r0, Z+1	; 0x01
    2336:	f2 81       	ldd	r31, Z+2	; 0x02
    2338:	e0 2d       	mov	r30, r0
    233a:	82 81       	ldd	r24, Z+2	; 0x02
    233c:	93 81       	ldd	r25, Z+3	; 0x03
    233e:	e9 81       	ldd	r30, Y+1	; 0x01
    2340:	fa 81       	ldd	r31, Y+2	; 0x02
    2342:	92 83       	std	Z+2, r25	; 0x02
    2344:	81 83       	std	Z+1, r24	; 0x01
    2346:	e9 81       	ldd	r30, Y+1	; 0x01
    2348:	fa 81       	ldd	r31, Y+2	; 0x02
    234a:	01 80       	ldd	r0, Z+1	; 0x01
    234c:	f2 81       	ldd	r31, Z+2	; 0x02
    234e:	e0 2d       	mov	r30, r0
    2350:	86 81       	ldd	r24, Z+6	; 0x06
    2352:	97 81       	ldd	r25, Z+7	; 0x07
    2354:	90 93 7b 00 	sts	0x007B, r25
    2358:	80 93 7a 00 	sts	0x007A, r24

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
    235c:	e0 91 7a 00 	lds	r30, 0x007A
    2360:	f0 91 7b 00 	lds	r31, 0x007B
    2364:	40 81       	ld	r20, Z
    2366:	51 81       	ldd	r21, Z+1	; 0x01
    2368:	80 91 7a 00 	lds	r24, 0x007A
    236c:	90 91 7b 00 	lds	r25, 0x007B
    2370:	e0 91 7a 00 	lds	r30, 0x007A
    2374:	f0 91 7b 00 	lds	r31, 0x007B
    2378:	27 89       	ldd	r18, Z+23	; 0x17
    237a:	62 2f       	mov	r22, r18
    237c:	fa 01       	movw	r30, r20
    237e:	09 95       	icall

	return;
}
    2380:	0f 90       	pop	r0
    2382:	0f 90       	pop	r0
    2384:	cf 91       	pop	r28
    2386:	df 91       	pop	r29
    2388:	08 95       	ret

0000238a <prvInitialiseCoRoutineLists>:
/*-----------------------------------------------------------*/

static void prvInitialiseCoRoutineLists( void )
{
    238a:	df 93       	push	r29
    238c:	cf 93       	push	r28
    238e:	0f 92       	push	r0
    2390:	cd b7       	in	r28, 0x3d	; 61
    2392:	de b7       	in	r29, 0x3e	; 62
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
    2394:	19 82       	std	Y+1, r1	; 0x01
    2396:	13 c0       	rjmp	.+38     	; 0x23be <prvInitialiseCoRoutineLists+0x34>
	{
		vListInitialise( ( xList * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
    2398:	89 81       	ldd	r24, Y+1	; 0x01
    239a:	28 2f       	mov	r18, r24
    239c:	30 e0       	ldi	r19, 0x00	; 0
    239e:	c9 01       	movw	r24, r18
    23a0:	88 0f       	add	r24, r24
    23a2:	99 1f       	adc	r25, r25
    23a4:	88 0f       	add	r24, r24
    23a6:	99 1f       	adc	r25, r25
    23a8:	88 0f       	add	r24, r24
    23aa:	99 1f       	adc	r25, r25
    23ac:	82 0f       	add	r24, r18
    23ae:	93 1f       	adc	r25, r19
    23b0:	8d 57       	subi	r24, 0x7D	; 125
    23b2:	9f 4f       	sbci	r25, 0xFF	; 255
    23b4:	0e 94 a2 12 	call	0x2544	; 0x2544 <vListInitialise>

static void prvInitialiseCoRoutineLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
    23b8:	89 81       	ldd	r24, Y+1	; 0x01
    23ba:	8f 5f       	subi	r24, 0xFF	; 255
    23bc:	89 83       	std	Y+1, r24	; 0x01
    23be:	89 81       	ldd	r24, Y+1	; 0x01
    23c0:	82 30       	cpi	r24, 0x02	; 2
    23c2:	50 f3       	brcs	.-44     	; 0x2398 <prvInitialiseCoRoutineLists+0xe>
	{
		vListInitialise( ( xList * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedCoRoutineList1 );
    23c4:	85 e9       	ldi	r24, 0x95	; 149
    23c6:	90 e0       	ldi	r25, 0x00	; 0
    23c8:	0e 94 a2 12 	call	0x2544	; 0x2544 <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedCoRoutineList2 );
    23cc:	8e e9       	ldi	r24, 0x9E	; 158
    23ce:	90 e0       	ldi	r25, 0x00	; 0
    23d0:	0e 94 a2 12 	call	0x2544	; 0x2544 <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyCoRoutineList );
    23d4:	8b ea       	ldi	r24, 0xAB	; 171
    23d6:	90 e0       	ldi	r25, 0x00	; 0
    23d8:	0e 94 a2 12 	call	0x2544	; 0x2544 <vListInitialise>

	/* Start with pxDelayedCoRoutineList using list1 and the
	pxOverflowDelayedCoRoutineList using list2. */
	pxDelayedCoRoutineList = &xDelayedCoRoutineList1;
    23dc:	85 e9       	ldi	r24, 0x95	; 149
    23de:	90 e0       	ldi	r25, 0x00	; 0
    23e0:	90 93 a8 00 	sts	0x00A8, r25
    23e4:	80 93 a7 00 	sts	0x00A7, r24
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
    23e8:	8e e9       	ldi	r24, 0x9E	; 158
    23ea:	90 e0       	ldi	r25, 0x00	; 0
    23ec:	90 93 aa 00 	sts	0x00AA, r25
    23f0:	80 93 a9 00 	sts	0x00A9, r24
}
    23f4:	0f 90       	pop	r0
    23f6:	cf 91       	pop	r28
    23f8:	df 91       	pop	r29
    23fa:	08 95       	ret

000023fc <xCoRoutineRemoveFromEventList>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineRemoveFromEventList( const xList *pxEventList )
{
    23fc:	df 93       	push	r29
    23fe:	cf 93       	push	r28
    2400:	00 d0       	rcall	.+0      	; 0x2402 <xCoRoutineRemoveFromEventList+0x6>
    2402:	00 d0       	rcall	.+0      	; 0x2404 <xCoRoutineRemoveFromEventList+0x8>
    2404:	0f 92       	push	r0
    2406:	cd b7       	in	r28, 0x3d	; 61
    2408:	de b7       	in	r29, 0x3e	; 62
    240a:	9d 83       	std	Y+5, r25	; 0x05
    240c:	8c 83       	std	Y+4, r24	; 0x04
signed portBASE_TYPE xReturn;

	/* This function is called from within an interrupt.  It can only access
	event lists and the pending ready list.  This function assumes that a
	check has already been made to ensure pxEventList is not empty. */
	pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    240e:	ec 81       	ldd	r30, Y+4	; 0x04
    2410:	fd 81       	ldd	r31, Y+5	; 0x05
    2412:	05 80       	ldd	r0, Z+5	; 0x05
    2414:	f6 81       	ldd	r31, Z+6	; 0x06
    2416:	e0 2d       	mov	r30, r0
    2418:	86 81       	ldd	r24, Z+6	; 0x06
    241a:	97 81       	ldd	r25, Z+7	; 0x07
    241c:	9b 83       	std	Y+3, r25	; 0x03
    241e:	8a 83       	std	Y+2, r24	; 0x02
	vListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    2420:	8a 81       	ldd	r24, Y+2	; 0x02
    2422:	9b 81       	ldd	r25, Y+3	; 0x03
    2424:	0c 96       	adiw	r24, 0x0c	; 12
    2426:	0e 94 94 13 	call	0x2728	; 0x2728 <vListRemove>
	vListInsertEnd( ( xList * ) &( xPendingReadyCoRoutineList ), &( pxUnblockedCRCB->xEventListItem ) );
    242a:	8a 81       	ldd	r24, Y+2	; 0x02
    242c:	9b 81       	ldd	r25, Y+3	; 0x03
    242e:	9c 01       	movw	r18, r24
    2430:	24 5f       	subi	r18, 0xF4	; 244
    2432:	3f 4f       	sbci	r19, 0xFF	; 255
    2434:	8b ea       	ldi	r24, 0xAB	; 171
    2436:	90 e0       	ldi	r25, 0x00	; 0
    2438:	b9 01       	movw	r22, r18
    243a:	0e 94 dc 12 	call	0x25b8	; 0x25b8 <vListInsertEnd>

	if( pxUnblockedCRCB->uxPriority >= pxCurrentCoRoutine->uxPriority )
    243e:	ea 81       	ldd	r30, Y+2	; 0x02
    2440:	fb 81       	ldd	r31, Y+3	; 0x03
    2442:	96 89       	ldd	r25, Z+22	; 0x16
    2444:	e0 91 7a 00 	lds	r30, 0x007A
    2448:	f0 91 7b 00 	lds	r31, 0x007B
    244c:	86 89       	ldd	r24, Z+22	; 0x16
    244e:	98 17       	cp	r25, r24
    2450:	18 f0       	brcs	.+6      	; 0x2458 <xCoRoutineRemoveFromEventList+0x5c>
	{
		xReturn = pdTRUE;
    2452:	81 e0       	ldi	r24, 0x01	; 1
    2454:	89 83       	std	Y+1, r24	; 0x01
    2456:	01 c0       	rjmp	.+2      	; 0x245a <xCoRoutineRemoveFromEventList+0x5e>
	}
	else
	{
		xReturn = pdFALSE;
    2458:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    245a:	89 81       	ldd	r24, Y+1	; 0x01
}
    245c:	0f 90       	pop	r0
    245e:	0f 90       	pop	r0
    2460:	0f 90       	pop	r0
    2462:	0f 90       	pop	r0
    2464:	0f 90       	pop	r0
    2466:	cf 91       	pop	r28
    2468:	df 91       	pop	r29
    246a:	08 95       	ret

0000246c <pvPortMalloc>:

static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    246c:	df 93       	push	r29
    246e:	cf 93       	push	r28
    2470:	00 d0       	rcall	.+0      	; 0x2472 <pvPortMalloc+0x6>
    2472:	00 d0       	rcall	.+0      	; 0x2474 <pvPortMalloc+0x8>
    2474:	cd b7       	in	r28, 0x3d	; 61
    2476:	de b7       	in	r29, 0x3e	; 62
    2478:	9c 83       	std	Y+4, r25	; 0x04
    247a:	8b 83       	std	Y+3, r24	; 0x03
void *pvReturn = NULL; 
    247c:	1a 82       	std	Y+2, r1	; 0x02
    247e:	19 82       	std	Y+1, r1	; 0x01
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
    2480:	0e 94 6c 1d 	call	0x3ad8	; 0x3ad8 <vTaskSuspendAll>
	{
		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configTOTAL_HEAP_SIZE ) &&
    2484:	80 91 b4 00 	lds	r24, 0x00B4
    2488:	90 91 b5 00 	lds	r25, 0x00B5
    248c:	2b 81       	ldd	r18, Y+3	; 0x03
    248e:	3c 81       	ldd	r19, Y+4	; 0x04
    2490:	82 0f       	add	r24, r18
    2492:	93 1f       	adc	r25, r19
    2494:	25 e0       	ldi	r18, 0x05	; 5
    2496:	8c 3d       	cpi	r24, 0xDC	; 220
    2498:	92 07       	cpc	r25, r18
    249a:	18 f5       	brcc	.+70     	; 0x24e2 <pvPortMalloc+0x76>
    249c:	20 91 b4 00 	lds	r18, 0x00B4
    24a0:	30 91 b5 00 	lds	r19, 0x00B5
    24a4:	8b 81       	ldd	r24, Y+3	; 0x03
    24a6:	9c 81       	ldd	r25, Y+4	; 0x04
    24a8:	28 0f       	add	r18, r24
    24aa:	39 1f       	adc	r19, r25
    24ac:	80 91 b4 00 	lds	r24, 0x00B4
    24b0:	90 91 b5 00 	lds	r25, 0x00B5
    24b4:	82 17       	cp	r24, r18
    24b6:	93 07       	cpc	r25, r19
    24b8:	a0 f4       	brcc	.+40     	; 0x24e2 <pvPortMalloc+0x76>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
    24ba:	80 91 b4 00 	lds	r24, 0x00B4
    24be:	90 91 b5 00 	lds	r25, 0x00B5
    24c2:	8a 54       	subi	r24, 0x4A	; 74
    24c4:	9f 4f       	sbci	r25, 0xFF	; 255
    24c6:	9a 83       	std	Y+2, r25	; 0x02
    24c8:	89 83       	std	Y+1, r24	; 0x01
			xNextFreeByte += xWantedSize;			
    24ca:	20 91 b4 00 	lds	r18, 0x00B4
    24ce:	30 91 b5 00 	lds	r19, 0x00B5
    24d2:	8b 81       	ldd	r24, Y+3	; 0x03
    24d4:	9c 81       	ldd	r25, Y+4	; 0x04
    24d6:	82 0f       	add	r24, r18
    24d8:	93 1f       	adc	r25, r19
    24da:	90 93 b5 00 	sts	0x00B5, r25
    24de:	80 93 b4 00 	sts	0x00B4, r24
		}	
	}
	xTaskResumeAll();
    24e2:	0e 94 78 1d 	call	0x3af0	; 0x3af0 <xTaskResumeAll>
			vApplicationMallocFailedHook();
		}
	}
	#endif	

	return pvReturn;
    24e6:	89 81       	ldd	r24, Y+1	; 0x01
    24e8:	9a 81       	ldd	r25, Y+2	; 0x02
}
    24ea:	0f 90       	pop	r0
    24ec:	0f 90       	pop	r0
    24ee:	0f 90       	pop	r0
    24f0:	0f 90       	pop	r0
    24f2:	cf 91       	pop	r28
    24f4:	df 91       	pop	r29
    24f6:	08 95       	ret

000024f8 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    24f8:	df 93       	push	r29
    24fa:	cf 93       	push	r28
    24fc:	00 d0       	rcall	.+0      	; 0x24fe <vPortFree+0x6>
    24fe:	cd b7       	in	r28, 0x3d	; 61
    2500:	de b7       	in	r29, 0x3e	; 62
    2502:	9a 83       	std	Y+2, r25	; 0x02
    2504:	89 83       	std	Y+1, r24	; 0x01
	/* Memory cannot be freed using this scheme.  See heap_2.c and heap_3.c 
	for alternative implementations, and the memory management pages of 
	http://www.FreeRTOS.org for more information. */
	( void ) pv;
}
    2506:	0f 90       	pop	r0
    2508:	0f 90       	pop	r0
    250a:	cf 91       	pop	r28
    250c:	df 91       	pop	r29
    250e:	08 95       	ret

00002510 <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
    2510:	df 93       	push	r29
    2512:	cf 93       	push	r28
    2514:	cd b7       	in	r28, 0x3d	; 61
    2516:	de b7       	in	r29, 0x3e	; 62
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
    2518:	10 92 b5 00 	sts	0x00B5, r1
    251c:	10 92 b4 00 	sts	0x00B4, r1
}
    2520:	cf 91       	pop	r28
    2522:	df 91       	pop	r29
    2524:	08 95       	ret

00002526 <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
    2526:	df 93       	push	r29
    2528:	cf 93       	push	r28
    252a:	cd b7       	in	r28, 0x3d	; 61
    252c:	de b7       	in	r29, 0x3e	; 62
	return ( configTOTAL_HEAP_SIZE - xNextFreeByte );
    252e:	20 91 b4 00 	lds	r18, 0x00B4
    2532:	30 91 b5 00 	lds	r19, 0x00B5
    2536:	8c ed       	ldi	r24, 0xDC	; 220
    2538:	95 e0       	ldi	r25, 0x05	; 5
    253a:	82 1b       	sub	r24, r18
    253c:	93 0b       	sbc	r25, r19
}
    253e:	cf 91       	pop	r28
    2540:	df 91       	pop	r29
    2542:	08 95       	ret

00002544 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
    2544:	df 93       	push	r29
    2546:	cf 93       	push	r28
    2548:	00 d0       	rcall	.+0      	; 0x254a <vListInitialise+0x6>
    254a:	cd b7       	in	r28, 0x3d	; 61
    254c:	de b7       	in	r29, 0x3e	; 62
    254e:	9a 83       	std	Y+2, r25	; 0x02
    2550:	89 83       	std	Y+1, r24	; 0x01
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
    2552:	89 81       	ldd	r24, Y+1	; 0x01
    2554:	9a 81       	ldd	r25, Y+2	; 0x02
    2556:	03 96       	adiw	r24, 0x03	; 3
    2558:	e9 81       	ldd	r30, Y+1	; 0x01
    255a:	fa 81       	ldd	r31, Y+2	; 0x02
    255c:	92 83       	std	Z+2, r25	; 0x02
    255e:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    2560:	e9 81       	ldd	r30, Y+1	; 0x01
    2562:	fa 81       	ldd	r31, Y+2	; 0x02
    2564:	8f ef       	ldi	r24, 0xFF	; 255
    2566:	9f ef       	ldi	r25, 0xFF	; 255
    2568:	94 83       	std	Z+4, r25	; 0x04
    256a:	83 83       	std	Z+3, r24	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
    256c:	89 81       	ldd	r24, Y+1	; 0x01
    256e:	9a 81       	ldd	r25, Y+2	; 0x02
    2570:	03 96       	adiw	r24, 0x03	; 3
    2572:	e9 81       	ldd	r30, Y+1	; 0x01
    2574:	fa 81       	ldd	r31, Y+2	; 0x02
    2576:	96 83       	std	Z+6, r25	; 0x06
    2578:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
    257a:	89 81       	ldd	r24, Y+1	; 0x01
    257c:	9a 81       	ldd	r25, Y+2	; 0x02
    257e:	03 96       	adiw	r24, 0x03	; 3
    2580:	e9 81       	ldd	r30, Y+1	; 0x01
    2582:	fa 81       	ldd	r31, Y+2	; 0x02
    2584:	90 87       	std	Z+8, r25	; 0x08
    2586:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
    2588:	e9 81       	ldd	r30, Y+1	; 0x01
    258a:	fa 81       	ldd	r31, Y+2	; 0x02
    258c:	10 82       	st	Z, r1
}
    258e:	0f 90       	pop	r0
    2590:	0f 90       	pop	r0
    2592:	cf 91       	pop	r28
    2594:	df 91       	pop	r29
    2596:	08 95       	ret

00002598 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
    2598:	df 93       	push	r29
    259a:	cf 93       	push	r28
    259c:	00 d0       	rcall	.+0      	; 0x259e <vListInitialiseItem+0x6>
    259e:	cd b7       	in	r28, 0x3d	; 61
    25a0:	de b7       	in	r29, 0x3e	; 62
    25a2:	9a 83       	std	Y+2, r25	; 0x02
    25a4:	89 83       	std	Y+1, r24	; 0x01
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    25a6:	e9 81       	ldd	r30, Y+1	; 0x01
    25a8:	fa 81       	ldd	r31, Y+2	; 0x02
    25aa:	11 86       	std	Z+9, r1	; 0x09
    25ac:	10 86       	std	Z+8, r1	; 0x08
}
    25ae:	0f 90       	pop	r0
    25b0:	0f 90       	pop	r0
    25b2:	cf 91       	pop	r28
    25b4:	df 91       	pop	r29
    25b6:	08 95       	ret

000025b8 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
    25b8:	df 93       	push	r29
    25ba:	cf 93       	push	r28
    25bc:	00 d0       	rcall	.+0      	; 0x25be <vListInsertEnd+0x6>
    25be:	00 d0       	rcall	.+0      	; 0x25c0 <vListInsertEnd+0x8>
    25c0:	00 d0       	rcall	.+0      	; 0x25c2 <vListInsertEnd+0xa>
    25c2:	cd b7       	in	r28, 0x3d	; 61
    25c4:	de b7       	in	r29, 0x3e	; 62
    25c6:	9c 83       	std	Y+4, r25	; 0x04
    25c8:	8b 83       	std	Y+3, r24	; 0x03
    25ca:	7e 83       	std	Y+6, r23	; 0x06
    25cc:	6d 83       	std	Y+5, r22	; 0x05

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
    25ce:	eb 81       	ldd	r30, Y+3	; 0x03
    25d0:	fc 81       	ldd	r31, Y+4	; 0x04
    25d2:	81 81       	ldd	r24, Z+1	; 0x01
    25d4:	92 81       	ldd	r25, Z+2	; 0x02
    25d6:	9a 83       	std	Y+2, r25	; 0x02
    25d8:	89 83       	std	Y+1, r24	; 0x01

	pxNewListItem->pxNext = pxIndex->pxNext;
    25da:	e9 81       	ldd	r30, Y+1	; 0x01
    25dc:	fa 81       	ldd	r31, Y+2	; 0x02
    25de:	82 81       	ldd	r24, Z+2	; 0x02
    25e0:	93 81       	ldd	r25, Z+3	; 0x03
    25e2:	ed 81       	ldd	r30, Y+5	; 0x05
    25e4:	fe 81       	ldd	r31, Y+6	; 0x06
    25e6:	93 83       	std	Z+3, r25	; 0x03
    25e8:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxPrevious = pxList->pxIndex;
    25ea:	eb 81       	ldd	r30, Y+3	; 0x03
    25ec:	fc 81       	ldd	r31, Y+4	; 0x04
    25ee:	81 81       	ldd	r24, Z+1	; 0x01
    25f0:	92 81       	ldd	r25, Z+2	; 0x02
    25f2:	ed 81       	ldd	r30, Y+5	; 0x05
    25f4:	fe 81       	ldd	r31, Y+6	; 0x06
    25f6:	95 83       	std	Z+5, r25	; 0x05
    25f8:	84 83       	std	Z+4, r24	; 0x04
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    25fa:	e9 81       	ldd	r30, Y+1	; 0x01
    25fc:	fa 81       	ldd	r31, Y+2	; 0x02
    25fe:	02 80       	ldd	r0, Z+2	; 0x02
    2600:	f3 81       	ldd	r31, Z+3	; 0x03
    2602:	e0 2d       	mov	r30, r0
    2604:	8d 81       	ldd	r24, Y+5	; 0x05
    2606:	9e 81       	ldd	r25, Y+6	; 0x06
    2608:	95 83       	std	Z+5, r25	; 0x05
    260a:	84 83       	std	Z+4, r24	; 0x04
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
    260c:	8d 81       	ldd	r24, Y+5	; 0x05
    260e:	9e 81       	ldd	r25, Y+6	; 0x06
    2610:	e9 81       	ldd	r30, Y+1	; 0x01
    2612:	fa 81       	ldd	r31, Y+2	; 0x02
    2614:	93 83       	std	Z+3, r25	; 0x03
    2616:	82 83       	std	Z+2, r24	; 0x02
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
    2618:	8d 81       	ldd	r24, Y+5	; 0x05
    261a:	9e 81       	ldd	r25, Y+6	; 0x06
    261c:	eb 81       	ldd	r30, Y+3	; 0x03
    261e:	fc 81       	ldd	r31, Y+4	; 0x04
    2620:	92 83       	std	Z+2, r25	; 0x02
    2622:	81 83       	std	Z+1, r24	; 0x01

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    2624:	ed 81       	ldd	r30, Y+5	; 0x05
    2626:	fe 81       	ldd	r31, Y+6	; 0x06
    2628:	8b 81       	ldd	r24, Y+3	; 0x03
    262a:	9c 81       	ldd	r25, Y+4	; 0x04
    262c:	91 87       	std	Z+9, r25	; 0x09
    262e:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
    2630:	eb 81       	ldd	r30, Y+3	; 0x03
    2632:	fc 81       	ldd	r31, Y+4	; 0x04
    2634:	80 81       	ld	r24, Z
    2636:	8f 5f       	subi	r24, 0xFF	; 255
    2638:	eb 81       	ldd	r30, Y+3	; 0x03
    263a:	fc 81       	ldd	r31, Y+4	; 0x04
    263c:	80 83       	st	Z, r24
}
    263e:	26 96       	adiw	r28, 0x06	; 6
    2640:	0f b6       	in	r0, 0x3f	; 63
    2642:	f8 94       	cli
    2644:	de bf       	out	0x3e, r29	; 62
    2646:	0f be       	out	0x3f, r0	; 63
    2648:	cd bf       	out	0x3d, r28	; 61
    264a:	cf 91       	pop	r28
    264c:	df 91       	pop	r29
    264e:	08 95       	ret

00002650 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
    2650:	df 93       	push	r29
    2652:	cf 93       	push	r28
    2654:	cd b7       	in	r28, 0x3d	; 61
    2656:	de b7       	in	r29, 0x3e	; 62
    2658:	28 97       	sbiw	r28, 0x08	; 8
    265a:	0f b6       	in	r0, 0x3f	; 63
    265c:	f8 94       	cli
    265e:	de bf       	out	0x3e, r29	; 62
    2660:	0f be       	out	0x3f, r0	; 63
    2662:	cd bf       	out	0x3d, r28	; 61
    2664:	9e 83       	std	Y+6, r25	; 0x06
    2666:	8d 83       	std	Y+5, r24	; 0x05
    2668:	78 87       	std	Y+8, r23	; 0x08
    266a:	6f 83       	std	Y+7, r22	; 0x07
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
    266c:	ef 81       	ldd	r30, Y+7	; 0x07
    266e:	f8 85       	ldd	r31, Y+8	; 0x08
    2670:	80 81       	ld	r24, Z
    2672:	91 81       	ldd	r25, Z+1	; 0x01
    2674:	9a 83       	std	Y+2, r25	; 0x02
    2676:	89 83       	std	Y+1, r24	; 0x01
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    2678:	89 81       	ldd	r24, Y+1	; 0x01
    267a:	9a 81       	ldd	r25, Y+2	; 0x02
    267c:	2f ef       	ldi	r18, 0xFF	; 255
    267e:	8f 3f       	cpi	r24, 0xFF	; 255
    2680:	92 07       	cpc	r25, r18
    2682:	39 f4       	brne	.+14     	; 0x2692 <vListInsert+0x42>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    2684:	ed 81       	ldd	r30, Y+5	; 0x05
    2686:	fe 81       	ldd	r31, Y+6	; 0x06
    2688:	87 81       	ldd	r24, Z+7	; 0x07
    268a:	90 85       	ldd	r25, Z+8	; 0x08
    268c:	9c 83       	std	Y+4, r25	; 0x04
    268e:	8b 83       	std	Y+3, r24	; 0x03
    2690:	18 c0       	rjmp	.+48     	; 0x26c2 <vListInsert+0x72>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/
		
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
    2692:	8d 81       	ldd	r24, Y+5	; 0x05
    2694:	9e 81       	ldd	r25, Y+6	; 0x06
    2696:	03 96       	adiw	r24, 0x03	; 3
    2698:	9c 83       	std	Y+4, r25	; 0x04
    269a:	8b 83       	std	Y+3, r24	; 0x03
    269c:	06 c0       	rjmp	.+12     	; 0x26aa <vListInsert+0x5a>
    269e:	eb 81       	ldd	r30, Y+3	; 0x03
    26a0:	fc 81       	ldd	r31, Y+4	; 0x04
    26a2:	82 81       	ldd	r24, Z+2	; 0x02
    26a4:	93 81       	ldd	r25, Z+3	; 0x03
    26a6:	9c 83       	std	Y+4, r25	; 0x04
    26a8:	8b 83       	std	Y+3, r24	; 0x03
    26aa:	eb 81       	ldd	r30, Y+3	; 0x03
    26ac:	fc 81       	ldd	r31, Y+4	; 0x04
    26ae:	02 80       	ldd	r0, Z+2	; 0x02
    26b0:	f3 81       	ldd	r31, Z+3	; 0x03
    26b2:	e0 2d       	mov	r30, r0
    26b4:	20 81       	ld	r18, Z
    26b6:	31 81       	ldd	r19, Z+1	; 0x01
    26b8:	89 81       	ldd	r24, Y+1	; 0x01
    26ba:	9a 81       	ldd	r25, Y+2	; 0x02
    26bc:	82 17       	cp	r24, r18
    26be:	93 07       	cpc	r25, r19
    26c0:	70 f7       	brcc	.-36     	; 0x269e <vListInsert+0x4e>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    26c2:	eb 81       	ldd	r30, Y+3	; 0x03
    26c4:	fc 81       	ldd	r31, Y+4	; 0x04
    26c6:	82 81       	ldd	r24, Z+2	; 0x02
    26c8:	93 81       	ldd	r25, Z+3	; 0x03
    26ca:	ef 81       	ldd	r30, Y+7	; 0x07
    26cc:	f8 85       	ldd	r31, Y+8	; 0x08
    26ce:	93 83       	std	Z+3, r25	; 0x03
    26d0:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    26d2:	ef 81       	ldd	r30, Y+7	; 0x07
    26d4:	f8 85       	ldd	r31, Y+8	; 0x08
    26d6:	02 80       	ldd	r0, Z+2	; 0x02
    26d8:	f3 81       	ldd	r31, Z+3	; 0x03
    26da:	e0 2d       	mov	r30, r0
    26dc:	8f 81       	ldd	r24, Y+7	; 0x07
    26de:	98 85       	ldd	r25, Y+8	; 0x08
    26e0:	95 83       	std	Z+5, r25	; 0x05
    26e2:	84 83       	std	Z+4, r24	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
    26e4:	ef 81       	ldd	r30, Y+7	; 0x07
    26e6:	f8 85       	ldd	r31, Y+8	; 0x08
    26e8:	8b 81       	ldd	r24, Y+3	; 0x03
    26ea:	9c 81       	ldd	r25, Y+4	; 0x04
    26ec:	95 83       	std	Z+5, r25	; 0x05
    26ee:	84 83       	std	Z+4, r24	; 0x04
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
    26f0:	8f 81       	ldd	r24, Y+7	; 0x07
    26f2:	98 85       	ldd	r25, Y+8	; 0x08
    26f4:	eb 81       	ldd	r30, Y+3	; 0x03
    26f6:	fc 81       	ldd	r31, Y+4	; 0x04
    26f8:	93 83       	std	Z+3, r25	; 0x03
    26fa:	82 83       	std	Z+2, r24	; 0x02

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    26fc:	ef 81       	ldd	r30, Y+7	; 0x07
    26fe:	f8 85       	ldd	r31, Y+8	; 0x08
    2700:	8d 81       	ldd	r24, Y+5	; 0x05
    2702:	9e 81       	ldd	r25, Y+6	; 0x06
    2704:	91 87       	std	Z+9, r25	; 0x09
    2706:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
    2708:	ed 81       	ldd	r30, Y+5	; 0x05
    270a:	fe 81       	ldd	r31, Y+6	; 0x06
    270c:	80 81       	ld	r24, Z
    270e:	8f 5f       	subi	r24, 0xFF	; 255
    2710:	ed 81       	ldd	r30, Y+5	; 0x05
    2712:	fe 81       	ldd	r31, Y+6	; 0x06
    2714:	80 83       	st	Z, r24
}
    2716:	28 96       	adiw	r28, 0x08	; 8
    2718:	0f b6       	in	r0, 0x3f	; 63
    271a:	f8 94       	cli
    271c:	de bf       	out	0x3e, r29	; 62
    271e:	0f be       	out	0x3f, r0	; 63
    2720:	cd bf       	out	0x3d, r28	; 61
    2722:	cf 91       	pop	r28
    2724:	df 91       	pop	r29
    2726:	08 95       	ret

00002728 <vListRemove>:
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
    2728:	df 93       	push	r29
    272a:	cf 93       	push	r28
    272c:	00 d0       	rcall	.+0      	; 0x272e <vListRemove+0x6>
    272e:	00 d0       	rcall	.+0      	; 0x2730 <vListRemove+0x8>
    2730:	cd b7       	in	r28, 0x3d	; 61
    2732:	de b7       	in	r29, 0x3e	; 62
    2734:	9c 83       	std	Y+4, r25	; 0x04
    2736:	8b 83       	std	Y+3, r24	; 0x03
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    2738:	eb 81       	ldd	r30, Y+3	; 0x03
    273a:	fc 81       	ldd	r31, Y+4	; 0x04
    273c:	a2 81       	ldd	r26, Z+2	; 0x02
    273e:	b3 81       	ldd	r27, Z+3	; 0x03
    2740:	eb 81       	ldd	r30, Y+3	; 0x03
    2742:	fc 81       	ldd	r31, Y+4	; 0x04
    2744:	84 81       	ldd	r24, Z+4	; 0x04
    2746:	95 81       	ldd	r25, Z+5	; 0x05
    2748:	15 96       	adiw	r26, 0x05	; 5
    274a:	9c 93       	st	X, r25
    274c:	8e 93       	st	-X, r24
    274e:	14 97       	sbiw	r26, 0x04	; 4
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    2750:	eb 81       	ldd	r30, Y+3	; 0x03
    2752:	fc 81       	ldd	r31, Y+4	; 0x04
    2754:	a4 81       	ldd	r26, Z+4	; 0x04
    2756:	b5 81       	ldd	r27, Z+5	; 0x05
    2758:	eb 81       	ldd	r30, Y+3	; 0x03
    275a:	fc 81       	ldd	r31, Y+4	; 0x04
    275c:	82 81       	ldd	r24, Z+2	; 0x02
    275e:	93 81       	ldd	r25, Z+3	; 0x03
    2760:	13 96       	adiw	r26, 0x03	; 3
    2762:	9c 93       	st	X, r25
    2764:	8e 93       	st	-X, r24
    2766:	12 97       	sbiw	r26, 0x02	; 2
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
    2768:	eb 81       	ldd	r30, Y+3	; 0x03
    276a:	fc 81       	ldd	r31, Y+4	; 0x04
    276c:	80 85       	ldd	r24, Z+8	; 0x08
    276e:	91 85       	ldd	r25, Z+9	; 0x09
    2770:	9a 83       	std	Y+2, r25	; 0x02
    2772:	89 83       	std	Y+1, r24	; 0x01

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    2774:	e9 81       	ldd	r30, Y+1	; 0x01
    2776:	fa 81       	ldd	r31, Y+2	; 0x02
    2778:	21 81       	ldd	r18, Z+1	; 0x01
    277a:	32 81       	ldd	r19, Z+2	; 0x02
    277c:	8b 81       	ldd	r24, Y+3	; 0x03
    277e:	9c 81       	ldd	r25, Y+4	; 0x04
    2780:	28 17       	cp	r18, r24
    2782:	39 07       	cpc	r19, r25
    2784:	41 f4       	brne	.+16     	; 0x2796 <vListRemove+0x6e>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    2786:	eb 81       	ldd	r30, Y+3	; 0x03
    2788:	fc 81       	ldd	r31, Y+4	; 0x04
    278a:	84 81       	ldd	r24, Z+4	; 0x04
    278c:	95 81       	ldd	r25, Z+5	; 0x05
    278e:	e9 81       	ldd	r30, Y+1	; 0x01
    2790:	fa 81       	ldd	r31, Y+2	; 0x02
    2792:	92 83       	std	Z+2, r25	; 0x02
    2794:	81 83       	std	Z+1, r24	; 0x01
	}

	pxItemToRemove->pvContainer = NULL;
    2796:	eb 81       	ldd	r30, Y+3	; 0x03
    2798:	fc 81       	ldd	r31, Y+4	; 0x04
    279a:	11 86       	std	Z+9, r1	; 0x09
    279c:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
    279e:	e9 81       	ldd	r30, Y+1	; 0x01
    27a0:	fa 81       	ldd	r31, Y+2	; 0x02
    27a2:	80 81       	ld	r24, Z
    27a4:	81 50       	subi	r24, 0x01	; 1
    27a6:	e9 81       	ldd	r30, Y+1	; 0x01
    27a8:	fa 81       	ldd	r31, Y+2	; 0x02
    27aa:	80 83       	st	Z, r24
}
    27ac:	0f 90       	pop	r0
    27ae:	0f 90       	pop	r0
    27b0:	0f 90       	pop	r0
    27b2:	0f 90       	pop	r0
    27b4:	cf 91       	pop	r28
    27b6:	df 91       	pop	r29
    27b8:	08 95       	ret

000027ba <pxPortInitialiseStack>:

/* 
 * See header file for description. 
 */
portSTACK_TYPE *pxPortInitialiseStack( portSTACK_TYPE *pxTopOfStack, pdTASK_CODE pxCode, void *pvParameters )
{
    27ba:	df 93       	push	r29
    27bc:	cf 93       	push	r28
    27be:	cd b7       	in	r28, 0x3d	; 61
    27c0:	de b7       	in	r29, 0x3e	; 62
    27c2:	28 97       	sbiw	r28, 0x08	; 8
    27c4:	0f b6       	in	r0, 0x3f	; 63
    27c6:	f8 94       	cli
    27c8:	de bf       	out	0x3e, r29	; 62
    27ca:	0f be       	out	0x3f, r0	; 63
    27cc:	cd bf       	out	0x3d, r28	; 61
    27ce:	9c 83       	std	Y+4, r25	; 0x04
    27d0:	8b 83       	std	Y+3, r24	; 0x03
    27d2:	7e 83       	std	Y+6, r23	; 0x06
    27d4:	6d 83       	std	Y+5, r22	; 0x05
    27d6:	58 87       	std	Y+8, r21	; 0x08
    27d8:	4f 83       	std	Y+7, r20	; 0x07
unsigned short usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
    27da:	eb 81       	ldd	r30, Y+3	; 0x03
    27dc:	fc 81       	ldd	r31, Y+4	; 0x04
    27de:	81 e1       	ldi	r24, 0x11	; 17
    27e0:	80 83       	st	Z, r24
	pxTopOfStack--;
    27e2:	8b 81       	ldd	r24, Y+3	; 0x03
    27e4:	9c 81       	ldd	r25, Y+4	; 0x04
    27e6:	01 97       	sbiw	r24, 0x01	; 1
    27e8:	9c 83       	std	Y+4, r25	; 0x04
    27ea:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x22;
    27ec:	eb 81       	ldd	r30, Y+3	; 0x03
    27ee:	fc 81       	ldd	r31, Y+4	; 0x04
    27f0:	82 e2       	ldi	r24, 0x22	; 34
    27f2:	80 83       	st	Z, r24
	pxTopOfStack--;
    27f4:	8b 81       	ldd	r24, Y+3	; 0x03
    27f6:	9c 81       	ldd	r25, Y+4	; 0x04
    27f8:	01 97       	sbiw	r24, 0x01	; 1
    27fa:	9c 83       	std	Y+4, r25	; 0x04
    27fc:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x33;
    27fe:	eb 81       	ldd	r30, Y+3	; 0x03
    2800:	fc 81       	ldd	r31, Y+4	; 0x04
    2802:	83 e3       	ldi	r24, 0x33	; 51
    2804:	80 83       	st	Z, r24
	pxTopOfStack--;
    2806:	8b 81       	ldd	r24, Y+3	; 0x03
    2808:	9c 81       	ldd	r25, Y+4	; 0x04
    280a:	01 97       	sbiw	r24, 0x01	; 1
    280c:	9c 83       	std	Y+4, r25	; 0x04
    280e:	8b 83       	std	Y+3, r24	; 0x03

	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( unsigned short ) pxCode;
    2810:	8d 81       	ldd	r24, Y+5	; 0x05
    2812:	9e 81       	ldd	r25, Y+6	; 0x06
    2814:	9a 83       	std	Y+2, r25	; 0x02
    2816:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    2818:	89 81       	ldd	r24, Y+1	; 0x01
    281a:	eb 81       	ldd	r30, Y+3	; 0x03
    281c:	fc 81       	ldd	r31, Y+4	; 0x04
    281e:	80 83       	st	Z, r24
	pxTopOfStack--;
    2820:	8b 81       	ldd	r24, Y+3	; 0x03
    2822:	9c 81       	ldd	r25, Y+4	; 0x04
    2824:	01 97       	sbiw	r24, 0x01	; 1
    2826:	9c 83       	std	Y+4, r25	; 0x04
    2828:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    282a:	89 81       	ldd	r24, Y+1	; 0x01
    282c:	9a 81       	ldd	r25, Y+2	; 0x02
    282e:	89 2f       	mov	r24, r25
    2830:	99 27       	eor	r25, r25
    2832:	9a 83       	std	Y+2, r25	; 0x02
    2834:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    2836:	89 81       	ldd	r24, Y+1	; 0x01
    2838:	eb 81       	ldd	r30, Y+3	; 0x03
    283a:	fc 81       	ldd	r31, Y+4	; 0x04
    283c:	80 83       	st	Z, r24
	pxTopOfStack--;
    283e:	8b 81       	ldd	r24, Y+3	; 0x03
    2840:	9c 81       	ldd	r25, Y+4	; 0x04
    2842:	01 97       	sbiw	r24, 0x01	; 1
    2844:	9c 83       	std	Y+4, r25	; 0x04
    2846:	8b 83       	std	Y+3, r24	; 0x03

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R0 */
    2848:	eb 81       	ldd	r30, Y+3	; 0x03
    284a:	fc 81       	ldd	r31, Y+4	; 0x04
    284c:	10 82       	st	Z, r1
	pxTopOfStack--;
    284e:	8b 81       	ldd	r24, Y+3	; 0x03
    2850:	9c 81       	ldd	r25, Y+4	; 0x04
    2852:	01 97       	sbiw	r24, 0x01	; 1
    2854:	9c 83       	std	Y+4, r25	; 0x04
    2856:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = portFLAGS_INT_ENABLED;
    2858:	eb 81       	ldd	r30, Y+3	; 0x03
    285a:	fc 81       	ldd	r31, Y+4	; 0x04
    285c:	80 e8       	ldi	r24, 0x80	; 128
    285e:	80 83       	st	Z, r24
	pxTopOfStack--;
    2860:	8b 81       	ldd	r24, Y+3	; 0x03
    2862:	9c 81       	ldd	r25, Y+4	; 0x04
    2864:	01 97       	sbiw	r24, 0x01	; 1
    2866:	9c 83       	std	Y+4, r25	; 0x04
    2868:	8b 83       	std	Y+3, r24	; 0x03


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R1 */
    286a:	eb 81       	ldd	r30, Y+3	; 0x03
    286c:	fc 81       	ldd	r31, Y+4	; 0x04
    286e:	10 82       	st	Z, r1
	pxTopOfStack--;
    2870:	8b 81       	ldd	r24, Y+3	; 0x03
    2872:	9c 81       	ldd	r25, Y+4	; 0x04
    2874:	01 97       	sbiw	r24, 0x01	; 1
    2876:	9c 83       	std	Y+4, r25	; 0x04
    2878:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x02;	/* R2 */
    287a:	eb 81       	ldd	r30, Y+3	; 0x03
    287c:	fc 81       	ldd	r31, Y+4	; 0x04
    287e:	82 e0       	ldi	r24, 0x02	; 2
    2880:	80 83       	st	Z, r24
	pxTopOfStack--;
    2882:	8b 81       	ldd	r24, Y+3	; 0x03
    2884:	9c 81       	ldd	r25, Y+4	; 0x04
    2886:	01 97       	sbiw	r24, 0x01	; 1
    2888:	9c 83       	std	Y+4, r25	; 0x04
    288a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x03;	/* R3 */
    288c:	eb 81       	ldd	r30, Y+3	; 0x03
    288e:	fc 81       	ldd	r31, Y+4	; 0x04
    2890:	83 e0       	ldi	r24, 0x03	; 3
    2892:	80 83       	st	Z, r24
	pxTopOfStack--;
    2894:	8b 81       	ldd	r24, Y+3	; 0x03
    2896:	9c 81       	ldd	r25, Y+4	; 0x04
    2898:	01 97       	sbiw	r24, 0x01	; 1
    289a:	9c 83       	std	Y+4, r25	; 0x04
    289c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x04;	/* R4 */
    289e:	eb 81       	ldd	r30, Y+3	; 0x03
    28a0:	fc 81       	ldd	r31, Y+4	; 0x04
    28a2:	84 e0       	ldi	r24, 0x04	; 4
    28a4:	80 83       	st	Z, r24
	pxTopOfStack--;
    28a6:	8b 81       	ldd	r24, Y+3	; 0x03
    28a8:	9c 81       	ldd	r25, Y+4	; 0x04
    28aa:	01 97       	sbiw	r24, 0x01	; 1
    28ac:	9c 83       	std	Y+4, r25	; 0x04
    28ae:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x05;	/* R5 */
    28b0:	eb 81       	ldd	r30, Y+3	; 0x03
    28b2:	fc 81       	ldd	r31, Y+4	; 0x04
    28b4:	85 e0       	ldi	r24, 0x05	; 5
    28b6:	80 83       	st	Z, r24
	pxTopOfStack--;
    28b8:	8b 81       	ldd	r24, Y+3	; 0x03
    28ba:	9c 81       	ldd	r25, Y+4	; 0x04
    28bc:	01 97       	sbiw	r24, 0x01	; 1
    28be:	9c 83       	std	Y+4, r25	; 0x04
    28c0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x06;	/* R6 */
    28c2:	eb 81       	ldd	r30, Y+3	; 0x03
    28c4:	fc 81       	ldd	r31, Y+4	; 0x04
    28c6:	86 e0       	ldi	r24, 0x06	; 6
    28c8:	80 83       	st	Z, r24
	pxTopOfStack--;
    28ca:	8b 81       	ldd	r24, Y+3	; 0x03
    28cc:	9c 81       	ldd	r25, Y+4	; 0x04
    28ce:	01 97       	sbiw	r24, 0x01	; 1
    28d0:	9c 83       	std	Y+4, r25	; 0x04
    28d2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x07;	/* R7 */
    28d4:	eb 81       	ldd	r30, Y+3	; 0x03
    28d6:	fc 81       	ldd	r31, Y+4	; 0x04
    28d8:	87 e0       	ldi	r24, 0x07	; 7
    28da:	80 83       	st	Z, r24
	pxTopOfStack--;
    28dc:	8b 81       	ldd	r24, Y+3	; 0x03
    28de:	9c 81       	ldd	r25, Y+4	; 0x04
    28e0:	01 97       	sbiw	r24, 0x01	; 1
    28e2:	9c 83       	std	Y+4, r25	; 0x04
    28e4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x08;	/* R8 */
    28e6:	eb 81       	ldd	r30, Y+3	; 0x03
    28e8:	fc 81       	ldd	r31, Y+4	; 0x04
    28ea:	88 e0       	ldi	r24, 0x08	; 8
    28ec:	80 83       	st	Z, r24
	pxTopOfStack--;
    28ee:	8b 81       	ldd	r24, Y+3	; 0x03
    28f0:	9c 81       	ldd	r25, Y+4	; 0x04
    28f2:	01 97       	sbiw	r24, 0x01	; 1
    28f4:	9c 83       	std	Y+4, r25	; 0x04
    28f6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x09;	/* R9 */
    28f8:	eb 81       	ldd	r30, Y+3	; 0x03
    28fa:	fc 81       	ldd	r31, Y+4	; 0x04
    28fc:	89 e0       	ldi	r24, 0x09	; 9
    28fe:	80 83       	st	Z, r24
	pxTopOfStack--;
    2900:	8b 81       	ldd	r24, Y+3	; 0x03
    2902:	9c 81       	ldd	r25, Y+4	; 0x04
    2904:	01 97       	sbiw	r24, 0x01	; 1
    2906:	9c 83       	std	Y+4, r25	; 0x04
    2908:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x10;	/* R10 */
    290a:	eb 81       	ldd	r30, Y+3	; 0x03
    290c:	fc 81       	ldd	r31, Y+4	; 0x04
    290e:	80 e1       	ldi	r24, 0x10	; 16
    2910:	80 83       	st	Z, r24
	pxTopOfStack--;
    2912:	8b 81       	ldd	r24, Y+3	; 0x03
    2914:	9c 81       	ldd	r25, Y+4	; 0x04
    2916:	01 97       	sbiw	r24, 0x01	; 1
    2918:	9c 83       	std	Y+4, r25	; 0x04
    291a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x11;	/* R11 */
    291c:	eb 81       	ldd	r30, Y+3	; 0x03
    291e:	fc 81       	ldd	r31, Y+4	; 0x04
    2920:	81 e1       	ldi	r24, 0x11	; 17
    2922:	80 83       	st	Z, r24
	pxTopOfStack--;
    2924:	8b 81       	ldd	r24, Y+3	; 0x03
    2926:	9c 81       	ldd	r25, Y+4	; 0x04
    2928:	01 97       	sbiw	r24, 0x01	; 1
    292a:	9c 83       	std	Y+4, r25	; 0x04
    292c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x12;	/* R12 */
    292e:	eb 81       	ldd	r30, Y+3	; 0x03
    2930:	fc 81       	ldd	r31, Y+4	; 0x04
    2932:	82 e1       	ldi	r24, 0x12	; 18
    2934:	80 83       	st	Z, r24
	pxTopOfStack--;
    2936:	8b 81       	ldd	r24, Y+3	; 0x03
    2938:	9c 81       	ldd	r25, Y+4	; 0x04
    293a:	01 97       	sbiw	r24, 0x01	; 1
    293c:	9c 83       	std	Y+4, r25	; 0x04
    293e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x13;	/* R13 */
    2940:	eb 81       	ldd	r30, Y+3	; 0x03
    2942:	fc 81       	ldd	r31, Y+4	; 0x04
    2944:	83 e1       	ldi	r24, 0x13	; 19
    2946:	80 83       	st	Z, r24
	pxTopOfStack--;
    2948:	8b 81       	ldd	r24, Y+3	; 0x03
    294a:	9c 81       	ldd	r25, Y+4	; 0x04
    294c:	01 97       	sbiw	r24, 0x01	; 1
    294e:	9c 83       	std	Y+4, r25	; 0x04
    2950:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x14;	/* R14 */
    2952:	eb 81       	ldd	r30, Y+3	; 0x03
    2954:	fc 81       	ldd	r31, Y+4	; 0x04
    2956:	84 e1       	ldi	r24, 0x14	; 20
    2958:	80 83       	st	Z, r24
	pxTopOfStack--;
    295a:	8b 81       	ldd	r24, Y+3	; 0x03
    295c:	9c 81       	ldd	r25, Y+4	; 0x04
    295e:	01 97       	sbiw	r24, 0x01	; 1
    2960:	9c 83       	std	Y+4, r25	; 0x04
    2962:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x15;	/* R15 */
    2964:	eb 81       	ldd	r30, Y+3	; 0x03
    2966:	fc 81       	ldd	r31, Y+4	; 0x04
    2968:	85 e1       	ldi	r24, 0x15	; 21
    296a:	80 83       	st	Z, r24
	pxTopOfStack--;
    296c:	8b 81       	ldd	r24, Y+3	; 0x03
    296e:	9c 81       	ldd	r25, Y+4	; 0x04
    2970:	01 97       	sbiw	r24, 0x01	; 1
    2972:	9c 83       	std	Y+4, r25	; 0x04
    2974:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x16;	/* R16 */
    2976:	eb 81       	ldd	r30, Y+3	; 0x03
    2978:	fc 81       	ldd	r31, Y+4	; 0x04
    297a:	86 e1       	ldi	r24, 0x16	; 22
    297c:	80 83       	st	Z, r24
	pxTopOfStack--;
    297e:	8b 81       	ldd	r24, Y+3	; 0x03
    2980:	9c 81       	ldd	r25, Y+4	; 0x04
    2982:	01 97       	sbiw	r24, 0x01	; 1
    2984:	9c 83       	std	Y+4, r25	; 0x04
    2986:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x17;	/* R17 */
    2988:	eb 81       	ldd	r30, Y+3	; 0x03
    298a:	fc 81       	ldd	r31, Y+4	; 0x04
    298c:	87 e1       	ldi	r24, 0x17	; 23
    298e:	80 83       	st	Z, r24
	pxTopOfStack--;
    2990:	8b 81       	ldd	r24, Y+3	; 0x03
    2992:	9c 81       	ldd	r25, Y+4	; 0x04
    2994:	01 97       	sbiw	r24, 0x01	; 1
    2996:	9c 83       	std	Y+4, r25	; 0x04
    2998:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x18;	/* R18 */
    299a:	eb 81       	ldd	r30, Y+3	; 0x03
    299c:	fc 81       	ldd	r31, Y+4	; 0x04
    299e:	88 e1       	ldi	r24, 0x18	; 24
    29a0:	80 83       	st	Z, r24
	pxTopOfStack--;
    29a2:	8b 81       	ldd	r24, Y+3	; 0x03
    29a4:	9c 81       	ldd	r25, Y+4	; 0x04
    29a6:	01 97       	sbiw	r24, 0x01	; 1
    29a8:	9c 83       	std	Y+4, r25	; 0x04
    29aa:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x19;	/* R19 */
    29ac:	eb 81       	ldd	r30, Y+3	; 0x03
    29ae:	fc 81       	ldd	r31, Y+4	; 0x04
    29b0:	89 e1       	ldi	r24, 0x19	; 25
    29b2:	80 83       	st	Z, r24
	pxTopOfStack--;
    29b4:	8b 81       	ldd	r24, Y+3	; 0x03
    29b6:	9c 81       	ldd	r25, Y+4	; 0x04
    29b8:	01 97       	sbiw	r24, 0x01	; 1
    29ba:	9c 83       	std	Y+4, r25	; 0x04
    29bc:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x20;	/* R20 */
    29be:	eb 81       	ldd	r30, Y+3	; 0x03
    29c0:	fc 81       	ldd	r31, Y+4	; 0x04
    29c2:	80 e2       	ldi	r24, 0x20	; 32
    29c4:	80 83       	st	Z, r24
	pxTopOfStack--;
    29c6:	8b 81       	ldd	r24, Y+3	; 0x03
    29c8:	9c 81       	ldd	r25, Y+4	; 0x04
    29ca:	01 97       	sbiw	r24, 0x01	; 1
    29cc:	9c 83       	std	Y+4, r25	; 0x04
    29ce:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x21;	/* R21 */
    29d0:	eb 81       	ldd	r30, Y+3	; 0x03
    29d2:	fc 81       	ldd	r31, Y+4	; 0x04
    29d4:	81 e2       	ldi	r24, 0x21	; 33
    29d6:	80 83       	st	Z, r24
	pxTopOfStack--;
    29d8:	8b 81       	ldd	r24, Y+3	; 0x03
    29da:	9c 81       	ldd	r25, Y+4	; 0x04
    29dc:	01 97       	sbiw	r24, 0x01	; 1
    29de:	9c 83       	std	Y+4, r25	; 0x04
    29e0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x22;	/* R22 */
    29e2:	eb 81       	ldd	r30, Y+3	; 0x03
    29e4:	fc 81       	ldd	r31, Y+4	; 0x04
    29e6:	82 e2       	ldi	r24, 0x22	; 34
    29e8:	80 83       	st	Z, r24
	pxTopOfStack--;
    29ea:	8b 81       	ldd	r24, Y+3	; 0x03
    29ec:	9c 81       	ldd	r25, Y+4	; 0x04
    29ee:	01 97       	sbiw	r24, 0x01	; 1
    29f0:	9c 83       	std	Y+4, r25	; 0x04
    29f2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x23;	/* R23 */
    29f4:	eb 81       	ldd	r30, Y+3	; 0x03
    29f6:	fc 81       	ldd	r31, Y+4	; 0x04
    29f8:	83 e2       	ldi	r24, 0x23	; 35
    29fa:	80 83       	st	Z, r24
	pxTopOfStack--;
    29fc:	8b 81       	ldd	r24, Y+3	; 0x03
    29fe:	9c 81       	ldd	r25, Y+4	; 0x04
    2a00:	01 97       	sbiw	r24, 0x01	; 1
    2a02:	9c 83       	std	Y+4, r25	; 0x04
    2a04:	8b 83       	std	Y+3, r24	; 0x03

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( unsigned short ) pvParameters;
    2a06:	8f 81       	ldd	r24, Y+7	; 0x07
    2a08:	98 85       	ldd	r25, Y+8	; 0x08
    2a0a:	9a 83       	std	Y+2, r25	; 0x02
    2a0c:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    2a0e:	89 81       	ldd	r24, Y+1	; 0x01
    2a10:	eb 81       	ldd	r30, Y+3	; 0x03
    2a12:	fc 81       	ldd	r31, Y+4	; 0x04
    2a14:	80 83       	st	Z, r24
	pxTopOfStack--;
    2a16:	8b 81       	ldd	r24, Y+3	; 0x03
    2a18:	9c 81       	ldd	r25, Y+4	; 0x04
    2a1a:	01 97       	sbiw	r24, 0x01	; 1
    2a1c:	9c 83       	std	Y+4, r25	; 0x04
    2a1e:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    2a20:	89 81       	ldd	r24, Y+1	; 0x01
    2a22:	9a 81       	ldd	r25, Y+2	; 0x02
    2a24:	89 2f       	mov	r24, r25
    2a26:	99 27       	eor	r25, r25
    2a28:	9a 83       	std	Y+2, r25	; 0x02
    2a2a:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    2a2c:	89 81       	ldd	r24, Y+1	; 0x01
    2a2e:	eb 81       	ldd	r30, Y+3	; 0x03
    2a30:	fc 81       	ldd	r31, Y+4	; 0x04
    2a32:	80 83       	st	Z, r24
	pxTopOfStack--;
    2a34:	8b 81       	ldd	r24, Y+3	; 0x03
    2a36:	9c 81       	ldd	r25, Y+4	; 0x04
    2a38:	01 97       	sbiw	r24, 0x01	; 1
    2a3a:	9c 83       	std	Y+4, r25	; 0x04
    2a3c:	8b 83       	std	Y+3, r24	; 0x03

	*pxTopOfStack = ( portSTACK_TYPE ) 0x26;	/* R26 X */
    2a3e:	eb 81       	ldd	r30, Y+3	; 0x03
    2a40:	fc 81       	ldd	r31, Y+4	; 0x04
    2a42:	86 e2       	ldi	r24, 0x26	; 38
    2a44:	80 83       	st	Z, r24
	pxTopOfStack--;
    2a46:	8b 81       	ldd	r24, Y+3	; 0x03
    2a48:	9c 81       	ldd	r25, Y+4	; 0x04
    2a4a:	01 97       	sbiw	r24, 0x01	; 1
    2a4c:	9c 83       	std	Y+4, r25	; 0x04
    2a4e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x27;	/* R27 */
    2a50:	eb 81       	ldd	r30, Y+3	; 0x03
    2a52:	fc 81       	ldd	r31, Y+4	; 0x04
    2a54:	87 e2       	ldi	r24, 0x27	; 39
    2a56:	80 83       	st	Z, r24
	pxTopOfStack--;
    2a58:	8b 81       	ldd	r24, Y+3	; 0x03
    2a5a:	9c 81       	ldd	r25, Y+4	; 0x04
    2a5c:	01 97       	sbiw	r24, 0x01	; 1
    2a5e:	9c 83       	std	Y+4, r25	; 0x04
    2a60:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x28;	/* R28 Y */
    2a62:	eb 81       	ldd	r30, Y+3	; 0x03
    2a64:	fc 81       	ldd	r31, Y+4	; 0x04
    2a66:	88 e2       	ldi	r24, 0x28	; 40
    2a68:	80 83       	st	Z, r24
	pxTopOfStack--;
    2a6a:	8b 81       	ldd	r24, Y+3	; 0x03
    2a6c:	9c 81       	ldd	r25, Y+4	; 0x04
    2a6e:	01 97       	sbiw	r24, 0x01	; 1
    2a70:	9c 83       	std	Y+4, r25	; 0x04
    2a72:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x29;	/* R29 */
    2a74:	eb 81       	ldd	r30, Y+3	; 0x03
    2a76:	fc 81       	ldd	r31, Y+4	; 0x04
    2a78:	89 e2       	ldi	r24, 0x29	; 41
    2a7a:	80 83       	st	Z, r24
	pxTopOfStack--;
    2a7c:	8b 81       	ldd	r24, Y+3	; 0x03
    2a7e:	9c 81       	ldd	r25, Y+4	; 0x04
    2a80:	01 97       	sbiw	r24, 0x01	; 1
    2a82:	9c 83       	std	Y+4, r25	; 0x04
    2a84:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x30;	/* R30 Z */
    2a86:	eb 81       	ldd	r30, Y+3	; 0x03
    2a88:	fc 81       	ldd	r31, Y+4	; 0x04
    2a8a:	80 e3       	ldi	r24, 0x30	; 48
    2a8c:	80 83       	st	Z, r24
	pxTopOfStack--;
    2a8e:	8b 81       	ldd	r24, Y+3	; 0x03
    2a90:	9c 81       	ldd	r25, Y+4	; 0x04
    2a92:	01 97       	sbiw	r24, 0x01	; 1
    2a94:	9c 83       	std	Y+4, r25	; 0x04
    2a96:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x031;	/* R31 */
    2a98:	eb 81       	ldd	r30, Y+3	; 0x03
    2a9a:	fc 81       	ldd	r31, Y+4	; 0x04
    2a9c:	81 e3       	ldi	r24, 0x31	; 49
    2a9e:	80 83       	st	Z, r24
	pxTopOfStack--;
    2aa0:	8b 81       	ldd	r24, Y+3	; 0x03
    2aa2:	9c 81       	ldd	r25, Y+4	; 0x04
    2aa4:	01 97       	sbiw	r24, 0x01	; 1
    2aa6:	9c 83       	std	Y+4, r25	; 0x04
    2aa8:	8b 83       	std	Y+3, r24	; 0x03

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
    2aaa:	8b 81       	ldd	r24, Y+3	; 0x03
    2aac:	9c 81       	ldd	r25, Y+4	; 0x04
}
    2aae:	28 96       	adiw	r28, 0x08	; 8
    2ab0:	0f b6       	in	r0, 0x3f	; 63
    2ab2:	f8 94       	cli
    2ab4:	de bf       	out	0x3e, r29	; 62
    2ab6:	0f be       	out	0x3f, r0	; 63
    2ab8:	cd bf       	out	0x3d, r28	; 61
    2aba:	cf 91       	pop	r28
    2abc:	df 91       	pop	r29
    2abe:	08 95       	ret

00002ac0 <xPortStartScheduler>:
/*-----------------------------------------------------------*/

portBASE_TYPE xPortStartScheduler( void )
{
    2ac0:	df 93       	push	r29
    2ac2:	cf 93       	push	r28
    2ac4:	cd b7       	in	r28, 0x3d	; 61
    2ac6:	de b7       	in	r29, 0x3e	; 62
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();
    2ac8:	0e 94 50 16 	call	0x2ca0	; 0x2ca0 <prvSetupTimerInterrupt>

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
    2acc:	a0 91 92 06 	lds	r26, 0x0692
    2ad0:	b0 91 93 06 	lds	r27, 0x0693
    2ad4:	cd 91       	ld	r28, X+
    2ad6:	cd bf       	out	0x3d, r28	; 61
    2ad8:	dd 91       	ld	r29, X+
    2ada:	de bf       	out	0x3e, r29	; 62
    2adc:	ff 91       	pop	r31
    2ade:	ef 91       	pop	r30
    2ae0:	df 91       	pop	r29
    2ae2:	cf 91       	pop	r28
    2ae4:	bf 91       	pop	r27
    2ae6:	af 91       	pop	r26
    2ae8:	9f 91       	pop	r25
    2aea:	8f 91       	pop	r24
    2aec:	7f 91       	pop	r23
    2aee:	6f 91       	pop	r22
    2af0:	5f 91       	pop	r21
    2af2:	4f 91       	pop	r20
    2af4:	3f 91       	pop	r19
    2af6:	2f 91       	pop	r18
    2af8:	1f 91       	pop	r17
    2afa:	0f 91       	pop	r16
    2afc:	ff 90       	pop	r15
    2afe:	ef 90       	pop	r14
    2b00:	df 90       	pop	r13
    2b02:	cf 90       	pop	r12
    2b04:	bf 90       	pop	r11
    2b06:	af 90       	pop	r10
    2b08:	9f 90       	pop	r9
    2b0a:	8f 90       	pop	r8
    2b0c:	7f 90       	pop	r7
    2b0e:	6f 90       	pop	r6
    2b10:	5f 90       	pop	r5
    2b12:	4f 90       	pop	r4
    2b14:	3f 90       	pop	r3
    2b16:	2f 90       	pop	r2
    2b18:	1f 90       	pop	r1
    2b1a:	0f 90       	pop	r0
    2b1c:	0f be       	out	0x3f, r0	; 63
    2b1e:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
    2b20:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
    2b22:	81 e0       	ldi	r24, 0x01	; 1
}
    2b24:	cf 91       	pop	r28
    2b26:	df 91       	pop	r29
    2b28:	08 95       	ret

00002b2a <vPortEndScheduler>:
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    2b2a:	df 93       	push	r29
    2b2c:	cf 93       	push	r28
    2b2e:	cd b7       	in	r28, 0x3d	; 61
    2b30:	de b7       	in	r29, 0x3e	; 62
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
    2b32:	cf 91       	pop	r28
    2b34:	df 91       	pop	r29
    2b36:	08 95       	ret

00002b38 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    2b38:	0f 92       	push	r0
    2b3a:	0f b6       	in	r0, 0x3f	; 63
    2b3c:	f8 94       	cli
    2b3e:	0f 92       	push	r0
    2b40:	1f 92       	push	r1
    2b42:	11 24       	eor	r1, r1
    2b44:	2f 92       	push	r2
    2b46:	3f 92       	push	r3
    2b48:	4f 92       	push	r4
    2b4a:	5f 92       	push	r5
    2b4c:	6f 92       	push	r6
    2b4e:	7f 92       	push	r7
    2b50:	8f 92       	push	r8
    2b52:	9f 92       	push	r9
    2b54:	af 92       	push	r10
    2b56:	bf 92       	push	r11
    2b58:	cf 92       	push	r12
    2b5a:	df 92       	push	r13
    2b5c:	ef 92       	push	r14
    2b5e:	ff 92       	push	r15
    2b60:	0f 93       	push	r16
    2b62:	1f 93       	push	r17
    2b64:	2f 93       	push	r18
    2b66:	3f 93       	push	r19
    2b68:	4f 93       	push	r20
    2b6a:	5f 93       	push	r21
    2b6c:	6f 93       	push	r22
    2b6e:	7f 93       	push	r23
    2b70:	8f 93       	push	r24
    2b72:	9f 93       	push	r25
    2b74:	af 93       	push	r26
    2b76:	bf 93       	push	r27
    2b78:	cf 93       	push	r28
    2b7a:	df 93       	push	r29
    2b7c:	ef 93       	push	r30
    2b7e:	ff 93       	push	r31
    2b80:	a0 91 92 06 	lds	r26, 0x0692
    2b84:	b0 91 93 06 	lds	r27, 0x0693
    2b88:	0d b6       	in	r0, 0x3d	; 61
    2b8a:	0d 92       	st	X+, r0
    2b8c:	0e b6       	in	r0, 0x3e	; 62
    2b8e:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    2b90:	0e 94 0c 1f 	call	0x3e18	; 0x3e18 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    2b94:	a0 91 92 06 	lds	r26, 0x0692
    2b98:	b0 91 93 06 	lds	r27, 0x0693
    2b9c:	cd 91       	ld	r28, X+
    2b9e:	cd bf       	out	0x3d, r28	; 61
    2ba0:	dd 91       	ld	r29, X+
    2ba2:	de bf       	out	0x3e, r29	; 62
    2ba4:	ff 91       	pop	r31
    2ba6:	ef 91       	pop	r30
    2ba8:	df 91       	pop	r29
    2baa:	cf 91       	pop	r28
    2bac:	bf 91       	pop	r27
    2bae:	af 91       	pop	r26
    2bb0:	9f 91       	pop	r25
    2bb2:	8f 91       	pop	r24
    2bb4:	7f 91       	pop	r23
    2bb6:	6f 91       	pop	r22
    2bb8:	5f 91       	pop	r21
    2bba:	4f 91       	pop	r20
    2bbc:	3f 91       	pop	r19
    2bbe:	2f 91       	pop	r18
    2bc0:	1f 91       	pop	r17
    2bc2:	0f 91       	pop	r16
    2bc4:	ff 90       	pop	r15
    2bc6:	ef 90       	pop	r14
    2bc8:	df 90       	pop	r13
    2bca:	cf 90       	pop	r12
    2bcc:	bf 90       	pop	r11
    2bce:	af 90       	pop	r10
    2bd0:	9f 90       	pop	r9
    2bd2:	8f 90       	pop	r8
    2bd4:	7f 90       	pop	r7
    2bd6:	6f 90       	pop	r6
    2bd8:	5f 90       	pop	r5
    2bda:	4f 90       	pop	r4
    2bdc:	3f 90       	pop	r3
    2bde:	2f 90       	pop	r2
    2be0:	1f 90       	pop	r1
    2be2:	0f 90       	pop	r0
    2be4:	0f be       	out	0x3f, r0	; 63
    2be6:	0f 90       	pop	r0

	asm volatile ( "ret" );
    2be8:	08 95       	ret

00002bea <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    2bea:	0f 92       	push	r0
    2bec:	0f b6       	in	r0, 0x3f	; 63
    2bee:	f8 94       	cli
    2bf0:	0f 92       	push	r0
    2bf2:	1f 92       	push	r1
    2bf4:	11 24       	eor	r1, r1
    2bf6:	2f 92       	push	r2
    2bf8:	3f 92       	push	r3
    2bfa:	4f 92       	push	r4
    2bfc:	5f 92       	push	r5
    2bfe:	6f 92       	push	r6
    2c00:	7f 92       	push	r7
    2c02:	8f 92       	push	r8
    2c04:	9f 92       	push	r9
    2c06:	af 92       	push	r10
    2c08:	bf 92       	push	r11
    2c0a:	cf 92       	push	r12
    2c0c:	df 92       	push	r13
    2c0e:	ef 92       	push	r14
    2c10:	ff 92       	push	r15
    2c12:	0f 93       	push	r16
    2c14:	1f 93       	push	r17
    2c16:	2f 93       	push	r18
    2c18:	3f 93       	push	r19
    2c1a:	4f 93       	push	r20
    2c1c:	5f 93       	push	r21
    2c1e:	6f 93       	push	r22
    2c20:	7f 93       	push	r23
    2c22:	8f 93       	push	r24
    2c24:	9f 93       	push	r25
    2c26:	af 93       	push	r26
    2c28:	bf 93       	push	r27
    2c2a:	cf 93       	push	r28
    2c2c:	df 93       	push	r29
    2c2e:	ef 93       	push	r30
    2c30:	ff 93       	push	r31
    2c32:	a0 91 92 06 	lds	r26, 0x0692
    2c36:	b0 91 93 06 	lds	r27, 0x0693
    2c3a:	0d b6       	in	r0, 0x3d	; 61
    2c3c:	0d 92       	st	X+, r0
    2c3e:	0e b6       	in	r0, 0x3e	; 62
    2c40:	0d 92       	st	X+, r0
	vTaskIncrementTick();
    2c42:	0e 94 37 1e 	call	0x3c6e	; 0x3c6e <vTaskIncrementTick>
	vTaskSwitchContext();
    2c46:	0e 94 0c 1f 	call	0x3e18	; 0x3e18 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    2c4a:	a0 91 92 06 	lds	r26, 0x0692
    2c4e:	b0 91 93 06 	lds	r27, 0x0693
    2c52:	cd 91       	ld	r28, X+
    2c54:	cd bf       	out	0x3d, r28	; 61
    2c56:	dd 91       	ld	r29, X+
    2c58:	de bf       	out	0x3e, r29	; 62
    2c5a:	ff 91       	pop	r31
    2c5c:	ef 91       	pop	r30
    2c5e:	df 91       	pop	r29
    2c60:	cf 91       	pop	r28
    2c62:	bf 91       	pop	r27
    2c64:	af 91       	pop	r26
    2c66:	9f 91       	pop	r25
    2c68:	8f 91       	pop	r24
    2c6a:	7f 91       	pop	r23
    2c6c:	6f 91       	pop	r22
    2c6e:	5f 91       	pop	r21
    2c70:	4f 91       	pop	r20
    2c72:	3f 91       	pop	r19
    2c74:	2f 91       	pop	r18
    2c76:	1f 91       	pop	r17
    2c78:	0f 91       	pop	r16
    2c7a:	ff 90       	pop	r15
    2c7c:	ef 90       	pop	r14
    2c7e:	df 90       	pop	r13
    2c80:	cf 90       	pop	r12
    2c82:	bf 90       	pop	r11
    2c84:	af 90       	pop	r10
    2c86:	9f 90       	pop	r9
    2c88:	8f 90       	pop	r8
    2c8a:	7f 90       	pop	r7
    2c8c:	6f 90       	pop	r6
    2c8e:	5f 90       	pop	r5
    2c90:	4f 90       	pop	r4
    2c92:	3f 90       	pop	r3
    2c94:	2f 90       	pop	r2
    2c96:	1f 90       	pop	r1
    2c98:	0f 90       	pop	r0
    2c9a:	0f be       	out	0x3f, r0	; 63
    2c9c:	0f 90       	pop	r0

	asm volatile ( "ret" );
    2c9e:	08 95       	ret

00002ca0 <prvSetupTimerInterrupt>:

/*
 * Setup timer 1 compare match A to generate a tick interrupt.
 */
static void prvSetupTimerInterrupt( void )
{
    2ca0:	df 93       	push	r29
    2ca2:	cf 93       	push	r28
    2ca4:	00 d0       	rcall	.+0      	; 0x2ca6 <prvSetupTimerInterrupt+0x6>
    2ca6:	00 d0       	rcall	.+0      	; 0x2ca8 <prvSetupTimerInterrupt+0x8>
    2ca8:	00 d0       	rcall	.+0      	; 0x2caa <prvSetupTimerInterrupt+0xa>
    2caa:	cd b7       	in	r28, 0x3d	; 61
    2cac:	de b7       	in	r29, 0x3e	; 62
unsigned char ucHighByte, ucLowByte;

	/* Using 16bit timer 1 to generate the tick.  Correct fuses must be
	selected for the configCPU_CLOCK_HZ clock. */

	ulCompareMatch = configCPU_CLOCK_HZ / configTICK_RATE_HZ;
    2cae:	80 e4       	ldi	r24, 0x40	; 64
    2cb0:	9f e1       	ldi	r25, 0x1F	; 31
    2cb2:	a0 e0       	ldi	r26, 0x00	; 0
    2cb4:	b0 e0       	ldi	r27, 0x00	; 0
    2cb6:	8b 83       	std	Y+3, r24	; 0x03
    2cb8:	9c 83       	std	Y+4, r25	; 0x04
    2cba:	ad 83       	std	Y+5, r26	; 0x05
    2cbc:	be 83       	std	Y+6, r27	; 0x06

	/* We only have 16 bits so have to scale to get our required tick rate. */
	ulCompareMatch /= portCLOCK_PRESCALER;
    2cbe:	8b 81       	ldd	r24, Y+3	; 0x03
    2cc0:	9c 81       	ldd	r25, Y+4	; 0x04
    2cc2:	ad 81       	ldd	r26, Y+5	; 0x05
    2cc4:	be 81       	ldd	r27, Y+6	; 0x06
    2cc6:	68 94       	set
    2cc8:	15 f8       	bld	r1, 5
    2cca:	b6 95       	lsr	r27
    2ccc:	a7 95       	ror	r26
    2cce:	97 95       	ror	r25
    2cd0:	87 95       	ror	r24
    2cd2:	16 94       	lsr	r1
    2cd4:	d1 f7       	brne	.-12     	; 0x2cca <prvSetupTimerInterrupt+0x2a>
    2cd6:	8b 83       	std	Y+3, r24	; 0x03
    2cd8:	9c 83       	std	Y+4, r25	; 0x04
    2cda:	ad 83       	std	Y+5, r26	; 0x05
    2cdc:	be 83       	std	Y+6, r27	; 0x06

	/* Adjust for correct value. */
	ulCompareMatch -= ( unsigned long ) 1;
    2cde:	8b 81       	ldd	r24, Y+3	; 0x03
    2ce0:	9c 81       	ldd	r25, Y+4	; 0x04
    2ce2:	ad 81       	ldd	r26, Y+5	; 0x05
    2ce4:	be 81       	ldd	r27, Y+6	; 0x06
    2ce6:	01 97       	sbiw	r24, 0x01	; 1
    2ce8:	a1 09       	sbc	r26, r1
    2cea:	b1 09       	sbc	r27, r1
    2cec:	8b 83       	std	Y+3, r24	; 0x03
    2cee:	9c 83       	std	Y+4, r25	; 0x04
    2cf0:	ad 83       	std	Y+5, r26	; 0x05
    2cf2:	be 83       	std	Y+6, r27	; 0x06

	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( unsigned char ) ( ulCompareMatch & ( unsigned long ) 0xff );
    2cf4:	8b 81       	ldd	r24, Y+3	; 0x03
    2cf6:	89 83       	std	Y+1, r24	; 0x01
	ulCompareMatch >>= 8;
    2cf8:	8b 81       	ldd	r24, Y+3	; 0x03
    2cfa:	9c 81       	ldd	r25, Y+4	; 0x04
    2cfc:	ad 81       	ldd	r26, Y+5	; 0x05
    2cfe:	be 81       	ldd	r27, Y+6	; 0x06
    2d00:	89 2f       	mov	r24, r25
    2d02:	9a 2f       	mov	r25, r26
    2d04:	ab 2f       	mov	r26, r27
    2d06:	bb 27       	eor	r27, r27
    2d08:	8b 83       	std	Y+3, r24	; 0x03
    2d0a:	9c 83       	std	Y+4, r25	; 0x04
    2d0c:	ad 83       	std	Y+5, r26	; 0x05
    2d0e:	be 83       	std	Y+6, r27	; 0x06
	ucHighByte = ( unsigned char ) ( ulCompareMatch & ( unsigned long ) 0xff );
    2d10:	8b 81       	ldd	r24, Y+3	; 0x03
    2d12:	8a 83       	std	Y+2, r24	; 0x02
	OCR1AH = ucHighByte;
    2d14:	eb e4       	ldi	r30, 0x4B	; 75
    2d16:	f0 e0       	ldi	r31, 0x00	; 0
    2d18:	8a 81       	ldd	r24, Y+2	; 0x02
    2d1a:	80 83       	st	Z, r24
	OCR1AL = ucLowByte;
    2d1c:	ea e4       	ldi	r30, 0x4A	; 74
    2d1e:	f0 e0       	ldi	r31, 0x00	; 0
    2d20:	89 81       	ldd	r24, Y+1	; 0x01
    2d22:	80 83       	st	Z, r24

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
    2d24:	8b e0       	ldi	r24, 0x0B	; 11
    2d26:	89 83       	std	Y+1, r24	; 0x01
	TCCR1B = ucLowByte;
    2d28:	ee e4       	ldi	r30, 0x4E	; 78
    2d2a:	f0 e0       	ldi	r31, 0x00	; 0
    2d2c:	89 81       	ldd	r24, Y+1	; 0x01
    2d2e:	80 83       	st	Z, r24

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK;
    2d30:	e9 e5       	ldi	r30, 0x59	; 89
    2d32:	f0 e0       	ldi	r31, 0x00	; 0
    2d34:	80 81       	ld	r24, Z
    2d36:	89 83       	std	Y+1, r24	; 0x01
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
    2d38:	89 81       	ldd	r24, Y+1	; 0x01
    2d3a:	80 61       	ori	r24, 0x10	; 16
    2d3c:	89 83       	std	Y+1, r24	; 0x01
	TIMSK = ucLowByte;
    2d3e:	e9 e5       	ldi	r30, 0x59	; 89
    2d40:	f0 e0       	ldi	r31, 0x00	; 0
    2d42:	89 81       	ldd	r24, Y+1	; 0x01
    2d44:	80 83       	st	Z, r24
}
    2d46:	26 96       	adiw	r28, 0x06	; 6
    2d48:	0f b6       	in	r0, 0x3f	; 63
    2d4a:	f8 94       	cli
    2d4c:	de bf       	out	0x3e, r29	; 62
    2d4e:	0f be       	out	0x3f, r0	; 63
    2d50:	cd bf       	out	0x3d, r28	; 61
    2d52:	cf 91       	pop	r28
    2d54:	df 91       	pop	r29
    2d56:	08 95       	ret

00002d58 <__vector_7>:
	 * count is incremented after the context is saved.
	 */
void __vector_7( void ) __attribute__ ( ( signal, naked ) );
void __vector_7( void )
	{
		vPortYieldFromTick();
    2d58:	0e 94 f5 15 	call	0x2bea	; 0x2bea <vPortYieldFromTick>
		asm volatile ( "reti" );
    2d5c:	18 95       	reti

00002d5e <xQueueCreate>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
{
    2d5e:	df 93       	push	r29
    2d60:	cf 93       	push	r28
    2d62:	cd b7       	in	r28, 0x3d	; 61
    2d64:	de b7       	in	r29, 0x3e	; 62
    2d66:	28 97       	sbiw	r28, 0x08	; 8
    2d68:	0f b6       	in	r0, 0x3f	; 63
    2d6a:	f8 94       	cli
    2d6c:	de bf       	out	0x3e, r29	; 62
    2d6e:	0f be       	out	0x3f, r0	; 63
    2d70:	cd bf       	out	0x3d, r28	; 61
    2d72:	8f 83       	std	Y+7, r24	; 0x07
    2d74:	68 87       	std	Y+8, r22	; 0x08
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;
    2d76:	1a 82       	std	Y+2, r1	; 0x02
    2d78:	19 82       	std	Y+1, r1	; 0x01

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
    2d7a:	8f 81       	ldd	r24, Y+7	; 0x07
    2d7c:	88 23       	and	r24, r24
    2d7e:	09 f4       	brne	.+2      	; 0x2d82 <xQueueCreate+0x24>
    2d80:	8c c0       	rjmp	.+280    	; 0x2e9a <xQueueCreate+0x13c>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
    2d82:	8f e1       	ldi	r24, 0x1F	; 31
    2d84:	90 e0       	ldi	r25, 0x00	; 0
    2d86:	0e 94 36 12 	call	0x246c	; 0x246c <pvPortMalloc>
    2d8a:	9e 83       	std	Y+6, r25	; 0x06
    2d8c:	8d 83       	std	Y+5, r24	; 0x05
		if( pxNewQueue != NULL )
    2d8e:	8d 81       	ldd	r24, Y+5	; 0x05
    2d90:	9e 81       	ldd	r25, Y+6	; 0x06
    2d92:	00 97       	sbiw	r24, 0x00	; 0
    2d94:	09 f4       	brne	.+2      	; 0x2d98 <xQueueCreate+0x3a>
    2d96:	81 c0       	rjmp	.+258    	; 0x2e9a <xQueueCreate+0x13c>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
    2d98:	8f 81       	ldd	r24, Y+7	; 0x07
    2d9a:	28 2f       	mov	r18, r24
    2d9c:	30 e0       	ldi	r19, 0x00	; 0
    2d9e:	88 85       	ldd	r24, Y+8	; 0x08
    2da0:	88 2f       	mov	r24, r24
    2da2:	90 e0       	ldi	r25, 0x00	; 0
    2da4:	ac 01       	movw	r20, r24
    2da6:	24 9f       	mul	r18, r20
    2da8:	c0 01       	movw	r24, r0
    2daa:	25 9f       	mul	r18, r21
    2dac:	90 0d       	add	r25, r0
    2dae:	34 9f       	mul	r19, r20
    2db0:	90 0d       	add	r25, r0
    2db2:	11 24       	eor	r1, r1
    2db4:	01 96       	adiw	r24, 0x01	; 1
    2db6:	9c 83       	std	Y+4, r25	; 0x04
    2db8:	8b 83       	std	Y+3, r24	; 0x03

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
    2dba:	8b 81       	ldd	r24, Y+3	; 0x03
    2dbc:	9c 81       	ldd	r25, Y+4	; 0x04
    2dbe:	0e 94 36 12 	call	0x246c	; 0x246c <pvPortMalloc>
    2dc2:	ed 81       	ldd	r30, Y+5	; 0x05
    2dc4:	fe 81       	ldd	r31, Y+6	; 0x06
    2dc6:	91 83       	std	Z+1, r25	; 0x01
    2dc8:	80 83       	st	Z, r24
			if( pxNewQueue->pcHead != NULL )
    2dca:	ed 81       	ldd	r30, Y+5	; 0x05
    2dcc:	fe 81       	ldd	r31, Y+6	; 0x06
    2dce:	80 81       	ld	r24, Z
    2dd0:	91 81       	ldd	r25, Z+1	; 0x01
    2dd2:	00 97       	sbiw	r24, 0x00	; 0
    2dd4:	09 f4       	brne	.+2      	; 0x2dd8 <xQueueCreate+0x7a>
    2dd6:	5d c0       	rjmp	.+186    	; 0x2e92 <xQueueCreate+0x134>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
    2dd8:	ed 81       	ldd	r30, Y+5	; 0x05
    2dda:	fe 81       	ldd	r31, Y+6	; 0x06
    2ddc:	40 81       	ld	r20, Z
    2dde:	51 81       	ldd	r21, Z+1	; 0x01
    2de0:	8f 81       	ldd	r24, Y+7	; 0x07
    2de2:	28 2f       	mov	r18, r24
    2de4:	30 e0       	ldi	r19, 0x00	; 0
    2de6:	88 85       	ldd	r24, Y+8	; 0x08
    2de8:	88 2f       	mov	r24, r24
    2dea:	90 e0       	ldi	r25, 0x00	; 0
    2dec:	bc 01       	movw	r22, r24
    2dee:	26 9f       	mul	r18, r22
    2df0:	c0 01       	movw	r24, r0
    2df2:	27 9f       	mul	r18, r23
    2df4:	90 0d       	add	r25, r0
    2df6:	36 9f       	mul	r19, r22
    2df8:	90 0d       	add	r25, r0
    2dfa:	11 24       	eor	r1, r1
    2dfc:	84 0f       	add	r24, r20
    2dfe:	95 1f       	adc	r25, r21
    2e00:	ed 81       	ldd	r30, Y+5	; 0x05
    2e02:	fe 81       	ldd	r31, Y+6	; 0x06
    2e04:	93 83       	std	Z+3, r25	; 0x03
    2e06:	82 83       	std	Z+2, r24	; 0x02
				pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
    2e08:	ed 81       	ldd	r30, Y+5	; 0x05
    2e0a:	fe 81       	ldd	r31, Y+6	; 0x06
    2e0c:	12 8e       	std	Z+26, r1	; 0x1a
				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
    2e0e:	ed 81       	ldd	r30, Y+5	; 0x05
    2e10:	fe 81       	ldd	r31, Y+6	; 0x06
    2e12:	80 81       	ld	r24, Z
    2e14:	91 81       	ldd	r25, Z+1	; 0x01
    2e16:	ed 81       	ldd	r30, Y+5	; 0x05
    2e18:	fe 81       	ldd	r31, Y+6	; 0x06
    2e1a:	95 83       	std	Z+5, r25	; 0x05
    2e1c:	84 83       	std	Z+4, r24	; 0x04
				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - ( unsigned portBASE_TYPE ) 1U ) * uxItemSize );
    2e1e:	ed 81       	ldd	r30, Y+5	; 0x05
    2e20:	fe 81       	ldd	r31, Y+6	; 0x06
    2e22:	40 81       	ld	r20, Z
    2e24:	51 81       	ldd	r21, Z+1	; 0x01
    2e26:	8f 81       	ldd	r24, Y+7	; 0x07
    2e28:	88 2f       	mov	r24, r24
    2e2a:	90 e0       	ldi	r25, 0x00	; 0
    2e2c:	9c 01       	movw	r18, r24
    2e2e:	21 50       	subi	r18, 0x01	; 1
    2e30:	30 40       	sbci	r19, 0x00	; 0
    2e32:	88 85       	ldd	r24, Y+8	; 0x08
    2e34:	88 2f       	mov	r24, r24
    2e36:	90 e0       	ldi	r25, 0x00	; 0
    2e38:	bc 01       	movw	r22, r24
    2e3a:	26 9f       	mul	r18, r22
    2e3c:	c0 01       	movw	r24, r0
    2e3e:	27 9f       	mul	r18, r23
    2e40:	90 0d       	add	r25, r0
    2e42:	36 9f       	mul	r19, r22
    2e44:	90 0d       	add	r25, r0
    2e46:	11 24       	eor	r1, r1
    2e48:	84 0f       	add	r24, r20
    2e4a:	95 1f       	adc	r25, r21
    2e4c:	ed 81       	ldd	r30, Y+5	; 0x05
    2e4e:	fe 81       	ldd	r31, Y+6	; 0x06
    2e50:	97 83       	std	Z+7, r25	; 0x07
    2e52:	86 83       	std	Z+6, r24	; 0x06
				pxNewQueue->uxLength = uxQueueLength;
    2e54:	ed 81       	ldd	r30, Y+5	; 0x05
    2e56:	fe 81       	ldd	r31, Y+6	; 0x06
    2e58:	8f 81       	ldd	r24, Y+7	; 0x07
    2e5a:	83 8f       	std	Z+27, r24	; 0x1b
				pxNewQueue->uxItemSize = uxItemSize;
    2e5c:	ed 81       	ldd	r30, Y+5	; 0x05
    2e5e:	fe 81       	ldd	r31, Y+6	; 0x06
    2e60:	88 85       	ldd	r24, Y+8	; 0x08
    2e62:	84 8f       	std	Z+28, r24	; 0x1c
				pxNewQueue->xRxLock = queueUNLOCKED;
    2e64:	ed 81       	ldd	r30, Y+5	; 0x05
    2e66:	fe 81       	ldd	r31, Y+6	; 0x06
    2e68:	8f ef       	ldi	r24, 0xFF	; 255
    2e6a:	85 8f       	std	Z+29, r24	; 0x1d
				pxNewQueue->xTxLock = queueUNLOCKED;
    2e6c:	ed 81       	ldd	r30, Y+5	; 0x05
    2e6e:	fe 81       	ldd	r31, Y+6	; 0x06
    2e70:	8f ef       	ldi	r24, 0xFF	; 255
    2e72:	86 8f       	std	Z+30, r24	; 0x1e

				/* Likewise ensure the event queues start with the correct state. */
				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
    2e74:	8d 81       	ldd	r24, Y+5	; 0x05
    2e76:	9e 81       	ldd	r25, Y+6	; 0x06
    2e78:	08 96       	adiw	r24, 0x08	; 8
    2e7a:	0e 94 a2 12 	call	0x2544	; 0x2544 <vListInitialise>
				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
    2e7e:	8d 81       	ldd	r24, Y+5	; 0x05
    2e80:	9e 81       	ldd	r25, Y+6	; 0x06
    2e82:	41 96       	adiw	r24, 0x11	; 17
    2e84:	0e 94 a2 12 	call	0x2544	; 0x2544 <vListInitialise>

				traceQUEUE_CREATE( pxNewQueue );
				xReturn = pxNewQueue;
    2e88:	8d 81       	ldd	r24, Y+5	; 0x05
    2e8a:	9e 81       	ldd	r25, Y+6	; 0x06
    2e8c:	9a 83       	std	Y+2, r25	; 0x02
    2e8e:	89 83       	std	Y+1, r24	; 0x01
    2e90:	04 c0       	rjmp	.+8      	; 0x2e9a <xQueueCreate+0x13c>
			}
			else
			{
				traceQUEUE_CREATE_FAILED();
				vPortFree( pxNewQueue );
    2e92:	8d 81       	ldd	r24, Y+5	; 0x05
    2e94:	9e 81       	ldd	r25, Y+6	; 0x06
    2e96:	0e 94 7c 12 	call	0x24f8	; 0x24f8 <vPortFree>
		}
	}

	configASSERT( xReturn );

	return xReturn;
    2e9a:	89 81       	ldd	r24, Y+1	; 0x01
    2e9c:	9a 81       	ldd	r25, Y+2	; 0x02
}
    2e9e:	28 96       	adiw	r28, 0x08	; 8
    2ea0:	0f b6       	in	r0, 0x3f	; 63
    2ea2:	f8 94       	cli
    2ea4:	de bf       	out	0x3e, r29	; 62
    2ea6:	0f be       	out	0x3f, r0	; 63
    2ea8:	cd bf       	out	0x3d, r28	; 61
    2eaa:	cf 91       	pop	r28
    2eac:	df 91       	pop	r29
    2eae:	08 95       	ret

00002eb0 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
    2eb0:	df 93       	push	r29
    2eb2:	cf 93       	push	r28
    2eb4:	cd b7       	in	r28, 0x3d	; 61
    2eb6:	de b7       	in	r29, 0x3e	; 62
    2eb8:	2c 97       	sbiw	r28, 0x0c	; 12
    2eba:	0f b6       	in	r0, 0x3f	; 63
    2ebc:	f8 94       	cli
    2ebe:	de bf       	out	0x3e, r29	; 62
    2ec0:	0f be       	out	0x3f, r0	; 63
    2ec2:	cd bf       	out	0x3d, r28	; 61
    2ec4:	9e 83       	std	Y+6, r25	; 0x06
    2ec6:	8d 83       	std	Y+5, r24	; 0x05
    2ec8:	78 87       	std	Y+8, r23	; 0x08
    2eca:	6f 83       	std	Y+7, r22	; 0x07
    2ecc:	5a 87       	std	Y+10, r21	; 0x0a
    2ece:	49 87       	std	Y+9, r20	; 0x09
    2ed0:	2b 87       	std	Y+11, r18	; 0x0b
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
    2ed2:	19 82       	std	Y+1, r1	; 0x01
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    2ed4:	0f b6       	in	r0, 0x3f	; 63
    2ed6:	f8 94       	cli
    2ed8:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    2eda:	ed 81       	ldd	r30, Y+5	; 0x05
    2edc:	fe 81       	ldd	r31, Y+6	; 0x06
    2ede:	92 8d       	ldd	r25, Z+26	; 0x1a
    2ee0:	ed 81       	ldd	r30, Y+5	; 0x05
    2ee2:	fe 81       	ldd	r31, Y+6	; 0x06
    2ee4:	83 8d       	ldd	r24, Z+27	; 0x1b
    2ee6:	98 17       	cp	r25, r24
    2ee8:	d8 f4       	brcc	.+54     	; 0x2f20 <xQueueGenericSend+0x70>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    2eea:	8d 81       	ldd	r24, Y+5	; 0x05
    2eec:	9e 81       	ldd	r25, Y+6	; 0x06
    2eee:	2f 81       	ldd	r18, Y+7	; 0x07
    2ef0:	38 85       	ldd	r19, Y+8	; 0x08
    2ef2:	b9 01       	movw	r22, r18
    2ef4:	4b 85       	ldd	r20, Y+11	; 0x0b
    2ef6:	0e 94 93 19 	call	0x3326	; 0x3326 <prvCopyDataToQueue>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    2efa:	ed 81       	ldd	r30, Y+5	; 0x05
    2efc:	fe 81       	ldd	r31, Y+6	; 0x06
    2efe:	81 89       	ldd	r24, Z+17	; 0x11
    2f00:	88 23       	and	r24, r24
    2f02:	49 f0       	breq	.+18     	; 0x2f16 <xQueueGenericSend+0x66>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
    2f04:	8d 81       	ldd	r24, Y+5	; 0x05
    2f06:	9e 81       	ldd	r25, Y+6	; 0x06
    2f08:	41 96       	adiw	r24, 0x11	; 17
    2f0a:	0e 94 a8 1f 	call	0x3f50	; 0x3f50 <xTaskRemoveFromEventList>
    2f0e:	81 30       	cpi	r24, 0x01	; 1
    2f10:	11 f4       	brne	.+4      	; 0x2f16 <xQueueGenericSend+0x66>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
    2f12:	0e 94 9c 15 	call	0x2b38	; 0x2b38 <vPortYield>
					}
				}

				taskEXIT_CRITICAL();
    2f16:	0f 90       	pop	r0
    2f18:	0f be       	out	0x3f, r0	; 63

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
    2f1a:	81 e0       	ldi	r24, 0x01	; 1
    2f1c:	8c 87       	std	Y+12, r24	; 0x0c
    2f1e:	5c c0       	rjmp	.+184    	; 0x2fd8 <xQueueGenericSend+0x128>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    2f20:	89 85       	ldd	r24, Y+9	; 0x09
    2f22:	9a 85       	ldd	r25, Y+10	; 0x0a
    2f24:	00 97       	sbiw	r24, 0x00	; 0
    2f26:	21 f4       	brne	.+8      	; 0x2f30 <xQueueGenericSend+0x80>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    2f28:	0f 90       	pop	r0
    2f2a:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
    2f2c:	1c 86       	std	Y+12, r1	; 0x0c
    2f2e:	54 c0       	rjmp	.+168    	; 0x2fd8 <xQueueGenericSend+0x128>
				}
				else if( xEntryTimeSet == pdFALSE )
    2f30:	89 81       	ldd	r24, Y+1	; 0x01
    2f32:	88 23       	and	r24, r24
    2f34:	31 f4       	brne	.+12     	; 0x2f42 <xQueueGenericSend+0x92>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    2f36:	ce 01       	movw	r24, r28
    2f38:	02 96       	adiw	r24, 0x02	; 2
    2f3a:	0e 94 10 20 	call	0x4020	; 0x4020 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    2f3e:	81 e0       	ldi	r24, 0x01	; 1
    2f40:	89 83       	std	Y+1, r24	; 0x01
				}
			}
		}
		taskEXIT_CRITICAL();
    2f42:	0f 90       	pop	r0
    2f44:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    2f46:	0e 94 6c 1d 	call	0x3ad8	; 0x3ad8 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    2f4a:	0f b6       	in	r0, 0x3f	; 63
    2f4c:	f8 94       	cli
    2f4e:	0f 92       	push	r0
    2f50:	ed 81       	ldd	r30, Y+5	; 0x05
    2f52:	fe 81       	ldd	r31, Y+6	; 0x06
    2f54:	85 8d       	ldd	r24, Z+29	; 0x1d
    2f56:	8f 3f       	cpi	r24, 0xFF	; 255
    2f58:	19 f4       	brne	.+6      	; 0x2f60 <xQueueGenericSend+0xb0>
    2f5a:	ed 81       	ldd	r30, Y+5	; 0x05
    2f5c:	fe 81       	ldd	r31, Y+6	; 0x06
    2f5e:	15 8e       	std	Z+29, r1	; 0x1d
    2f60:	ed 81       	ldd	r30, Y+5	; 0x05
    2f62:	fe 81       	ldd	r31, Y+6	; 0x06
    2f64:	86 8d       	ldd	r24, Z+30	; 0x1e
    2f66:	8f 3f       	cpi	r24, 0xFF	; 255
    2f68:	19 f4       	brne	.+6      	; 0x2f70 <xQueueGenericSend+0xc0>
    2f6a:	ed 81       	ldd	r30, Y+5	; 0x05
    2f6c:	fe 81       	ldd	r31, Y+6	; 0x06
    2f6e:	16 8e       	std	Z+30, r1	; 0x1e
    2f70:	0f 90       	pop	r0
    2f72:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    2f74:	ce 01       	movw	r24, r28
    2f76:	02 96       	adiw	r24, 0x02	; 2
    2f78:	9e 01       	movw	r18, r28
    2f7a:	27 5f       	subi	r18, 0xF7	; 247
    2f7c:	3f 4f       	sbci	r19, 0xFF	; 255
    2f7e:	b9 01       	movw	r22, r18
    2f80:	0e 94 29 20 	call	0x4052	; 0x4052 <xTaskCheckForTimeOut>
    2f84:	88 23       	and	r24, r24
    2f86:	09 f5       	brne	.+66     	; 0x2fca <xQueueGenericSend+0x11a>
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    2f88:	8d 81       	ldd	r24, Y+5	; 0x05
    2f8a:	9e 81       	ldd	r25, Y+6	; 0x06
    2f8c:	0e 94 f7 1a 	call	0x35ee	; 0x35ee <prvIsQueueFull>
    2f90:	88 23       	and	r24, r24
    2f92:	a1 f0       	breq	.+40     	; 0x2fbc <xQueueGenericSend+0x10c>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    2f94:	8d 81       	ldd	r24, Y+5	; 0x05
    2f96:	9e 81       	ldd	r25, Y+6	; 0x06
    2f98:	08 96       	adiw	r24, 0x08	; 8
    2f9a:	29 85       	ldd	r18, Y+9	; 0x09
    2f9c:	3a 85       	ldd	r19, Y+10	; 0x0a
    2f9e:	b9 01       	movw	r22, r18
    2fa0:	0e 94 72 1f 	call	0x3ee4	; 0x3ee4 <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    2fa4:	8d 81       	ldd	r24, Y+5	; 0x05
    2fa6:	9e 81       	ldd	r25, Y+6	; 0x06
    2fa8:	0e 94 70 1a 	call	0x34e0	; 0x34e0 <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    2fac:	0e 94 78 1d 	call	0x3af0	; 0x3af0 <xTaskResumeAll>
    2fb0:	88 23       	and	r24, r24
    2fb2:	09 f0       	breq	.+2      	; 0x2fb6 <xQueueGenericSend+0x106>
    2fb4:	8f cf       	rjmp	.-226    	; 0x2ed4 <xQueueGenericSend+0x24>
				{
					portYIELD_WITHIN_API();
    2fb6:	0e 94 9c 15 	call	0x2b38	; 0x2b38 <vPortYield>
    2fba:	8c cf       	rjmp	.-232    	; 0x2ed4 <xQueueGenericSend+0x24>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    2fbc:	8d 81       	ldd	r24, Y+5	; 0x05
    2fbe:	9e 81       	ldd	r25, Y+6	; 0x06
    2fc0:	0e 94 70 1a 	call	0x34e0	; 0x34e0 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    2fc4:	0e 94 78 1d 	call	0x3af0	; 0x3af0 <xTaskResumeAll>
    2fc8:	85 cf       	rjmp	.-246    	; 0x2ed4 <xQueueGenericSend+0x24>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    2fca:	8d 81       	ldd	r24, Y+5	; 0x05
    2fcc:	9e 81       	ldd	r25, Y+6	; 0x06
    2fce:	0e 94 70 1a 	call	0x34e0	; 0x34e0 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    2fd2:	0e 94 78 1d 	call	0x3af0	; 0x3af0 <xTaskResumeAll>

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    2fd6:	1c 86       	std	Y+12, r1	; 0x0c
    2fd8:	8c 85       	ldd	r24, Y+12	; 0x0c
		}
	}
}
    2fda:	2c 96       	adiw	r28, 0x0c	; 12
    2fdc:	0f b6       	in	r0, 0x3f	; 63
    2fde:	f8 94       	cli
    2fe0:	de bf       	out	0x3e, r29	; 62
    2fe2:	0f be       	out	0x3f, r0	; 63
    2fe4:	cd bf       	out	0x3d, r28	; 61
    2fe6:	cf 91       	pop	r28
    2fe8:	df 91       	pop	r29
    2fea:	08 95       	ret

00002fec <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
    2fec:	df 93       	push	r29
    2fee:	cf 93       	push	r28
    2ff0:	cd b7       	in	r28, 0x3d	; 61
    2ff2:	de b7       	in	r29, 0x3e	; 62
    2ff4:	29 97       	sbiw	r28, 0x09	; 9
    2ff6:	0f b6       	in	r0, 0x3f	; 63
    2ff8:	f8 94       	cli
    2ffa:	de bf       	out	0x3e, r29	; 62
    2ffc:	0f be       	out	0x3f, r0	; 63
    2ffe:	cd bf       	out	0x3d, r28	; 61
    3000:	9c 83       	std	Y+4, r25	; 0x04
    3002:	8b 83       	std	Y+3, r24	; 0x03
    3004:	7e 83       	std	Y+6, r23	; 0x06
    3006:	6d 83       	std	Y+5, r22	; 0x05
    3008:	58 87       	std	Y+8, r21	; 0x08
    300a:	4f 83       	std	Y+7, r20	; 0x07
    300c:	29 87       	std	Y+9, r18	; 0x09
	/* Similar to xQueueGenericSend, except we don't block if there is no room
	in the queue.  Also we don't directly wake a task that was blocked on a
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    300e:	19 82       	std	Y+1, r1	; 0x01
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    3010:	eb 81       	ldd	r30, Y+3	; 0x03
    3012:	fc 81       	ldd	r31, Y+4	; 0x04
    3014:	92 8d       	ldd	r25, Z+26	; 0x1a
    3016:	eb 81       	ldd	r30, Y+3	; 0x03
    3018:	fc 81       	ldd	r31, Y+4	; 0x04
    301a:	83 8d       	ldd	r24, Z+27	; 0x1b
    301c:	98 17       	cp	r25, r24
    301e:	40 f5       	brcc	.+80     	; 0x3070 <xQueueGenericSendFromISR+0x84>
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    3020:	8b 81       	ldd	r24, Y+3	; 0x03
    3022:	9c 81       	ldd	r25, Y+4	; 0x04
    3024:	2d 81       	ldd	r18, Y+5	; 0x05
    3026:	3e 81       	ldd	r19, Y+6	; 0x06
    3028:	b9 01       	movw	r22, r18
    302a:	49 85       	ldd	r20, Y+9	; 0x09
    302c:	0e 94 93 19 	call	0x3326	; 0x3326 <prvCopyDataToQueue>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
    3030:	eb 81       	ldd	r30, Y+3	; 0x03
    3032:	fc 81       	ldd	r31, Y+4	; 0x04
    3034:	86 8d       	ldd	r24, Z+30	; 0x1e
    3036:	8f 3f       	cpi	r24, 0xFF	; 255
    3038:	89 f4       	brne	.+34     	; 0x305c <xQueueGenericSendFromISR+0x70>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    303a:	eb 81       	ldd	r30, Y+3	; 0x03
    303c:	fc 81       	ldd	r31, Y+4	; 0x04
    303e:	81 89       	ldd	r24, Z+17	; 0x11
    3040:	88 23       	and	r24, r24
    3042:	99 f0       	breq	.+38     	; 0x306a <xQueueGenericSendFromISR+0x7e>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    3044:	8b 81       	ldd	r24, Y+3	; 0x03
    3046:	9c 81       	ldd	r25, Y+4	; 0x04
    3048:	41 96       	adiw	r24, 0x11	; 17
    304a:	0e 94 a8 1f 	call	0x3f50	; 0x3f50 <xTaskRemoveFromEventList>
    304e:	88 23       	and	r24, r24
    3050:	61 f0       	breq	.+24     	; 0x306a <xQueueGenericSendFromISR+0x7e>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						*pxHigherPriorityTaskWoken = pdTRUE;
    3052:	ef 81       	ldd	r30, Y+7	; 0x07
    3054:	f8 85       	ldd	r31, Y+8	; 0x08
    3056:	81 e0       	ldi	r24, 0x01	; 1
    3058:	80 83       	st	Z, r24
    305a:	07 c0       	rjmp	.+14     	; 0x306a <xQueueGenericSendFromISR+0x7e>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    305c:	eb 81       	ldd	r30, Y+3	; 0x03
    305e:	fc 81       	ldd	r31, Y+4	; 0x04
    3060:	86 8d       	ldd	r24, Z+30	; 0x1e
    3062:	8f 5f       	subi	r24, 0xFF	; 255
    3064:	eb 81       	ldd	r30, Y+3	; 0x03
    3066:	fc 81       	ldd	r31, Y+4	; 0x04
    3068:	86 8f       	std	Z+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    306a:	81 e0       	ldi	r24, 0x01	; 1
    306c:	8a 83       	std	Y+2, r24	; 0x02
    306e:	01 c0       	rjmp	.+2      	; 0x3072 <xQueueGenericSendFromISR+0x86>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    3070:	1a 82       	std	Y+2, r1	; 0x02
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    3072:	8a 81       	ldd	r24, Y+2	; 0x02
}
    3074:	29 96       	adiw	r28, 0x09	; 9
    3076:	0f b6       	in	r0, 0x3f	; 63
    3078:	f8 94       	cli
    307a:	de bf       	out	0x3e, r29	; 62
    307c:	0f be       	out	0x3f, r0	; 63
    307e:	cd bf       	out	0x3d, r28	; 61
    3080:	cf 91       	pop	r28
    3082:	df 91       	pop	r29
    3084:	08 95       	ret

00003086 <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
    3086:	df 93       	push	r29
    3088:	cf 93       	push	r28
    308a:	cd b7       	in	r28, 0x3d	; 61
    308c:	de b7       	in	r29, 0x3e	; 62
    308e:	2e 97       	sbiw	r28, 0x0e	; 14
    3090:	0f b6       	in	r0, 0x3f	; 63
    3092:	f8 94       	cli
    3094:	de bf       	out	0x3e, r29	; 62
    3096:	0f be       	out	0x3f, r0	; 63
    3098:	cd bf       	out	0x3d, r28	; 61
    309a:	98 87       	std	Y+8, r25	; 0x08
    309c:	8f 83       	std	Y+7, r24	; 0x07
    309e:	7a 87       	std	Y+10, r23	; 0x0a
    30a0:	69 87       	std	Y+9, r22	; 0x09
    30a2:	5c 87       	std	Y+12, r21	; 0x0c
    30a4:	4b 87       	std	Y+11, r20	; 0x0b
    30a6:	2d 87       	std	Y+13, r18	; 0x0d
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
    30a8:	1b 82       	std	Y+3, r1	; 0x03
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    30aa:	0f b6       	in	r0, 0x3f	; 63
    30ac:	f8 94       	cli
    30ae:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    30b0:	ef 81       	ldd	r30, Y+7	; 0x07
    30b2:	f8 85       	ldd	r31, Y+8	; 0x08
    30b4:	82 8d       	ldd	r24, Z+26	; 0x1a
    30b6:	88 23       	and	r24, r24
    30b8:	09 f4       	brne	.+2      	; 0x30bc <xQueueGenericReceive+0x36>
    30ba:	3f c0       	rjmp	.+126    	; 0x313a <xQueueGenericReceive+0xb4>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
    30bc:	ef 81       	ldd	r30, Y+7	; 0x07
    30be:	f8 85       	ldd	r31, Y+8	; 0x08
    30c0:	86 81       	ldd	r24, Z+6	; 0x06
    30c2:	97 81       	ldd	r25, Z+7	; 0x07
    30c4:	9a 83       	std	Y+2, r25	; 0x02
    30c6:	89 83       	std	Y+1, r24	; 0x01

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    30c8:	8f 81       	ldd	r24, Y+7	; 0x07
    30ca:	98 85       	ldd	r25, Y+8	; 0x08
    30cc:	29 85       	ldd	r18, Y+9	; 0x09
    30ce:	3a 85       	ldd	r19, Y+10	; 0x0a
    30d0:	b9 01       	movw	r22, r18
    30d2:	0e 94 28 1a 	call	0x3450	; 0x3450 <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
    30d6:	8d 85       	ldd	r24, Y+13	; 0x0d
    30d8:	88 23       	and	r24, r24
    30da:	b1 f4       	brne	.+44     	; 0x3108 <xQueueGenericReceive+0x82>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
    30dc:	ef 81       	ldd	r30, Y+7	; 0x07
    30de:	f8 85       	ldd	r31, Y+8	; 0x08
    30e0:	82 8d       	ldd	r24, Z+26	; 0x1a
    30e2:	81 50       	subi	r24, 0x01	; 1
    30e4:	ef 81       	ldd	r30, Y+7	; 0x07
    30e6:	f8 85       	ldd	r31, Y+8	; 0x08
    30e8:	82 8f       	std	Z+26, r24	; 0x1a
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    30ea:	ef 81       	ldd	r30, Y+7	; 0x07
    30ec:	f8 85       	ldd	r31, Y+8	; 0x08
    30ee:	80 85       	ldd	r24, Z+8	; 0x08
    30f0:	88 23       	and	r24, r24
    30f2:	f1 f0       	breq	.+60     	; 0x3130 <xQueueGenericReceive+0xaa>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    30f4:	8f 81       	ldd	r24, Y+7	; 0x07
    30f6:	98 85       	ldd	r25, Y+8	; 0x08
    30f8:	08 96       	adiw	r24, 0x08	; 8
    30fa:	0e 94 a8 1f 	call	0x3f50	; 0x3f50 <xTaskRemoveFromEventList>
    30fe:	81 30       	cpi	r24, 0x01	; 1
    3100:	b9 f4       	brne	.+46     	; 0x3130 <xQueueGenericReceive+0xaa>
						{
							portYIELD_WITHIN_API();
    3102:	0e 94 9c 15 	call	0x2b38	; 0x2b38 <vPortYield>
    3106:	14 c0       	rjmp	.+40     	; 0x3130 <xQueueGenericReceive+0xaa>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
    3108:	ef 81       	ldd	r30, Y+7	; 0x07
    310a:	f8 85       	ldd	r31, Y+8	; 0x08
    310c:	89 81       	ldd	r24, Y+1	; 0x01
    310e:	9a 81       	ldd	r25, Y+2	; 0x02
    3110:	97 83       	std	Z+7, r25	; 0x07
    3112:	86 83       	std	Z+6, r24	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    3114:	ef 81       	ldd	r30, Y+7	; 0x07
    3116:	f8 85       	ldd	r31, Y+8	; 0x08
    3118:	81 89       	ldd	r24, Z+17	; 0x11
    311a:	88 23       	and	r24, r24
    311c:	49 f0       	breq	.+18     	; 0x3130 <xQueueGenericReceive+0xaa>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    311e:	8f 81       	ldd	r24, Y+7	; 0x07
    3120:	98 85       	ldd	r25, Y+8	; 0x08
    3122:	41 96       	adiw	r24, 0x11	; 17
    3124:	0e 94 a8 1f 	call	0x3f50	; 0x3f50 <xTaskRemoveFromEventList>
    3128:	88 23       	and	r24, r24
    312a:	11 f0       	breq	.+4      	; 0x3130 <xQueueGenericReceive+0xaa>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
    312c:	0e 94 9c 15 	call	0x2b38	; 0x2b38 <vPortYield>
						}
					}

				}

				taskEXIT_CRITICAL();
    3130:	0f 90       	pop	r0
    3132:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    3134:	81 e0       	ldi	r24, 0x01	; 1
    3136:	8e 87       	std	Y+14, r24	; 0x0e
    3138:	5c c0       	rjmp	.+184    	; 0x31f2 <xQueueGenericReceive+0x16c>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    313a:	8b 85       	ldd	r24, Y+11	; 0x0b
    313c:	9c 85       	ldd	r25, Y+12	; 0x0c
    313e:	00 97       	sbiw	r24, 0x00	; 0
    3140:	21 f4       	brne	.+8      	; 0x314a <xQueueGenericReceive+0xc4>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    3142:	0f 90       	pop	r0
    3144:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    3146:	1e 86       	std	Y+14, r1	; 0x0e
    3148:	54 c0       	rjmp	.+168    	; 0x31f2 <xQueueGenericReceive+0x16c>
				}
				else if( xEntryTimeSet == pdFALSE )
    314a:	8b 81       	ldd	r24, Y+3	; 0x03
    314c:	88 23       	and	r24, r24
    314e:	31 f4       	brne	.+12     	; 0x315c <xQueueGenericReceive+0xd6>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    3150:	ce 01       	movw	r24, r28
    3152:	04 96       	adiw	r24, 0x04	; 4
    3154:	0e 94 10 20 	call	0x4020	; 0x4020 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    3158:	81 e0       	ldi	r24, 0x01	; 1
    315a:	8b 83       	std	Y+3, r24	; 0x03
				}
			}
		}
		taskEXIT_CRITICAL();
    315c:	0f 90       	pop	r0
    315e:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    3160:	0e 94 6c 1d 	call	0x3ad8	; 0x3ad8 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    3164:	0f b6       	in	r0, 0x3f	; 63
    3166:	f8 94       	cli
    3168:	0f 92       	push	r0
    316a:	ef 81       	ldd	r30, Y+7	; 0x07
    316c:	f8 85       	ldd	r31, Y+8	; 0x08
    316e:	85 8d       	ldd	r24, Z+29	; 0x1d
    3170:	8f 3f       	cpi	r24, 0xFF	; 255
    3172:	19 f4       	brne	.+6      	; 0x317a <xQueueGenericReceive+0xf4>
    3174:	ef 81       	ldd	r30, Y+7	; 0x07
    3176:	f8 85       	ldd	r31, Y+8	; 0x08
    3178:	15 8e       	std	Z+29, r1	; 0x1d
    317a:	ef 81       	ldd	r30, Y+7	; 0x07
    317c:	f8 85       	ldd	r31, Y+8	; 0x08
    317e:	86 8d       	ldd	r24, Z+30	; 0x1e
    3180:	8f 3f       	cpi	r24, 0xFF	; 255
    3182:	19 f4       	brne	.+6      	; 0x318a <xQueueGenericReceive+0x104>
    3184:	ef 81       	ldd	r30, Y+7	; 0x07
    3186:	f8 85       	ldd	r31, Y+8	; 0x08
    3188:	16 8e       	std	Z+30, r1	; 0x1e
    318a:	0f 90       	pop	r0
    318c:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    318e:	ce 01       	movw	r24, r28
    3190:	04 96       	adiw	r24, 0x04	; 4
    3192:	9e 01       	movw	r18, r28
    3194:	25 5f       	subi	r18, 0xF5	; 245
    3196:	3f 4f       	sbci	r19, 0xFF	; 255
    3198:	b9 01       	movw	r22, r18
    319a:	0e 94 29 20 	call	0x4052	; 0x4052 <xTaskCheckForTimeOut>
    319e:	88 23       	and	r24, r24
    31a0:	09 f5       	brne	.+66     	; 0x31e4 <xQueueGenericReceive+0x15e>
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    31a2:	8f 81       	ldd	r24, Y+7	; 0x07
    31a4:	98 85       	ldd	r25, Y+8	; 0x08
    31a6:	0e 94 c4 1a 	call	0x3588	; 0x3588 <prvIsQueueEmpty>
    31aa:	88 23       	and	r24, r24
    31ac:	a1 f0       	breq	.+40     	; 0x31d6 <xQueueGenericReceive+0x150>
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    31ae:	8f 81       	ldd	r24, Y+7	; 0x07
    31b0:	98 85       	ldd	r25, Y+8	; 0x08
    31b2:	41 96       	adiw	r24, 0x11	; 17
    31b4:	2b 85       	ldd	r18, Y+11	; 0x0b
    31b6:	3c 85       	ldd	r19, Y+12	; 0x0c
    31b8:	b9 01       	movw	r22, r18
    31ba:	0e 94 72 1f 	call	0x3ee4	; 0x3ee4 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    31be:	8f 81       	ldd	r24, Y+7	; 0x07
    31c0:	98 85       	ldd	r25, Y+8	; 0x08
    31c2:	0e 94 70 1a 	call	0x34e0	; 0x34e0 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    31c6:	0e 94 78 1d 	call	0x3af0	; 0x3af0 <xTaskResumeAll>
    31ca:	88 23       	and	r24, r24
    31cc:	09 f0       	breq	.+2      	; 0x31d0 <xQueueGenericReceive+0x14a>
    31ce:	6d cf       	rjmp	.-294    	; 0x30aa <xQueueGenericReceive+0x24>
				{
					portYIELD_WITHIN_API();
    31d0:	0e 94 9c 15 	call	0x2b38	; 0x2b38 <vPortYield>
    31d4:	6a cf       	rjmp	.-300    	; 0x30aa <xQueueGenericReceive+0x24>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    31d6:	8f 81       	ldd	r24, Y+7	; 0x07
    31d8:	98 85       	ldd	r25, Y+8	; 0x08
    31da:	0e 94 70 1a 	call	0x34e0	; 0x34e0 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    31de:	0e 94 78 1d 	call	0x3af0	; 0x3af0 <xTaskResumeAll>
    31e2:	63 cf       	rjmp	.-314    	; 0x30aa <xQueueGenericReceive+0x24>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    31e4:	8f 81       	ldd	r24, Y+7	; 0x07
    31e6:	98 85       	ldd	r25, Y+8	; 0x08
    31e8:	0e 94 70 1a 	call	0x34e0	; 0x34e0 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    31ec:	0e 94 78 1d 	call	0x3af0	; 0x3af0 <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
    31f0:	1e 86       	std	Y+14, r1	; 0x0e
    31f2:	8e 85       	ldd	r24, Y+14	; 0x0e
		}
	}
}
    31f4:	2e 96       	adiw	r28, 0x0e	; 14
    31f6:	0f b6       	in	r0, 0x3f	; 63
    31f8:	f8 94       	cli
    31fa:	de bf       	out	0x3e, r29	; 62
    31fc:	0f be       	out	0x3f, r0	; 63
    31fe:	cd bf       	out	0x3d, r28	; 61
    3200:	cf 91       	pop	r28
    3202:	df 91       	pop	r29
    3204:	08 95       	ret

00003206 <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxTaskWoken )
{
    3206:	df 93       	push	r29
    3208:	cf 93       	push	r28
    320a:	cd b7       	in	r28, 0x3d	; 61
    320c:	de b7       	in	r29, 0x3e	; 62
    320e:	28 97       	sbiw	r28, 0x08	; 8
    3210:	0f b6       	in	r0, 0x3f	; 63
    3212:	f8 94       	cli
    3214:	de bf       	out	0x3e, r29	; 62
    3216:	0f be       	out	0x3f, r0	; 63
    3218:	cd bf       	out	0x3d, r28	; 61
    321a:	9c 83       	std	Y+4, r25	; 0x04
    321c:	8b 83       	std	Y+3, r24	; 0x03
    321e:	7e 83       	std	Y+6, r23	; 0x06
    3220:	6d 83       	std	Y+5, r22	; 0x05
    3222:	58 87       	std	Y+8, r21	; 0x08
    3224:	4f 83       	std	Y+7, r20	; 0x07

	configASSERT( pxQueue );
	configASSERT( pxTaskWoken );
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    3226:	19 82       	std	Y+1, r1	; 0x01
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    3228:	eb 81       	ldd	r30, Y+3	; 0x03
    322a:	fc 81       	ldd	r31, Y+4	; 0x04
    322c:	82 8d       	ldd	r24, Z+26	; 0x1a
    322e:	88 23       	and	r24, r24
    3230:	71 f1       	breq	.+92     	; 0x328e <xQueueReceiveFromISR+0x88>
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    3232:	8b 81       	ldd	r24, Y+3	; 0x03
    3234:	9c 81       	ldd	r25, Y+4	; 0x04
    3236:	2d 81       	ldd	r18, Y+5	; 0x05
    3238:	3e 81       	ldd	r19, Y+6	; 0x06
    323a:	b9 01       	movw	r22, r18
    323c:	0e 94 28 1a 	call	0x3450	; 0x3450 <prvCopyDataFromQueue>
			--( pxQueue->uxMessagesWaiting );
    3240:	eb 81       	ldd	r30, Y+3	; 0x03
    3242:	fc 81       	ldd	r31, Y+4	; 0x04
    3244:	82 8d       	ldd	r24, Z+26	; 0x1a
    3246:	81 50       	subi	r24, 0x01	; 1
    3248:	eb 81       	ldd	r30, Y+3	; 0x03
    324a:	fc 81       	ldd	r31, Y+4	; 0x04
    324c:	82 8f       	std	Z+26, r24	; 0x1a

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
    324e:	eb 81       	ldd	r30, Y+3	; 0x03
    3250:	fc 81       	ldd	r31, Y+4	; 0x04
    3252:	85 8d       	ldd	r24, Z+29	; 0x1d
    3254:	8f 3f       	cpi	r24, 0xFF	; 255
    3256:	89 f4       	brne	.+34     	; 0x327a <xQueueReceiveFromISR+0x74>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    3258:	eb 81       	ldd	r30, Y+3	; 0x03
    325a:	fc 81       	ldd	r31, Y+4	; 0x04
    325c:	80 85       	ldd	r24, Z+8	; 0x08
    325e:	88 23       	and	r24, r24
    3260:	99 f0       	breq	.+38     	; 0x3288 <xQueueReceiveFromISR+0x82>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    3262:	8b 81       	ldd	r24, Y+3	; 0x03
    3264:	9c 81       	ldd	r25, Y+4	; 0x04
    3266:	08 96       	adiw	r24, 0x08	; 8
    3268:	0e 94 a8 1f 	call	0x3f50	; 0x3f50 <xTaskRemoveFromEventList>
    326c:	88 23       	and	r24, r24
    326e:	61 f0       	breq	.+24     	; 0x3288 <xQueueReceiveFromISR+0x82>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						*pxTaskWoken = pdTRUE;
    3270:	ef 81       	ldd	r30, Y+7	; 0x07
    3272:	f8 85       	ldd	r31, Y+8	; 0x08
    3274:	81 e0       	ldi	r24, 0x01	; 1
    3276:	80 83       	st	Z, r24
    3278:	07 c0       	rjmp	.+14     	; 0x3288 <xQueueReceiveFromISR+0x82>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
    327a:	eb 81       	ldd	r30, Y+3	; 0x03
    327c:	fc 81       	ldd	r31, Y+4	; 0x04
    327e:	85 8d       	ldd	r24, Z+29	; 0x1d
    3280:	8f 5f       	subi	r24, 0xFF	; 255
    3282:	eb 81       	ldd	r30, Y+3	; 0x03
    3284:	fc 81       	ldd	r31, Y+4	; 0x04
    3286:	85 8f       	std	Z+29, r24	; 0x1d
			}

			xReturn = pdPASS;
    3288:	81 e0       	ldi	r24, 0x01	; 1
    328a:	8a 83       	std	Y+2, r24	; 0x02
    328c:	01 c0       	rjmp	.+2      	; 0x3290 <xQueueReceiveFromISR+0x8a>
		}
		else
		{
			xReturn = pdFAIL;
    328e:	1a 82       	std	Y+2, r1	; 0x02
			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    3290:	8a 81       	ldd	r24, Y+2	; 0x02
}
    3292:	28 96       	adiw	r28, 0x08	; 8
    3294:	0f b6       	in	r0, 0x3f	; 63
    3296:	f8 94       	cli
    3298:	de bf       	out	0x3e, r29	; 62
    329a:	0f be       	out	0x3f, r0	; 63
    329c:	cd bf       	out	0x3d, r28	; 61
    329e:	cf 91       	pop	r28
    32a0:	df 91       	pop	r29
    32a2:	08 95       	ret

000032a4 <uxQueueMessagesWaiting>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxQueueMessagesWaiting( const xQueueHandle pxQueue )
{
    32a4:	df 93       	push	r29
    32a6:	cf 93       	push	r28
    32a8:	00 d0       	rcall	.+0      	; 0x32aa <uxQueueMessagesWaiting+0x6>
    32aa:	0f 92       	push	r0
    32ac:	cd b7       	in	r28, 0x3d	; 61
    32ae:	de b7       	in	r29, 0x3e	; 62
    32b0:	9b 83       	std	Y+3, r25	; 0x03
    32b2:	8a 83       	std	Y+2, r24	; 0x02
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    32b4:	0f b6       	in	r0, 0x3f	; 63
    32b6:	f8 94       	cli
    32b8:	0f 92       	push	r0
		uxReturn = pxQueue->uxMessagesWaiting;
    32ba:	ea 81       	ldd	r30, Y+2	; 0x02
    32bc:	fb 81       	ldd	r31, Y+3	; 0x03
    32be:	82 8d       	ldd	r24, Z+26	; 0x1a
    32c0:	89 83       	std	Y+1, r24	; 0x01
	taskEXIT_CRITICAL();
    32c2:	0f 90       	pop	r0
    32c4:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    32c6:	89 81       	ldd	r24, Y+1	; 0x01
}
    32c8:	0f 90       	pop	r0
    32ca:	0f 90       	pop	r0
    32cc:	0f 90       	pop	r0
    32ce:	cf 91       	pop	r28
    32d0:	df 91       	pop	r29
    32d2:	08 95       	ret

000032d4 <uxQueueMessagesWaitingFromISR>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxQueueMessagesWaitingFromISR( const xQueueHandle pxQueue )
{
    32d4:	df 93       	push	r29
    32d6:	cf 93       	push	r28
    32d8:	00 d0       	rcall	.+0      	; 0x32da <uxQueueMessagesWaitingFromISR+0x6>
    32da:	0f 92       	push	r0
    32dc:	cd b7       	in	r28, 0x3d	; 61
    32de:	de b7       	in	r29, 0x3e	; 62
    32e0:	9b 83       	std	Y+3, r25	; 0x03
    32e2:	8a 83       	std	Y+2, r24	; 0x02
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	uxReturn = pxQueue->uxMessagesWaiting;
    32e4:	ea 81       	ldd	r30, Y+2	; 0x02
    32e6:	fb 81       	ldd	r31, Y+3	; 0x03
    32e8:	82 8d       	ldd	r24, Z+26	; 0x1a
    32ea:	89 83       	std	Y+1, r24	; 0x01

	return uxReturn;
    32ec:	89 81       	ldd	r24, Y+1	; 0x01
}
    32ee:	0f 90       	pop	r0
    32f0:	0f 90       	pop	r0
    32f2:	0f 90       	pop	r0
    32f4:	cf 91       	pop	r28
    32f6:	df 91       	pop	r29
    32f8:	08 95       	ret

000032fa <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( xQueueHandle pxQueue )
{
    32fa:	df 93       	push	r29
    32fc:	cf 93       	push	r28
    32fe:	00 d0       	rcall	.+0      	; 0x3300 <vQueueDelete+0x6>
    3300:	cd b7       	in	r28, 0x3d	; 61
    3302:	de b7       	in	r29, 0x3e	; 62
    3304:	9a 83       	std	Y+2, r25	; 0x02
    3306:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxQueue );

	traceQUEUE_DELETE( pxQueue );
	vQueueUnregisterQueue( pxQueue );
	vPortFree( pxQueue->pcHead );
    3308:	e9 81       	ldd	r30, Y+1	; 0x01
    330a:	fa 81       	ldd	r31, Y+2	; 0x02
    330c:	80 81       	ld	r24, Z
    330e:	91 81       	ldd	r25, Z+1	; 0x01
    3310:	0e 94 7c 12 	call	0x24f8	; 0x24f8 <vPortFree>
	vPortFree( pxQueue );
    3314:	89 81       	ldd	r24, Y+1	; 0x01
    3316:	9a 81       	ldd	r25, Y+2	; 0x02
    3318:	0e 94 7c 12 	call	0x24f8	; 0x24f8 <vPortFree>
}
    331c:	0f 90       	pop	r0
    331e:	0f 90       	pop	r0
    3320:	cf 91       	pop	r28
    3322:	df 91       	pop	r29
    3324:	08 95       	ret

00003326 <prvCopyDataToQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
    3326:	df 93       	push	r29
    3328:	cf 93       	push	r28
    332a:	00 d0       	rcall	.+0      	; 0x332c <prvCopyDataToQueue+0x6>
    332c:	00 d0       	rcall	.+0      	; 0x332e <prvCopyDataToQueue+0x8>
    332e:	0f 92       	push	r0
    3330:	cd b7       	in	r28, 0x3d	; 61
    3332:	de b7       	in	r29, 0x3e	; 62
    3334:	9a 83       	std	Y+2, r25	; 0x02
    3336:	89 83       	std	Y+1, r24	; 0x01
    3338:	7c 83       	std	Y+4, r23	; 0x04
    333a:	6b 83       	std	Y+3, r22	; 0x03
    333c:	4d 83       	std	Y+5, r20	; 0x05
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
    333e:	e9 81       	ldd	r30, Y+1	; 0x01
    3340:	fa 81       	ldd	r31, Y+2	; 0x02
    3342:	84 8d       	ldd	r24, Z+28	; 0x1c
    3344:	88 23       	and	r24, r24
    3346:	09 f4       	brne	.+2      	; 0x334a <prvCopyDataToQueue+0x24>
    3348:	74 c0       	rjmp	.+232    	; 0x3432 <prvCopyDataToQueue+0x10c>
				pxQueue->pxMutexHolder = NULL;
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
    334a:	8d 81       	ldd	r24, Y+5	; 0x05
    334c:	88 23       	and	r24, r24
    334e:	99 f5       	brne	.+102    	; 0x33b6 <prvCopyDataToQueue+0x90>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    3350:	e9 81       	ldd	r30, Y+1	; 0x01
    3352:	fa 81       	ldd	r31, Y+2	; 0x02
    3354:	64 81       	ldd	r22, Z+4	; 0x04
    3356:	75 81       	ldd	r23, Z+5	; 0x05
    3358:	e9 81       	ldd	r30, Y+1	; 0x01
    335a:	fa 81       	ldd	r31, Y+2	; 0x02
    335c:	84 8d       	ldd	r24, Z+28	; 0x1c
    335e:	48 2f       	mov	r20, r24
    3360:	50 e0       	ldi	r21, 0x00	; 0
    3362:	2b 81       	ldd	r18, Y+3	; 0x03
    3364:	3c 81       	ldd	r19, Y+4	; 0x04
    3366:	cb 01       	movw	r24, r22
    3368:	b9 01       	movw	r22, r18
    336a:	0e 94 93 22 	call	0x4526	; 0x4526 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
    336e:	e9 81       	ldd	r30, Y+1	; 0x01
    3370:	fa 81       	ldd	r31, Y+2	; 0x02
    3372:	24 81       	ldd	r18, Z+4	; 0x04
    3374:	35 81       	ldd	r19, Z+5	; 0x05
    3376:	e9 81       	ldd	r30, Y+1	; 0x01
    3378:	fa 81       	ldd	r31, Y+2	; 0x02
    337a:	84 8d       	ldd	r24, Z+28	; 0x1c
    337c:	88 2f       	mov	r24, r24
    337e:	90 e0       	ldi	r25, 0x00	; 0
    3380:	82 0f       	add	r24, r18
    3382:	93 1f       	adc	r25, r19
    3384:	e9 81       	ldd	r30, Y+1	; 0x01
    3386:	fa 81       	ldd	r31, Y+2	; 0x02
    3388:	95 83       	std	Z+5, r25	; 0x05
    338a:	84 83       	std	Z+4, r24	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
    338c:	e9 81       	ldd	r30, Y+1	; 0x01
    338e:	fa 81       	ldd	r31, Y+2	; 0x02
    3390:	24 81       	ldd	r18, Z+4	; 0x04
    3392:	35 81       	ldd	r19, Z+5	; 0x05
    3394:	e9 81       	ldd	r30, Y+1	; 0x01
    3396:	fa 81       	ldd	r31, Y+2	; 0x02
    3398:	82 81       	ldd	r24, Z+2	; 0x02
    339a:	93 81       	ldd	r25, Z+3	; 0x03
    339c:	28 17       	cp	r18, r24
    339e:	39 07       	cpc	r19, r25
    33a0:	08 f4       	brcc	.+2      	; 0x33a4 <prvCopyDataToQueue+0x7e>
    33a2:	47 c0       	rjmp	.+142    	; 0x3432 <prvCopyDataToQueue+0x10c>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    33a4:	e9 81       	ldd	r30, Y+1	; 0x01
    33a6:	fa 81       	ldd	r31, Y+2	; 0x02
    33a8:	80 81       	ld	r24, Z
    33aa:	91 81       	ldd	r25, Z+1	; 0x01
    33ac:	e9 81       	ldd	r30, Y+1	; 0x01
    33ae:	fa 81       	ldd	r31, Y+2	; 0x02
    33b0:	95 83       	std	Z+5, r25	; 0x05
    33b2:	84 83       	std	Z+4, r24	; 0x04
    33b4:	3e c0       	rjmp	.+124    	; 0x3432 <prvCopyDataToQueue+0x10c>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    33b6:	e9 81       	ldd	r30, Y+1	; 0x01
    33b8:	fa 81       	ldd	r31, Y+2	; 0x02
    33ba:	66 81       	ldd	r22, Z+6	; 0x06
    33bc:	77 81       	ldd	r23, Z+7	; 0x07
    33be:	e9 81       	ldd	r30, Y+1	; 0x01
    33c0:	fa 81       	ldd	r31, Y+2	; 0x02
    33c2:	84 8d       	ldd	r24, Z+28	; 0x1c
    33c4:	48 2f       	mov	r20, r24
    33c6:	50 e0       	ldi	r21, 0x00	; 0
    33c8:	2b 81       	ldd	r18, Y+3	; 0x03
    33ca:	3c 81       	ldd	r19, Y+4	; 0x04
    33cc:	cb 01       	movw	r24, r22
    33ce:	b9 01       	movw	r22, r18
    33d0:	0e 94 93 22 	call	0x4526	; 0x4526 <memcpy>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
    33d4:	e9 81       	ldd	r30, Y+1	; 0x01
    33d6:	fa 81       	ldd	r31, Y+2	; 0x02
    33d8:	26 81       	ldd	r18, Z+6	; 0x06
    33da:	37 81       	ldd	r19, Z+7	; 0x07
    33dc:	e9 81       	ldd	r30, Y+1	; 0x01
    33de:	fa 81       	ldd	r31, Y+2	; 0x02
    33e0:	84 8d       	ldd	r24, Z+28	; 0x1c
    33e2:	88 2f       	mov	r24, r24
    33e4:	90 e0       	ldi	r25, 0x00	; 0
    33e6:	90 95       	com	r25
    33e8:	81 95       	neg	r24
    33ea:	9f 4f       	sbci	r25, 0xFF	; 255
    33ec:	82 0f       	add	r24, r18
    33ee:	93 1f       	adc	r25, r19
    33f0:	e9 81       	ldd	r30, Y+1	; 0x01
    33f2:	fa 81       	ldd	r31, Y+2	; 0x02
    33f4:	97 83       	std	Z+7, r25	; 0x07
    33f6:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
    33f8:	e9 81       	ldd	r30, Y+1	; 0x01
    33fa:	fa 81       	ldd	r31, Y+2	; 0x02
    33fc:	26 81       	ldd	r18, Z+6	; 0x06
    33fe:	37 81       	ldd	r19, Z+7	; 0x07
    3400:	e9 81       	ldd	r30, Y+1	; 0x01
    3402:	fa 81       	ldd	r31, Y+2	; 0x02
    3404:	80 81       	ld	r24, Z
    3406:	91 81       	ldd	r25, Z+1	; 0x01
    3408:	28 17       	cp	r18, r24
    340a:	39 07       	cpc	r19, r25
    340c:	90 f4       	brcc	.+36     	; 0x3432 <prvCopyDataToQueue+0x10c>
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
    340e:	e9 81       	ldd	r30, Y+1	; 0x01
    3410:	fa 81       	ldd	r31, Y+2	; 0x02
    3412:	22 81       	ldd	r18, Z+2	; 0x02
    3414:	33 81       	ldd	r19, Z+3	; 0x03
    3416:	e9 81       	ldd	r30, Y+1	; 0x01
    3418:	fa 81       	ldd	r31, Y+2	; 0x02
    341a:	84 8d       	ldd	r24, Z+28	; 0x1c
    341c:	88 2f       	mov	r24, r24
    341e:	90 e0       	ldi	r25, 0x00	; 0
    3420:	90 95       	com	r25
    3422:	81 95       	neg	r24
    3424:	9f 4f       	sbci	r25, 0xFF	; 255
    3426:	82 0f       	add	r24, r18
    3428:	93 1f       	adc	r25, r19
    342a:	e9 81       	ldd	r30, Y+1	; 0x01
    342c:	fa 81       	ldd	r31, Y+2	; 0x02
    342e:	97 83       	std	Z+7, r25	; 0x07
    3430:	86 83       	std	Z+6, r24	; 0x06
		}
	}

	++( pxQueue->uxMessagesWaiting );
    3432:	e9 81       	ldd	r30, Y+1	; 0x01
    3434:	fa 81       	ldd	r31, Y+2	; 0x02
    3436:	82 8d       	ldd	r24, Z+26	; 0x1a
    3438:	8f 5f       	subi	r24, 0xFF	; 255
    343a:	e9 81       	ldd	r30, Y+1	; 0x01
    343c:	fa 81       	ldd	r31, Y+2	; 0x02
    343e:	82 8f       	std	Z+26, r24	; 0x1a
}
    3440:	0f 90       	pop	r0
    3442:	0f 90       	pop	r0
    3444:	0f 90       	pop	r0
    3446:	0f 90       	pop	r0
    3448:	0f 90       	pop	r0
    344a:	cf 91       	pop	r28
    344c:	df 91       	pop	r29
    344e:	08 95       	ret

00003450 <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
    3450:	df 93       	push	r29
    3452:	cf 93       	push	r28
    3454:	00 d0       	rcall	.+0      	; 0x3456 <prvCopyDataFromQueue+0x6>
    3456:	00 d0       	rcall	.+0      	; 0x3458 <prvCopyDataFromQueue+0x8>
    3458:	cd b7       	in	r28, 0x3d	; 61
    345a:	de b7       	in	r29, 0x3e	; 62
    345c:	9a 83       	std	Y+2, r25	; 0x02
    345e:	89 83       	std	Y+1, r24	; 0x01
    3460:	7c 83       	std	Y+4, r23	; 0x04
    3462:	6b 83       	std	Y+3, r22	; 0x03
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
    3464:	e9 81       	ldd	r30, Y+1	; 0x01
    3466:	fa 81       	ldd	r31, Y+2	; 0x02
    3468:	80 81       	ld	r24, Z
    346a:	91 81       	ldd	r25, Z+1	; 0x01
    346c:	00 97       	sbiw	r24, 0x00	; 0
    346e:	89 f1       	breq	.+98     	; 0x34d2 <prvCopyDataFromQueue+0x82>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
    3470:	e9 81       	ldd	r30, Y+1	; 0x01
    3472:	fa 81       	ldd	r31, Y+2	; 0x02
    3474:	26 81       	ldd	r18, Z+6	; 0x06
    3476:	37 81       	ldd	r19, Z+7	; 0x07
    3478:	e9 81       	ldd	r30, Y+1	; 0x01
    347a:	fa 81       	ldd	r31, Y+2	; 0x02
    347c:	84 8d       	ldd	r24, Z+28	; 0x1c
    347e:	88 2f       	mov	r24, r24
    3480:	90 e0       	ldi	r25, 0x00	; 0
    3482:	82 0f       	add	r24, r18
    3484:	93 1f       	adc	r25, r19
    3486:	e9 81       	ldd	r30, Y+1	; 0x01
    3488:	fa 81       	ldd	r31, Y+2	; 0x02
    348a:	97 83       	std	Z+7, r25	; 0x07
    348c:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
    348e:	e9 81       	ldd	r30, Y+1	; 0x01
    3490:	fa 81       	ldd	r31, Y+2	; 0x02
    3492:	26 81       	ldd	r18, Z+6	; 0x06
    3494:	37 81       	ldd	r19, Z+7	; 0x07
    3496:	e9 81       	ldd	r30, Y+1	; 0x01
    3498:	fa 81       	ldd	r31, Y+2	; 0x02
    349a:	82 81       	ldd	r24, Z+2	; 0x02
    349c:	93 81       	ldd	r25, Z+3	; 0x03
    349e:	28 17       	cp	r18, r24
    34a0:	39 07       	cpc	r19, r25
    34a2:	40 f0       	brcs	.+16     	; 0x34b4 <prvCopyDataFromQueue+0x64>
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
    34a4:	e9 81       	ldd	r30, Y+1	; 0x01
    34a6:	fa 81       	ldd	r31, Y+2	; 0x02
    34a8:	80 81       	ld	r24, Z
    34aa:	91 81       	ldd	r25, Z+1	; 0x01
    34ac:	e9 81       	ldd	r30, Y+1	; 0x01
    34ae:	fa 81       	ldd	r31, Y+2	; 0x02
    34b0:	97 83       	std	Z+7, r25	; 0x07
    34b2:	86 83       	std	Z+6, r24	; 0x06
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    34b4:	e9 81       	ldd	r30, Y+1	; 0x01
    34b6:	fa 81       	ldd	r31, Y+2	; 0x02
    34b8:	46 81       	ldd	r20, Z+6	; 0x06
    34ba:	57 81       	ldd	r21, Z+7	; 0x07
    34bc:	e9 81       	ldd	r30, Y+1	; 0x01
    34be:	fa 81       	ldd	r31, Y+2	; 0x02
    34c0:	84 8d       	ldd	r24, Z+28	; 0x1c
    34c2:	28 2f       	mov	r18, r24
    34c4:	30 e0       	ldi	r19, 0x00	; 0
    34c6:	8b 81       	ldd	r24, Y+3	; 0x03
    34c8:	9c 81       	ldd	r25, Y+4	; 0x04
    34ca:	ba 01       	movw	r22, r20
    34cc:	a9 01       	movw	r20, r18
    34ce:	0e 94 93 22 	call	0x4526	; 0x4526 <memcpy>
	}
}
    34d2:	0f 90       	pop	r0
    34d4:	0f 90       	pop	r0
    34d6:	0f 90       	pop	r0
    34d8:	0f 90       	pop	r0
    34da:	cf 91       	pop	r28
    34dc:	df 91       	pop	r29
    34de:	08 95       	ret

000034e0 <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
    34e0:	df 93       	push	r29
    34e2:	cf 93       	push	r28
    34e4:	00 d0       	rcall	.+0      	; 0x34e6 <prvUnlockQueue+0x6>
    34e6:	cd b7       	in	r28, 0x3d	; 61
    34e8:	de b7       	in	r29, 0x3e	; 62
    34ea:	9a 83       	std	Y+2, r25	; 0x02
    34ec:	89 83       	std	Y+1, r24	; 0x01

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    34ee:	0f b6       	in	r0, 0x3f	; 63
    34f0:	f8 94       	cli
    34f2:	0f 92       	push	r0
    34f4:	15 c0       	rjmp	.+42     	; 0x3520 <prvUnlockQueue+0x40>
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    34f6:	e9 81       	ldd	r30, Y+1	; 0x01
    34f8:	fa 81       	ldd	r31, Y+2	; 0x02
    34fa:	81 89       	ldd	r24, Z+17	; 0x11
    34fc:	88 23       	and	r24, r24
    34fe:	a9 f0       	breq	.+42     	; 0x352a <prvUnlockQueue+0x4a>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    3500:	89 81       	ldd	r24, Y+1	; 0x01
    3502:	9a 81       	ldd	r25, Y+2	; 0x02
    3504:	41 96       	adiw	r24, 0x11	; 17
    3506:	0e 94 a8 1f 	call	0x3f50	; 0x3f50 <xTaskRemoveFromEventList>
    350a:	88 23       	and	r24, r24
    350c:	11 f0       	breq	.+4      	; 0x3512 <prvUnlockQueue+0x32>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
    350e:	0e 94 86 20 	call	0x410c	; 0x410c <vTaskMissedYield>
				}

				--( pxQueue->xTxLock );
    3512:	e9 81       	ldd	r30, Y+1	; 0x01
    3514:	fa 81       	ldd	r31, Y+2	; 0x02
    3516:	86 8d       	ldd	r24, Z+30	; 0x1e
    3518:	81 50       	subi	r24, 0x01	; 1
    351a:	e9 81       	ldd	r30, Y+1	; 0x01
    351c:	fa 81       	ldd	r31, Y+2	; 0x02
    351e:	86 8f       	std	Z+30, r24	; 0x1e
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    3520:	e9 81       	ldd	r30, Y+1	; 0x01
    3522:	fa 81       	ldd	r31, Y+2	; 0x02
    3524:	86 8d       	ldd	r24, Z+30	; 0x1e
    3526:	18 16       	cp	r1, r24
    3528:	34 f3       	brlt	.-52     	; 0x34f6 <prvUnlockQueue+0x16>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
    352a:	e9 81       	ldd	r30, Y+1	; 0x01
    352c:	fa 81       	ldd	r31, Y+2	; 0x02
    352e:	8f ef       	ldi	r24, 0xFF	; 255
    3530:	86 8f       	std	Z+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
    3532:	0f 90       	pop	r0
    3534:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    3536:	0f b6       	in	r0, 0x3f	; 63
    3538:	f8 94       	cli
    353a:	0f 92       	push	r0
    353c:	15 c0       	rjmp	.+42     	; 0x3568 <prvUnlockQueue+0x88>
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    353e:	e9 81       	ldd	r30, Y+1	; 0x01
    3540:	fa 81       	ldd	r31, Y+2	; 0x02
    3542:	80 85       	ldd	r24, Z+8	; 0x08
    3544:	88 23       	and	r24, r24
    3546:	a9 f0       	breq	.+42     	; 0x3572 <prvUnlockQueue+0x92>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    3548:	89 81       	ldd	r24, Y+1	; 0x01
    354a:	9a 81       	ldd	r25, Y+2	; 0x02
    354c:	08 96       	adiw	r24, 0x08	; 8
    354e:	0e 94 a8 1f 	call	0x3f50	; 0x3f50 <xTaskRemoveFromEventList>
    3552:	88 23       	and	r24, r24
    3554:	11 f0       	breq	.+4      	; 0x355a <prvUnlockQueue+0x7a>
				{
					vTaskMissedYield();
    3556:	0e 94 86 20 	call	0x410c	; 0x410c <vTaskMissedYield>
				}

				--( pxQueue->xRxLock );
    355a:	e9 81       	ldd	r30, Y+1	; 0x01
    355c:	fa 81       	ldd	r31, Y+2	; 0x02
    355e:	85 8d       	ldd	r24, Z+29	; 0x1d
    3560:	81 50       	subi	r24, 0x01	; 1
    3562:	e9 81       	ldd	r30, Y+1	; 0x01
    3564:	fa 81       	ldd	r31, Y+2	; 0x02
    3566:	85 8f       	std	Z+29, r24	; 0x1d
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    3568:	e9 81       	ldd	r30, Y+1	; 0x01
    356a:	fa 81       	ldd	r31, Y+2	; 0x02
    356c:	85 8d       	ldd	r24, Z+29	; 0x1d
    356e:	18 16       	cp	r1, r24
    3570:	34 f3       	brlt	.-52     	; 0x353e <prvUnlockQueue+0x5e>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
    3572:	e9 81       	ldd	r30, Y+1	; 0x01
    3574:	fa 81       	ldd	r31, Y+2	; 0x02
    3576:	8f ef       	ldi	r24, 0xFF	; 255
    3578:	85 8f       	std	Z+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
    357a:	0f 90       	pop	r0
    357c:	0f be       	out	0x3f, r0	; 63
}
    357e:	0f 90       	pop	r0
    3580:	0f 90       	pop	r0
    3582:	cf 91       	pop	r28
    3584:	df 91       	pop	r29
    3586:	08 95       	ret

00003588 <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
    3588:	df 93       	push	r29
    358a:	cf 93       	push	r28
    358c:	00 d0       	rcall	.+0      	; 0x358e <prvIsQueueEmpty+0x6>
    358e:	0f 92       	push	r0
    3590:	cd b7       	in	r28, 0x3d	; 61
    3592:	de b7       	in	r29, 0x3e	; 62
    3594:	9b 83       	std	Y+3, r25	; 0x03
    3596:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    3598:	0f b6       	in	r0, 0x3f	; 63
    359a:	f8 94       	cli
    359c:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    359e:	ea 81       	ldd	r30, Y+2	; 0x02
    35a0:	fb 81       	ldd	r31, Y+3	; 0x03
    35a2:	82 8d       	ldd	r24, Z+26	; 0x1a
    35a4:	19 82       	std	Y+1, r1	; 0x01
    35a6:	88 23       	and	r24, r24
    35a8:	11 f4       	brne	.+4      	; 0x35ae <prvIsQueueEmpty+0x26>
    35aa:	81 e0       	ldi	r24, 0x01	; 1
    35ac:	89 83       	std	Y+1, r24	; 0x01
	taskEXIT_CRITICAL();
    35ae:	0f 90       	pop	r0
    35b0:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    35b2:	89 81       	ldd	r24, Y+1	; 0x01
}
    35b4:	0f 90       	pop	r0
    35b6:	0f 90       	pop	r0
    35b8:	0f 90       	pop	r0
    35ba:	cf 91       	pop	r28
    35bc:	df 91       	pop	r29
    35be:	08 95       	ret

000035c0 <xQueueIsQueueEmptyFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueEmptyFromISR( const xQueueHandle pxQueue )
{
    35c0:	df 93       	push	r29
    35c2:	cf 93       	push	r28
    35c4:	00 d0       	rcall	.+0      	; 0x35c6 <xQueueIsQueueEmptyFromISR+0x6>
    35c6:	0f 92       	push	r0
    35c8:	cd b7       	in	r28, 0x3d	; 61
    35ca:	de b7       	in	r29, 0x3e	; 62
    35cc:	9b 83       	std	Y+3, r25	; 0x03
    35ce:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	configASSERT( pxQueue );
	xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    35d0:	ea 81       	ldd	r30, Y+2	; 0x02
    35d2:	fb 81       	ldd	r31, Y+3	; 0x03
    35d4:	82 8d       	ldd	r24, Z+26	; 0x1a
    35d6:	19 82       	std	Y+1, r1	; 0x01
    35d8:	88 23       	and	r24, r24
    35da:	11 f4       	brne	.+4      	; 0x35e0 <xQueueIsQueueEmptyFromISR+0x20>
    35dc:	81 e0       	ldi	r24, 0x01	; 1
    35de:	89 83       	std	Y+1, r24	; 0x01

	return xReturn;
    35e0:	89 81       	ldd	r24, Y+1	; 0x01
}
    35e2:	0f 90       	pop	r0
    35e4:	0f 90       	pop	r0
    35e6:	0f 90       	pop	r0
    35e8:	cf 91       	pop	r28
    35ea:	df 91       	pop	r29
    35ec:	08 95       	ret

000035ee <prvIsQueueFull>:
/*-----------------------------------------------------------*/

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
    35ee:	df 93       	push	r29
    35f0:	cf 93       	push	r28
    35f2:	00 d0       	rcall	.+0      	; 0x35f4 <prvIsQueueFull+0x6>
    35f4:	0f 92       	push	r0
    35f6:	cd b7       	in	r28, 0x3d	; 61
    35f8:	de b7       	in	r29, 0x3e	; 62
    35fa:	9b 83       	std	Y+3, r25	; 0x03
    35fc:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    35fe:	0f b6       	in	r0, 0x3f	; 63
    3600:	f8 94       	cli
    3602:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
    3604:	ea 81       	ldd	r30, Y+2	; 0x02
    3606:	fb 81       	ldd	r31, Y+3	; 0x03
    3608:	92 8d       	ldd	r25, Z+26	; 0x1a
    360a:	ea 81       	ldd	r30, Y+2	; 0x02
    360c:	fb 81       	ldd	r31, Y+3	; 0x03
    360e:	83 8d       	ldd	r24, Z+27	; 0x1b
    3610:	19 82       	std	Y+1, r1	; 0x01
    3612:	98 17       	cp	r25, r24
    3614:	11 f4       	brne	.+4      	; 0x361a <prvIsQueueFull+0x2c>
    3616:	81 e0       	ldi	r24, 0x01	; 1
    3618:	89 83       	std	Y+1, r24	; 0x01
	taskEXIT_CRITICAL();
    361a:	0f 90       	pop	r0
    361c:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    361e:	89 81       	ldd	r24, Y+1	; 0x01
}
    3620:	0f 90       	pop	r0
    3622:	0f 90       	pop	r0
    3624:	0f 90       	pop	r0
    3626:	cf 91       	pop	r28
    3628:	df 91       	pop	r29
    362a:	08 95       	ret

0000362c <xQueueIsQueueFullFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueFullFromISR( const xQueueHandle pxQueue )
{
    362c:	df 93       	push	r29
    362e:	cf 93       	push	r28
    3630:	00 d0       	rcall	.+0      	; 0x3632 <xQueueIsQueueFullFromISR+0x6>
    3632:	0f 92       	push	r0
    3634:	cd b7       	in	r28, 0x3d	; 61
    3636:	de b7       	in	r29, 0x3e	; 62
    3638:	9b 83       	std	Y+3, r25	; 0x03
    363a:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	configASSERT( pxQueue );
	xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
    363c:	ea 81       	ldd	r30, Y+2	; 0x02
    363e:	fb 81       	ldd	r31, Y+3	; 0x03
    3640:	92 8d       	ldd	r25, Z+26	; 0x1a
    3642:	ea 81       	ldd	r30, Y+2	; 0x02
    3644:	fb 81       	ldd	r31, Y+3	; 0x03
    3646:	83 8d       	ldd	r24, Z+27	; 0x1b
    3648:	19 82       	std	Y+1, r1	; 0x01
    364a:	98 17       	cp	r25, r24
    364c:	11 f4       	brne	.+4      	; 0x3652 <xQueueIsQueueFullFromISR+0x26>
    364e:	81 e0       	ldi	r24, 0x01	; 1
    3650:	89 83       	std	Y+1, r24	; 0x01

	return xReturn;
    3652:	89 81       	ldd	r24, Y+1	; 0x01
}
    3654:	0f 90       	pop	r0
    3656:	0f 90       	pop	r0
    3658:	0f 90       	pop	r0
    365a:	cf 91       	pop	r28
    365c:	df 91       	pop	r29
    365e:	08 95       	ret

00003660 <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
    3660:	af 92       	push	r10
    3662:	bf 92       	push	r11
    3664:	cf 92       	push	r12
    3666:	df 92       	push	r13
    3668:	ef 92       	push	r14
    366a:	ff 92       	push	r15
    366c:	0f 93       	push	r16
    366e:	1f 93       	push	r17
    3670:	df 93       	push	r29
    3672:	cf 93       	push	r28
    3674:	cd b7       	in	r28, 0x3d	; 61
    3676:	de b7       	in	r29, 0x3e	; 62
    3678:	64 97       	sbiw	r28, 0x14	; 20
    367a:	0f b6       	in	r0, 0x3f	; 63
    367c:	f8 94       	cli
    367e:	de bf       	out	0x3e, r29	; 62
    3680:	0f be       	out	0x3f, r0	; 63
    3682:	cd bf       	out	0x3d, r28	; 61
    3684:	9f 83       	std	Y+7, r25	; 0x07
    3686:	8e 83       	std	Y+6, r24	; 0x06
    3688:	79 87       	std	Y+9, r23	; 0x09
    368a:	68 87       	std	Y+8, r22	; 0x08
    368c:	5b 87       	std	Y+11, r21	; 0x0b
    368e:	4a 87       	std	Y+10, r20	; 0x0a
    3690:	3d 87       	std	Y+13, r19	; 0x0d
    3692:	2c 87       	std	Y+12, r18	; 0x0c
    3694:	0e 87       	std	Y+14, r16	; 0x0e
    3696:	f8 8a       	std	Y+16, r15	; 0x10
    3698:	ef 86       	std	Y+15, r14	; 0x0f
    369a:	da 8a       	std	Y+18, r13	; 0x12
    369c:	c9 8a       	std	Y+17, r12	; 0x11
    369e:	bc 8a       	std	Y+20, r11	; 0x14
    36a0:	ab 8a       	std	Y+19, r10	; 0x13
	configASSERT( pxTaskCode );
	configASSERT( ( uxPriority < configMAX_PRIORITIES ) );

	/* Allocate the memory required by the TCB and stack for the new task,
	checking that the allocation was successful. */
	pxNewTCB = prvAllocateTCBAndStack( usStackDepth, puxStackBuffer );
    36a2:	8a 85       	ldd	r24, Y+10	; 0x0a
    36a4:	9b 85       	ldd	r25, Y+11	; 0x0b
    36a6:	29 89       	ldd	r18, Y+17	; 0x11
    36a8:	3a 89       	ldd	r19, Y+18	; 0x12
    36aa:	b9 01       	movw	r22, r18
    36ac:	0e 94 b5 21 	call	0x436a	; 0x436a <prvAllocateTCBAndStack>
    36b0:	9c 83       	std	Y+4, r25	; 0x04
    36b2:	8b 83       	std	Y+3, r24	; 0x03

	if( pxNewTCB != NULL )
    36b4:	8b 81       	ldd	r24, Y+3	; 0x03
    36b6:	9c 81       	ldd	r25, Y+4	; 0x04
    36b8:	00 97       	sbiw	r24, 0x00	; 0
    36ba:	09 f4       	brne	.+2      	; 0x36be <xTaskGenericCreate+0x5e>
    36bc:	99 c0       	rjmp	.+306    	; 0x37f0 <xTaskGenericCreate+0x190>
		stack grows from high memory to low (as per the 80x86) or visa versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
    36be:	eb 81       	ldd	r30, Y+3	; 0x03
    36c0:	fc 81       	ldd	r31, Y+4	; 0x04
    36c2:	27 89       	ldd	r18, Z+23	; 0x17
    36c4:	30 8d       	ldd	r19, Z+24	; 0x18
    36c6:	8a 85       	ldd	r24, Y+10	; 0x0a
    36c8:	9b 85       	ldd	r25, Y+11	; 0x0b
    36ca:	01 97       	sbiw	r24, 0x01	; 1
    36cc:	82 0f       	add	r24, r18
    36ce:	93 1f       	adc	r25, r19
    36d0:	9a 83       	std	Y+2, r25	; 0x02
    36d2:	89 83       	std	Y+1, r24	; 0x01
			pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
		}
		#endif

		/* Setup the newly allocated TCB with the initial state of the task. */
		prvInitialiseTCBVariables( pxNewTCB, pcName, uxPriority, xRegions, usStackDepth );
    36d4:	8b 81       	ldd	r24, Y+3	; 0x03
    36d6:	9c 81       	ldd	r25, Y+4	; 0x04
    36d8:	28 85       	ldd	r18, Y+8	; 0x08
    36da:	39 85       	ldd	r19, Y+9	; 0x09
    36dc:	eb 89       	ldd	r30, Y+19	; 0x13
    36de:	fc 89       	ldd	r31, Y+20	; 0x14
    36e0:	aa 85       	ldd	r26, Y+10	; 0x0a
    36e2:	bb 85       	ldd	r27, Y+11	; 0x0b
    36e4:	b9 01       	movw	r22, r18
    36e6:	4e 85       	ldd	r20, Y+14	; 0x0e
    36e8:	9f 01       	movw	r18, r30
    36ea:	8d 01       	movw	r16, r26
    36ec:	0e 94 9a 20 	call	0x4134	; 0x4134 <prvInitialiseTCBVariables>
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    36f0:	89 81       	ldd	r24, Y+1	; 0x01
    36f2:	9a 81       	ldd	r25, Y+2	; 0x02
    36f4:	2e 81       	ldd	r18, Y+6	; 0x06
    36f6:	3f 81       	ldd	r19, Y+7	; 0x07
    36f8:	4c 85       	ldd	r20, Y+12	; 0x0c
    36fa:	5d 85       	ldd	r21, Y+13	; 0x0d
    36fc:	b9 01       	movw	r22, r18
    36fe:	0e 94 dd 13 	call	0x27ba	; 0x27ba <pxPortInitialiseStack>
    3702:	eb 81       	ldd	r30, Y+3	; 0x03
    3704:	fc 81       	ldd	r31, Y+4	; 0x04
    3706:	91 83       	std	Z+1, r25	; 0x01
    3708:	80 83       	st	Z, r24
		#endif

		/* Check the alignment of the initialised stack. */
		configASSERT( ( ( ( unsigned long ) pxNewTCB->pxTopOfStack & ( unsigned long ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );

		if( ( void * ) pxCreatedTask != NULL )
    370a:	8f 85       	ldd	r24, Y+15	; 0x0f
    370c:	98 89       	ldd	r25, Y+16	; 0x10
    370e:	00 97       	sbiw	r24, 0x00	; 0
    3710:	31 f0       	breq	.+12     	; 0x371e <xTaskGenericCreate+0xbe>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
    3712:	ef 85       	ldd	r30, Y+15	; 0x0f
    3714:	f8 89       	ldd	r31, Y+16	; 0x10
    3716:	8b 81       	ldd	r24, Y+3	; 0x03
    3718:	9c 81       	ldd	r25, Y+4	; 0x04
    371a:	91 83       	std	Z+1, r25	; 0x01
    371c:	80 83       	st	Z, r24
		}
		
		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
    371e:	0f b6       	in	r0, 0x3f	; 63
    3720:	f8 94       	cli
    3722:	0f 92       	push	r0
		{
			uxCurrentNumberOfTasks++;
    3724:	80 91 95 06 	lds	r24, 0x0695
    3728:	8f 5f       	subi	r24, 0xFF	; 255
    372a:	80 93 95 06 	sts	0x0695, r24
			if( pxCurrentTCB == NULL )
    372e:	80 91 92 06 	lds	r24, 0x0692
    3732:	90 91 93 06 	lds	r25, 0x0693
    3736:	00 97       	sbiw	r24, 0x00	; 0
    3738:	69 f4       	brne	.+26     	; 0x3754 <xTaskGenericCreate+0xf4>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
    373a:	8b 81       	ldd	r24, Y+3	; 0x03
    373c:	9c 81       	ldd	r25, Y+4	; 0x04
    373e:	90 93 93 06 	sts	0x0693, r25
    3742:	80 93 92 06 	sts	0x0692, r24

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
    3746:	80 91 95 06 	lds	r24, 0x0695
    374a:	81 30       	cpi	r24, 0x01	; 1
    374c:	a9 f4       	brne	.+42     	; 0x3778 <xTaskGenericCreate+0x118>
				{
					/* This is the first task to be created so do the preliminary
					initialisation required.  We will not recover if this call
					fails, but we will report the failure. */
					prvInitialiseTaskLists();
    374e:	0e 94 f1 20 	call	0x41e2	; 0x41e2 <prvInitialiseTaskLists>
    3752:	12 c0       	rjmp	.+36     	; 0x3778 <xTaskGenericCreate+0x118>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
    3754:	80 91 9a 06 	lds	r24, 0x069A
    3758:	88 23       	and	r24, r24
    375a:	71 f4       	brne	.+28     	; 0x3778 <xTaskGenericCreate+0x118>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
    375c:	e0 91 92 06 	lds	r30, 0x0692
    3760:	f0 91 93 06 	lds	r31, 0x0693
    3764:	96 89       	ldd	r25, Z+22	; 0x16
    3766:	8e 85       	ldd	r24, Y+14	; 0x0e
    3768:	89 17       	cp	r24, r25
    376a:	30 f0       	brcs	.+12     	; 0x3778 <xTaskGenericCreate+0x118>
					{
						pxCurrentTCB = pxNewTCB;
    376c:	8b 81       	ldd	r24, Y+3	; 0x03
    376e:	9c 81       	ldd	r25, Y+4	; 0x04
    3770:	90 93 93 06 	sts	0x0693, r25
    3774:	80 93 92 06 	sts	0x0692, r24
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
    3778:	eb 81       	ldd	r30, Y+3	; 0x03
    377a:	fc 81       	ldd	r31, Y+4	; 0x04
    377c:	96 89       	ldd	r25, Z+22	; 0x16
    377e:	80 91 98 06 	lds	r24, 0x0698
    3782:	89 17       	cp	r24, r25
    3784:	28 f4       	brcc	.+10     	; 0x3790 <xTaskGenericCreate+0x130>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
    3786:	eb 81       	ldd	r30, Y+3	; 0x03
    3788:	fc 81       	ldd	r31, Y+4	; 0x04
    378a:	86 89       	ldd	r24, Z+22	; 0x16
    378c:	80 93 98 06 	sts	0x0698, r24
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
    3790:	80 91 9f 06 	lds	r24, 0x069F
    3794:	8f 5f       	subi	r24, 0xFF	; 255
    3796:	80 93 9f 06 	sts	0x069F, r24

			prvAddTaskToReadyQueue( pxNewTCB );
    379a:	eb 81       	ldd	r30, Y+3	; 0x03
    379c:	fc 81       	ldd	r31, Y+4	; 0x04
    379e:	96 89       	ldd	r25, Z+22	; 0x16
    37a0:	80 91 99 06 	lds	r24, 0x0699
    37a4:	89 17       	cp	r24, r25
    37a6:	28 f4       	brcc	.+10     	; 0x37b2 <xTaskGenericCreate+0x152>
    37a8:	eb 81       	ldd	r30, Y+3	; 0x03
    37aa:	fc 81       	ldd	r31, Y+4	; 0x04
    37ac:	86 89       	ldd	r24, Z+22	; 0x16
    37ae:	80 93 99 06 	sts	0x0699, r24
    37b2:	eb 81       	ldd	r30, Y+3	; 0x03
    37b4:	fc 81       	ldd	r31, Y+4	; 0x04
    37b6:	86 89       	ldd	r24, Z+22	; 0x16
    37b8:	28 2f       	mov	r18, r24
    37ba:	30 e0       	ldi	r19, 0x00	; 0
    37bc:	c9 01       	movw	r24, r18
    37be:	88 0f       	add	r24, r24
    37c0:	99 1f       	adc	r25, r25
    37c2:	88 0f       	add	r24, r24
    37c4:	99 1f       	adc	r25, r25
    37c6:	88 0f       	add	r24, r24
    37c8:	99 1f       	adc	r25, r25
    37ca:	82 0f       	add	r24, r18
    37cc:	93 1f       	adc	r25, r19
    37ce:	ac 01       	movw	r20, r24
    37d0:	40 56       	subi	r20, 0x60	; 96
    37d2:	59 4f       	sbci	r21, 0xF9	; 249
    37d4:	8b 81       	ldd	r24, Y+3	; 0x03
    37d6:	9c 81       	ldd	r25, Y+4	; 0x04
    37d8:	9c 01       	movw	r18, r24
    37da:	2e 5f       	subi	r18, 0xFE	; 254
    37dc:	3f 4f       	sbci	r19, 0xFF	; 255
    37de:	ca 01       	movw	r24, r20
    37e0:	b9 01       	movw	r22, r18
    37e2:	0e 94 dc 12 	call	0x25b8	; 0x25b8 <vListInsertEnd>

			xReturn = pdPASS;
    37e6:	81 e0       	ldi	r24, 0x01	; 1
    37e8:	8d 83       	std	Y+5, r24	; 0x05
			traceTASK_CREATE( pxNewTCB );
		}
		taskEXIT_CRITICAL();
    37ea:	0f 90       	pop	r0
    37ec:	0f be       	out	0x3f, r0	; 63
    37ee:	02 c0       	rjmp	.+4      	; 0x37f4 <xTaskGenericCreate+0x194>
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    37f0:	8f ef       	ldi	r24, 0xFF	; 255
    37f2:	8d 83       	std	Y+5, r24	; 0x05
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
    37f4:	8d 81       	ldd	r24, Y+5	; 0x05
    37f6:	81 30       	cpi	r24, 0x01	; 1
    37f8:	71 f4       	brne	.+28     	; 0x3816 <xTaskGenericCreate+0x1b6>
	{
		if( xSchedulerRunning != pdFALSE )
    37fa:	80 91 9a 06 	lds	r24, 0x069A
    37fe:	88 23       	and	r24, r24
    3800:	51 f0       	breq	.+20     	; 0x3816 <xTaskGenericCreate+0x1b6>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
    3802:	e0 91 92 06 	lds	r30, 0x0692
    3806:	f0 91 93 06 	lds	r31, 0x0693
    380a:	96 89       	ldd	r25, Z+22	; 0x16
    380c:	8e 85       	ldd	r24, Y+14	; 0x0e
    380e:	98 17       	cp	r25, r24
    3810:	10 f4       	brcc	.+4      	; 0x3816 <xTaskGenericCreate+0x1b6>
			{
				portYIELD_WITHIN_API();
    3812:	0e 94 9c 15 	call	0x2b38	; 0x2b38 <vPortYield>
			}
		}
	}

	return xReturn;
    3816:	8d 81       	ldd	r24, Y+5	; 0x05
}
    3818:	64 96       	adiw	r28, 0x14	; 20
    381a:	0f b6       	in	r0, 0x3f	; 63
    381c:	f8 94       	cli
    381e:	de bf       	out	0x3e, r29	; 62
    3820:	0f be       	out	0x3f, r0	; 63
    3822:	cd bf       	out	0x3d, r28	; 61
    3824:	cf 91       	pop	r28
    3826:	df 91       	pop	r29
    3828:	1f 91       	pop	r17
    382a:	0f 91       	pop	r16
    382c:	ff 90       	pop	r15
    382e:	ef 90       	pop	r14
    3830:	df 90       	pop	r13
    3832:	cf 90       	pop	r12
    3834:	bf 90       	pop	r11
    3836:	af 90       	pop	r10
    3838:	08 95       	ret

0000383a <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( xTaskHandle pxTaskToDelete )
	{
    383a:	df 93       	push	r29
    383c:	cf 93       	push	r28
    383e:	00 d0       	rcall	.+0      	; 0x3840 <vTaskDelete+0x6>
    3840:	00 d0       	rcall	.+0      	; 0x3842 <vTaskDelete+0x8>
    3842:	00 d0       	rcall	.+0      	; 0x3844 <vTaskDelete+0xa>
    3844:	cd b7       	in	r28, 0x3d	; 61
    3846:	de b7       	in	r29, 0x3e	; 62
    3848:	9c 83       	std	Y+4, r25	; 0x04
    384a:	8b 83       	std	Y+3, r24	; 0x03
	tskTCB *pxTCB;

		taskENTER_CRITICAL();
    384c:	0f b6       	in	r0, 0x3f	; 63
    384e:	f8 94       	cli
    3850:	0f 92       	push	r0
		{
			/* Ensure a yield is performed if the current task is being
			deleted. */
			if( pxTaskToDelete == pxCurrentTCB )
    3852:	20 91 92 06 	lds	r18, 0x0692
    3856:	30 91 93 06 	lds	r19, 0x0693
    385a:	8b 81       	ldd	r24, Y+3	; 0x03
    385c:	9c 81       	ldd	r25, Y+4	; 0x04
    385e:	82 17       	cp	r24, r18
    3860:	93 07       	cpc	r25, r19
    3862:	11 f4       	brne	.+4      	; 0x3868 <vTaskDelete+0x2e>
			{
				pxTaskToDelete = NULL;
    3864:	1c 82       	std	Y+4, r1	; 0x04
    3866:	1b 82       	std	Y+3, r1	; 0x03
			}

			/* If null is passed in here then we are deleting ourselves. */
			pxTCB = prvGetTCBFromHandle( pxTaskToDelete );
    3868:	8b 81       	ldd	r24, Y+3	; 0x03
    386a:	9c 81       	ldd	r25, Y+4	; 0x04
    386c:	00 97       	sbiw	r24, 0x00	; 0
    386e:	39 f4       	brne	.+14     	; 0x387e <vTaskDelete+0x44>
    3870:	80 91 92 06 	lds	r24, 0x0692
    3874:	90 91 93 06 	lds	r25, 0x0693
    3878:	9e 83       	std	Y+6, r25	; 0x06
    387a:	8d 83       	std	Y+5, r24	; 0x05
    387c:	04 c0       	rjmp	.+8      	; 0x3886 <vTaskDelete+0x4c>
    387e:	8b 81       	ldd	r24, Y+3	; 0x03
    3880:	9c 81       	ldd	r25, Y+4	; 0x04
    3882:	9e 83       	std	Y+6, r25	; 0x06
    3884:	8d 83       	std	Y+5, r24	; 0x05
    3886:	8d 81       	ldd	r24, Y+5	; 0x05
    3888:	9e 81       	ldd	r25, Y+6	; 0x06
    388a:	9a 83       	std	Y+2, r25	; 0x02
    388c:	89 83       	std	Y+1, r24	; 0x01

			/* Remove task from the ready list and place in the	termination list.
			This will stop the task from be scheduled.  The idle task will check
			the termination list and free up any memory allocated by the
			scheduler for the TCB and stack. */
			vListRemove( &( pxTCB->xGenericListItem ) );
    388e:	89 81       	ldd	r24, Y+1	; 0x01
    3890:	9a 81       	ldd	r25, Y+2	; 0x02
    3892:	02 96       	adiw	r24, 0x02	; 2
    3894:	0e 94 94 13 	call	0x2728	; 0x2728 <vListRemove>

			/* Is the task waiting on an event also? */
			if( pxTCB->xEventListItem.pvContainer != NULL )
    3898:	e9 81       	ldd	r30, Y+1	; 0x01
    389a:	fa 81       	ldd	r31, Y+2	; 0x02
    389c:	84 89       	ldd	r24, Z+20	; 0x14
    389e:	95 89       	ldd	r25, Z+21	; 0x15
    38a0:	00 97       	sbiw	r24, 0x00	; 0
    38a2:	29 f0       	breq	.+10     	; 0x38ae <vTaskDelete+0x74>
			{
				vListRemove( &( pxTCB->xEventListItem ) );
    38a4:	89 81       	ldd	r24, Y+1	; 0x01
    38a6:	9a 81       	ldd	r25, Y+2	; 0x02
    38a8:	0c 96       	adiw	r24, 0x0c	; 12
    38aa:	0e 94 94 13 	call	0x2728	; 0x2728 <vListRemove>
			}

			vListInsertEnd( ( xList * ) &xTasksWaitingTermination, &( pxTCB->xGenericListItem ) );
    38ae:	89 81       	ldd	r24, Y+1	; 0x01
    38b0:	9a 81       	ldd	r25, Y+2	; 0x02
    38b2:	9c 01       	movw	r18, r24
    38b4:	2e 5f       	subi	r18, 0xFE	; 254
    38b6:	3f 4f       	sbci	r19, 0xFF	; 255
    38b8:	8c ee       	ldi	r24, 0xEC	; 236
    38ba:	96 e0       	ldi	r25, 0x06	; 6
    38bc:	b9 01       	movw	r22, r18
    38be:	0e 94 dc 12 	call	0x25b8	; 0x25b8 <vListInsertEnd>

			/* Increment the ucTasksDeleted variable so the idle task knows
			there is a task that has been deleted and that it should therefore
			check the xTasksWaitingTermination list. */
			++uxTasksDeleted;
    38c2:	80 91 94 06 	lds	r24, 0x0694
    38c6:	8f 5f       	subi	r24, 0xFF	; 255
    38c8:	80 93 94 06 	sts	0x0694, r24

			/* Increment the uxTaskNumberVariable also so kernel aware debuggers
			can detect that the task lists need re-generating. */
			uxTaskNumber++;
    38cc:	80 91 9f 06 	lds	r24, 0x069F
    38d0:	8f 5f       	subi	r24, 0xFF	; 255
    38d2:	80 93 9f 06 	sts	0x069F, r24

			traceTASK_DELETE( pxTCB );
		}
		taskEXIT_CRITICAL();
    38d6:	0f 90       	pop	r0
    38d8:	0f be       	out	0x3f, r0	; 63

		/* Force a reschedule if we have just deleted the current task. */
		if( xSchedulerRunning != pdFALSE )
    38da:	80 91 9a 06 	lds	r24, 0x069A
    38de:	88 23       	and	r24, r24
    38e0:	31 f0       	breq	.+12     	; 0x38ee <vTaskDelete+0xb4>
		{
			if( ( void * ) pxTaskToDelete == NULL )
    38e2:	8b 81       	ldd	r24, Y+3	; 0x03
    38e4:	9c 81       	ldd	r25, Y+4	; 0x04
    38e6:	00 97       	sbiw	r24, 0x00	; 0
    38e8:	11 f4       	brne	.+4      	; 0x38ee <vTaskDelete+0xb4>
			{
				portYIELD_WITHIN_API();
    38ea:	0e 94 9c 15 	call	0x2b38	; 0x2b38 <vPortYield>
			}
		}
	}
    38ee:	26 96       	adiw	r28, 0x06	; 6
    38f0:	0f b6       	in	r0, 0x3f	; 63
    38f2:	f8 94       	cli
    38f4:	de bf       	out	0x3e, r29	; 62
    38f6:	0f be       	out	0x3f, r0	; 63
    38f8:	cd bf       	out	0x3d, r28	; 61
    38fa:	cf 91       	pop	r28
    38fc:	df 91       	pop	r29
    38fe:	08 95       	ret

00003900 <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
    3900:	df 93       	push	r29
    3902:	cf 93       	push	r28
    3904:	cd b7       	in	r28, 0x3d	; 61
    3906:	de b7       	in	r29, 0x3e	; 62
    3908:	28 97       	sbiw	r28, 0x08	; 8
    390a:	0f b6       	in	r0, 0x3f	; 63
    390c:	f8 94       	cli
    390e:	de bf       	out	0x3e, r29	; 62
    3910:	0f be       	out	0x3f, r0	; 63
    3912:	cd bf       	out	0x3d, r28	; 61
    3914:	9e 83       	std	Y+6, r25	; 0x06
    3916:	8d 83       	std	Y+5, r24	; 0x05
    3918:	78 87       	std	Y+8, r23	; 0x08
    391a:	6f 83       	std	Y+7, r22	; 0x07
	portTickType xTimeToWake;
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;
    391c:	19 82       	std	Y+1, r1	; 0x01

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );

		vTaskSuspendAll();
    391e:	0e 94 6c 1d 	call	0x3ad8	; 0x3ad8 <vTaskSuspendAll>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    3922:	ed 81       	ldd	r30, Y+5	; 0x05
    3924:	fe 81       	ldd	r31, Y+6	; 0x06
    3926:	20 81       	ld	r18, Z
    3928:	31 81       	ldd	r19, Z+1	; 0x01
    392a:	8f 81       	ldd	r24, Y+7	; 0x07
    392c:	98 85       	ldd	r25, Y+8	; 0x08
    392e:	82 0f       	add	r24, r18
    3930:	93 1f       	adc	r25, r19
    3932:	9c 83       	std	Y+4, r25	; 0x04
    3934:	8b 83       	std	Y+3, r24	; 0x03

			if( xTickCount < *pxPreviousWakeTime )
    3936:	ed 81       	ldd	r30, Y+5	; 0x05
    3938:	fe 81       	ldd	r31, Y+6	; 0x06
    393a:	20 81       	ld	r18, Z
    393c:	31 81       	ldd	r19, Z+1	; 0x01
    393e:	80 91 96 06 	lds	r24, 0x0696
    3942:	90 91 97 06 	lds	r25, 0x0697
    3946:	82 17       	cp	r24, r18
    3948:	93 07       	cpc	r25, r19
    394a:	a8 f4       	brcc	.+42     	; 0x3976 <vTaskDelayUntil+0x76>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
    394c:	ed 81       	ldd	r30, Y+5	; 0x05
    394e:	fe 81       	ldd	r31, Y+6	; 0x06
    3950:	20 81       	ld	r18, Z
    3952:	31 81       	ldd	r19, Z+1	; 0x01
    3954:	8b 81       	ldd	r24, Y+3	; 0x03
    3956:	9c 81       	ldd	r25, Y+4	; 0x04
    3958:	82 17       	cp	r24, r18
    395a:	93 07       	cpc	r25, r19
    395c:	00 f5       	brcc	.+64     	; 0x399e <vTaskDelayUntil+0x9e>
    395e:	20 91 96 06 	lds	r18, 0x0696
    3962:	30 91 97 06 	lds	r19, 0x0697
    3966:	8b 81       	ldd	r24, Y+3	; 0x03
    3968:	9c 81       	ldd	r25, Y+4	; 0x04
    396a:	28 17       	cp	r18, r24
    396c:	39 07       	cpc	r19, r25
    396e:	b8 f4       	brcc	.+46     	; 0x399e <vTaskDelayUntil+0x9e>
				{
					xShouldDelay = pdTRUE;
    3970:	81 e0       	ldi	r24, 0x01	; 1
    3972:	89 83       	std	Y+1, r24	; 0x01
    3974:	14 c0       	rjmp	.+40     	; 0x399e <vTaskDelayUntil+0x9e>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
    3976:	ed 81       	ldd	r30, Y+5	; 0x05
    3978:	fe 81       	ldd	r31, Y+6	; 0x06
    397a:	20 81       	ld	r18, Z
    397c:	31 81       	ldd	r19, Z+1	; 0x01
    397e:	8b 81       	ldd	r24, Y+3	; 0x03
    3980:	9c 81       	ldd	r25, Y+4	; 0x04
    3982:	82 17       	cp	r24, r18
    3984:	93 07       	cpc	r25, r19
    3986:	48 f0       	brcs	.+18     	; 0x399a <vTaskDelayUntil+0x9a>
    3988:	20 91 96 06 	lds	r18, 0x0696
    398c:	30 91 97 06 	lds	r19, 0x0697
    3990:	8b 81       	ldd	r24, Y+3	; 0x03
    3992:	9c 81       	ldd	r25, Y+4	; 0x04
    3994:	28 17       	cp	r18, r24
    3996:	39 07       	cpc	r19, r25
    3998:	10 f4       	brcc	.+4      	; 0x399e <vTaskDelayUntil+0x9e>
				{
					xShouldDelay = pdTRUE;
    399a:	81 e0       	ldi	r24, 0x01	; 1
    399c:	89 83       	std	Y+1, r24	; 0x01
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    399e:	ed 81       	ldd	r30, Y+5	; 0x05
    39a0:	fe 81       	ldd	r31, Y+6	; 0x06
    39a2:	8b 81       	ldd	r24, Y+3	; 0x03
    39a4:	9c 81       	ldd	r25, Y+4	; 0x04
    39a6:	91 83       	std	Z+1, r25	; 0x01
    39a8:	80 83       	st	Z, r24

			if( xShouldDelay != pdFALSE )
    39aa:	89 81       	ldd	r24, Y+1	; 0x01
    39ac:	88 23       	and	r24, r24
    39ae:	59 f0       	breq	.+22     	; 0x39c6 <vTaskDelayUntil+0xc6>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    39b0:	80 91 92 06 	lds	r24, 0x0692
    39b4:	90 91 93 06 	lds	r25, 0x0693
    39b8:	02 96       	adiw	r24, 0x02	; 2
    39ba:	0e 94 94 13 	call	0x2728	; 0x2728 <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    39be:	8b 81       	ldd	r24, Y+3	; 0x03
    39c0:	9c 81       	ldd	r25, Y+4	; 0x04
    39c2:	0e 94 6c 21 	call	0x42d8	; 0x42d8 <prvAddCurrentTaskToDelayedList>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    39c6:	0e 94 78 1d 	call	0x3af0	; 0x3af0 <xTaskResumeAll>
    39ca:	8a 83       	std	Y+2, r24	; 0x02

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    39cc:	8a 81       	ldd	r24, Y+2	; 0x02
    39ce:	88 23       	and	r24, r24
    39d0:	11 f4       	brne	.+4      	; 0x39d6 <vTaskDelayUntil+0xd6>
		{
			portYIELD_WITHIN_API();
    39d2:	0e 94 9c 15 	call	0x2b38	; 0x2b38 <vPortYield>
		}
	}
    39d6:	28 96       	adiw	r28, 0x08	; 8
    39d8:	0f b6       	in	r0, 0x3f	; 63
    39da:	f8 94       	cli
    39dc:	de bf       	out	0x3e, r29	; 62
    39de:	0f be       	out	0x3f, r0	; 63
    39e0:	cd bf       	out	0x3d, r28	; 61
    39e2:	cf 91       	pop	r28
    39e4:	df 91       	pop	r29
    39e6:	08 95       	ret

000039e8 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
    39e8:	df 93       	push	r29
    39ea:	cf 93       	push	r28
    39ec:	00 d0       	rcall	.+0      	; 0x39ee <vTaskDelay+0x6>
    39ee:	00 d0       	rcall	.+0      	; 0x39f0 <vTaskDelay+0x8>
    39f0:	0f 92       	push	r0
    39f2:	cd b7       	in	r28, 0x3d	; 61
    39f4:	de b7       	in	r29, 0x3e	; 62
    39f6:	9d 83       	std	Y+5, r25	; 0x05
    39f8:	8c 83       	std	Y+4, r24	; 0x04
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;
    39fa:	19 82       	std	Y+1, r1	; 0x01

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0U )
    39fc:	8c 81       	ldd	r24, Y+4	; 0x04
    39fe:	9d 81       	ldd	r25, Y+5	; 0x05
    3a00:	00 97       	sbiw	r24, 0x00	; 0
    3a02:	d1 f0       	breq	.+52     	; 0x3a38 <vTaskDelay+0x50>
		{
			vTaskSuspendAll();
    3a04:	0e 94 6c 1d 	call	0x3ad8	; 0x3ad8 <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    3a08:	20 91 96 06 	lds	r18, 0x0696
    3a0c:	30 91 97 06 	lds	r19, 0x0697
    3a10:	8c 81       	ldd	r24, Y+4	; 0x04
    3a12:	9d 81       	ldd	r25, Y+5	; 0x05
    3a14:	82 0f       	add	r24, r18
    3a16:	93 1f       	adc	r25, r19
    3a18:	9b 83       	std	Y+3, r25	; 0x03
    3a1a:	8a 83       	std	Y+2, r24	; 0x02

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    3a1c:	80 91 92 06 	lds	r24, 0x0692
    3a20:	90 91 93 06 	lds	r25, 0x0693
    3a24:	02 96       	adiw	r24, 0x02	; 2
    3a26:	0e 94 94 13 	call	0x2728	; 0x2728 <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    3a2a:	8a 81       	ldd	r24, Y+2	; 0x02
    3a2c:	9b 81       	ldd	r25, Y+3	; 0x03
    3a2e:	0e 94 6c 21 	call	0x42d8	; 0x42d8 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    3a32:	0e 94 78 1d 	call	0x3af0	; 0x3af0 <xTaskResumeAll>
    3a36:	89 83       	std	Y+1, r24	; 0x01
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    3a38:	89 81       	ldd	r24, Y+1	; 0x01
    3a3a:	88 23       	and	r24, r24
    3a3c:	11 f4       	brne	.+4      	; 0x3a42 <vTaskDelay+0x5a>
		{
			portYIELD_WITHIN_API();
    3a3e:	0e 94 9c 15 	call	0x2b38	; 0x2b38 <vPortYield>
		}
	}
    3a42:	0f 90       	pop	r0
    3a44:	0f 90       	pop	r0
    3a46:	0f 90       	pop	r0
    3a48:	0f 90       	pop	r0
    3a4a:	0f 90       	pop	r0
    3a4c:	cf 91       	pop	r28
    3a4e:	df 91       	pop	r29
    3a50:	08 95       	ret

00003a52 <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
    3a52:	af 92       	push	r10
    3a54:	bf 92       	push	r11
    3a56:	cf 92       	push	r12
    3a58:	df 92       	push	r13
    3a5a:	ef 92       	push	r14
    3a5c:	ff 92       	push	r15
    3a5e:	0f 93       	push	r16
    3a60:	df 93       	push	r29
    3a62:	cf 93       	push	r28
    3a64:	0f 92       	push	r0
    3a66:	cd b7       	in	r28, 0x3d	; 61
    3a68:	de b7       	in	r29, 0x3e	; 62
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle );
	}
	#else
	{
		/* Create the idle task without storing its handle. */
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), NULL );
    3a6a:	2a e6       	ldi	r18, 0x6A	; 106
    3a6c:	30 e0       	ldi	r19, 0x00	; 0
    3a6e:	80 e9       	ldi	r24, 0x90	; 144
    3a70:	90 e2       	ldi	r25, 0x20	; 32
    3a72:	b9 01       	movw	r22, r18
    3a74:	45 e5       	ldi	r20, 0x55	; 85
    3a76:	50 e0       	ldi	r21, 0x00	; 0
    3a78:	20 e0       	ldi	r18, 0x00	; 0
    3a7a:	30 e0       	ldi	r19, 0x00	; 0
    3a7c:	00 e0       	ldi	r16, 0x00	; 0
    3a7e:	ee 24       	eor	r14, r14
    3a80:	ff 24       	eor	r15, r15
    3a82:	cc 24       	eor	r12, r12
    3a84:	dd 24       	eor	r13, r13
    3a86:	aa 24       	eor	r10, r10
    3a88:	bb 24       	eor	r11, r11
    3a8a:	0e 94 30 1b 	call	0x3660	; 0x3660 <xTaskGenericCreate>
    3a8e:	89 83       	std	Y+1, r24	; 0x01
			xReturn = xTimerCreateTimerTask();
		}
	}
	#endif

	if( xReturn == pdPASS )
    3a90:	89 81       	ldd	r24, Y+1	; 0x01
    3a92:	81 30       	cpi	r24, 0x01	; 1
    3a94:	51 f4       	brne	.+20     	; 0x3aaa <vTaskStartScheduler+0x58>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
    3a96:	f8 94       	cli

		xSchedulerRunning = pdTRUE;
    3a98:	81 e0       	ldi	r24, 0x01	; 1
    3a9a:	80 93 9a 06 	sts	0x069A, r24
		xTickCount = ( portTickType ) 0U;
    3a9e:	10 92 97 06 	sts	0x0697, r1
    3aa2:	10 92 96 06 	sts	0x0696, r1
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();
		
		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
    3aa6:	0e 94 60 15 	call	0x2ac0	; 0x2ac0 <xPortStartScheduler>
		}
	}

	/* This line will only be reached if the kernel could not be started. */
	configASSERT( xReturn );
}
    3aaa:	0f 90       	pop	r0
    3aac:	cf 91       	pop	r28
    3aae:	df 91       	pop	r29
    3ab0:	0f 91       	pop	r16
    3ab2:	ff 90       	pop	r15
    3ab4:	ef 90       	pop	r14
    3ab6:	df 90       	pop	r13
    3ab8:	cf 90       	pop	r12
    3aba:	bf 90       	pop	r11
    3abc:	af 90       	pop	r10
    3abe:	08 95       	ret

00003ac0 <vTaskEndScheduler>:
/*-----------------------------------------------------------*/

void vTaskEndScheduler( void )
{
    3ac0:	df 93       	push	r29
    3ac2:	cf 93       	push	r28
    3ac4:	cd b7       	in	r28, 0x3d	; 61
    3ac6:	de b7       	in	r29, 0x3e	; 62
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
    3ac8:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
    3aca:	10 92 9a 06 	sts	0x069A, r1
	vPortEndScheduler();
    3ace:	0e 94 95 15 	call	0x2b2a	; 0x2b2a <vPortEndScheduler>
}
    3ad2:	cf 91       	pop	r28
    3ad4:	df 91       	pop	r29
    3ad6:	08 95       	ret

00003ad8 <vTaskSuspendAll>:
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
    3ad8:	df 93       	push	r29
    3ada:	cf 93       	push	r28
    3adc:	cd b7       	in	r28, 0x3d	; 61
    3ade:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
    3ae0:	80 91 9b 06 	lds	r24, 0x069B
    3ae4:	8f 5f       	subi	r24, 0xFF	; 255
    3ae6:	80 93 9b 06 	sts	0x069B, r24
}
    3aea:	cf 91       	pop	r28
    3aec:	df 91       	pop	r29
    3aee:	08 95       	ret

00003af0 <xTaskResumeAll>:
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
    3af0:	df 93       	push	r29
    3af2:	cf 93       	push	r28
    3af4:	00 d0       	rcall	.+0      	; 0x3af6 <xTaskResumeAll+0x6>
    3af6:	00 d0       	rcall	.+0      	; 0x3af8 <xTaskResumeAll+0x8>
    3af8:	cd b7       	in	r28, 0x3d	; 61
    3afa:	de b7       	in	r29, 0x3e	; 62
register tskTCB *pxTCB;
signed portBASE_TYPE xAlreadyYielded = pdFALSE;
    3afc:	1a 82       	std	Y+2, r1	; 0x02
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    3afe:	0f b6       	in	r0, 0x3f	; 63
    3b00:	f8 94       	cli
    3b02:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    3b04:	80 91 9b 06 	lds	r24, 0x069B
    3b08:	81 50       	subi	r24, 0x01	; 1
    3b0a:	80 93 9b 06 	sts	0x069B, r24

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    3b0e:	80 91 9b 06 	lds	r24, 0x069B
    3b12:	88 23       	and	r24, r24
    3b14:	09 f0       	breq	.+2      	; 0x3b18 <xTaskResumeAll+0x28>
    3b16:	6c c0       	rjmp	.+216    	; 0x3bf0 <xTaskResumeAll+0x100>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
    3b18:	80 91 95 06 	lds	r24, 0x0695
    3b1c:	88 23       	and	r24, r24
    3b1e:	09 f4       	brne	.+2      	; 0x3b22 <xTaskResumeAll+0x32>
    3b20:	67 c0       	rjmp	.+206    	; 0x3bf0 <xTaskResumeAll+0x100>
			{
				portBASE_TYPE xYieldRequired = pdFALSE;
    3b22:	19 82       	std	Y+1, r1	; 0x01
    3b24:	41 c0       	rjmp	.+130    	; 0x3ba8 <xTaskResumeAll+0xb8>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
    3b26:	e0 91 e8 06 	lds	r30, 0x06E8
    3b2a:	f0 91 e9 06 	lds	r31, 0x06E9
    3b2e:	86 81       	ldd	r24, Z+6	; 0x06
    3b30:	97 81       	ldd	r25, Z+7	; 0x07
    3b32:	9c 83       	std	Y+4, r25	; 0x04
    3b34:	8b 83       	std	Y+3, r24	; 0x03
					vListRemove( &( pxTCB->xEventListItem ) );
    3b36:	8b 81       	ldd	r24, Y+3	; 0x03
    3b38:	9c 81       	ldd	r25, Y+4	; 0x04
    3b3a:	0c 96       	adiw	r24, 0x0c	; 12
    3b3c:	0e 94 94 13 	call	0x2728	; 0x2728 <vListRemove>
					vListRemove( &( pxTCB->xGenericListItem ) );
    3b40:	8b 81       	ldd	r24, Y+3	; 0x03
    3b42:	9c 81       	ldd	r25, Y+4	; 0x04
    3b44:	02 96       	adiw	r24, 0x02	; 2
    3b46:	0e 94 94 13 	call	0x2728	; 0x2728 <vListRemove>
					prvAddTaskToReadyQueue( pxTCB );
    3b4a:	eb 81       	ldd	r30, Y+3	; 0x03
    3b4c:	fc 81       	ldd	r31, Y+4	; 0x04
    3b4e:	96 89       	ldd	r25, Z+22	; 0x16
    3b50:	80 91 99 06 	lds	r24, 0x0699
    3b54:	89 17       	cp	r24, r25
    3b56:	28 f4       	brcc	.+10     	; 0x3b62 <xTaskResumeAll+0x72>
    3b58:	eb 81       	ldd	r30, Y+3	; 0x03
    3b5a:	fc 81       	ldd	r31, Y+4	; 0x04
    3b5c:	86 89       	ldd	r24, Z+22	; 0x16
    3b5e:	80 93 99 06 	sts	0x0699, r24
    3b62:	eb 81       	ldd	r30, Y+3	; 0x03
    3b64:	fc 81       	ldd	r31, Y+4	; 0x04
    3b66:	86 89       	ldd	r24, Z+22	; 0x16
    3b68:	28 2f       	mov	r18, r24
    3b6a:	30 e0       	ldi	r19, 0x00	; 0
    3b6c:	c9 01       	movw	r24, r18
    3b6e:	88 0f       	add	r24, r24
    3b70:	99 1f       	adc	r25, r25
    3b72:	88 0f       	add	r24, r24
    3b74:	99 1f       	adc	r25, r25
    3b76:	88 0f       	add	r24, r24
    3b78:	99 1f       	adc	r25, r25
    3b7a:	82 0f       	add	r24, r18
    3b7c:	93 1f       	adc	r25, r19
    3b7e:	80 56       	subi	r24, 0x60	; 96
    3b80:	99 4f       	sbci	r25, 0xF9	; 249
    3b82:	2b 81       	ldd	r18, Y+3	; 0x03
    3b84:	3c 81       	ldd	r19, Y+4	; 0x04
    3b86:	2e 5f       	subi	r18, 0xFE	; 254
    3b88:	3f 4f       	sbci	r19, 0xFF	; 255
    3b8a:	b9 01       	movw	r22, r18
    3b8c:	0e 94 dc 12 	call	0x25b8	; 0x25b8 <vListInsertEnd>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    3b90:	eb 81       	ldd	r30, Y+3	; 0x03
    3b92:	fc 81       	ldd	r31, Y+4	; 0x04
    3b94:	96 89       	ldd	r25, Z+22	; 0x16
    3b96:	e0 91 92 06 	lds	r30, 0x0692
    3b9a:	f0 91 93 06 	lds	r31, 0x0693
    3b9e:	86 89       	ldd	r24, Z+22	; 0x16
    3ba0:	98 17       	cp	r25, r24
    3ba2:	10 f0       	brcs	.+4      	; 0x3ba8 <xTaskResumeAll+0xb8>
					{
						xYieldRequired = pdTRUE;
    3ba4:	81 e0       	ldi	r24, 0x01	; 1
    3ba6:	89 83       	std	Y+1, r24	; 0x01
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
    3ba8:	80 91 e3 06 	lds	r24, 0x06E3
    3bac:	88 23       	and	r24, r24
    3bae:	09 f0       	breq	.+2      	; 0x3bb2 <xTaskResumeAll+0xc2>
    3bb0:	ba cf       	rjmp	.-140    	; 0x3b26 <xTaskResumeAll+0x36>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    3bb2:	80 91 9c 06 	lds	r24, 0x069C
    3bb6:	88 23       	and	r24, r24
    3bb8:	71 f0       	breq	.+28     	; 0x3bd6 <xTaskResumeAll+0xe6>
    3bba:	07 c0       	rjmp	.+14     	; 0x3bca <xTaskResumeAll+0xda>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
					{
						vTaskIncrementTick();
    3bbc:	0e 94 37 1e 	call	0x3c6e	; 0x3c6e <vTaskIncrementTick>
						--uxMissedTicks;
    3bc0:	80 91 9c 06 	lds	r24, 0x069C
    3bc4:	81 50       	subi	r24, 0x01	; 1
    3bc6:	80 93 9c 06 	sts	0x069C, r24
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    3bca:	80 91 9c 06 	lds	r24, 0x069C
    3bce:	88 23       	and	r24, r24
    3bd0:	a9 f7       	brne	.-22     	; 0x3bbc <xTaskResumeAll+0xcc>
					/* As we have processed some ticks it is appropriate to yield
					to ensure the highest priority task that is ready to run is
					the task actually running. */
					#if configUSE_PREEMPTION == 1
					{
						xYieldRequired = pdTRUE;
    3bd2:	81 e0       	ldi	r24, 0x01	; 1
    3bd4:	89 83       	std	Y+1, r24	; 0x01
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
    3bd6:	89 81       	ldd	r24, Y+1	; 0x01
    3bd8:	81 30       	cpi	r24, 0x01	; 1
    3bda:	21 f0       	breq	.+8      	; 0x3be4 <xTaskResumeAll+0xf4>
    3bdc:	80 91 9d 06 	lds	r24, 0x069D
    3be0:	81 30       	cpi	r24, 0x01	; 1
    3be2:	31 f4       	brne	.+12     	; 0x3bf0 <xTaskResumeAll+0x100>
				{
					xAlreadyYielded = pdTRUE;
    3be4:	81 e0       	ldi	r24, 0x01	; 1
    3be6:	8a 83       	std	Y+2, r24	; 0x02
					xMissedYield = pdFALSE;
    3be8:	10 92 9d 06 	sts	0x069D, r1
					portYIELD_WITHIN_API();
    3bec:	0e 94 9c 15 	call	0x2b38	; 0x2b38 <vPortYield>
				}
			}
		}
	}
	taskEXIT_CRITICAL();
    3bf0:	0f 90       	pop	r0
    3bf2:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
    3bf4:	8a 81       	ldd	r24, Y+2	; 0x02
}
    3bf6:	0f 90       	pop	r0
    3bf8:	0f 90       	pop	r0
    3bfa:	0f 90       	pop	r0
    3bfc:	0f 90       	pop	r0
    3bfe:	cf 91       	pop	r28
    3c00:	df 91       	pop	r29
    3c02:	08 95       	ret

00003c04 <xTaskGetTickCount>:
 *----------------------------------------------------------*/



portTickType xTaskGetTickCount( void )
{
    3c04:	df 93       	push	r29
    3c06:	cf 93       	push	r28
    3c08:	00 d0       	rcall	.+0      	; 0x3c0a <xTaskGetTickCount+0x6>
    3c0a:	cd b7       	in	r28, 0x3d	; 61
    3c0c:	de b7       	in	r29, 0x3e	; 62
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
    3c0e:	0f b6       	in	r0, 0x3f	; 63
    3c10:	f8 94       	cli
    3c12:	0f 92       	push	r0
	{
		xTicks = xTickCount;
    3c14:	80 91 96 06 	lds	r24, 0x0696
    3c18:	90 91 97 06 	lds	r25, 0x0697
    3c1c:	9a 83       	std	Y+2, r25	; 0x02
    3c1e:	89 83       	std	Y+1, r24	; 0x01
	}
	taskEXIT_CRITICAL();
    3c20:	0f 90       	pop	r0
    3c22:	0f be       	out	0x3f, r0	; 63

	return xTicks;
    3c24:	89 81       	ldd	r24, Y+1	; 0x01
    3c26:	9a 81       	ldd	r25, Y+2	; 0x02
}
    3c28:	0f 90       	pop	r0
    3c2a:	0f 90       	pop	r0
    3c2c:	cf 91       	pop	r28
    3c2e:	df 91       	pop	r29
    3c30:	08 95       	ret

00003c32 <xTaskGetTickCountFromISR>:
/*-----------------------------------------------------------*/

portTickType xTaskGetTickCountFromISR( void )
{
    3c32:	df 93       	push	r29
    3c34:	cf 93       	push	r28
    3c36:	00 d0       	rcall	.+0      	; 0x3c38 <xTaskGetTickCountFromISR+0x6>
    3c38:	0f 92       	push	r0
    3c3a:	cd b7       	in	r28, 0x3d	; 61
    3c3c:	de b7       	in	r29, 0x3e	; 62
portTickType xReturn;
unsigned portBASE_TYPE uxSavedInterruptStatus;

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    3c3e:	19 82       	std	Y+1, r1	; 0x01
	xReturn = xTickCount;
    3c40:	80 91 96 06 	lds	r24, 0x0696
    3c44:	90 91 97 06 	lds	r25, 0x0697
    3c48:	9b 83       	std	Y+3, r25	; 0x03
    3c4a:	8a 83       	std	Y+2, r24	; 0x02
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    3c4c:	8a 81       	ldd	r24, Y+2	; 0x02
    3c4e:	9b 81       	ldd	r25, Y+3	; 0x03
}
    3c50:	0f 90       	pop	r0
    3c52:	0f 90       	pop	r0
    3c54:	0f 90       	pop	r0
    3c56:	cf 91       	pop	r28
    3c58:	df 91       	pop	r29
    3c5a:	08 95       	ret

00003c5c <uxTaskGetNumberOfTasks>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxTaskGetNumberOfTasks( void )
{
    3c5c:	df 93       	push	r29
    3c5e:	cf 93       	push	r28
    3c60:	cd b7       	in	r28, 0x3d	; 61
    3c62:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required because the variables are of type
	portBASE_TYPE. */
	return uxCurrentNumberOfTasks;
    3c64:	80 91 95 06 	lds	r24, 0x0695
}
    3c68:	cf 91       	pop	r28
    3c6a:	df 91       	pop	r29
    3c6c:	08 95       	ret

00003c6e <vTaskIncrementTick>:
 * SCHEDULER INTERNALS AVAILABLE FOR PORTING PURPOSES
 * documented in task.h
 *----------------------------------------------------------*/

void vTaskIncrementTick( void )
{
    3c6e:	df 93       	push	r29
    3c70:	cf 93       	push	r28
    3c72:	00 d0       	rcall	.+0      	; 0x3c74 <vTaskIncrementTick+0x6>
    3c74:	00 d0       	rcall	.+0      	; 0x3c76 <vTaskIncrementTick+0x8>
    3c76:	00 d0       	rcall	.+0      	; 0x3c78 <vTaskIncrementTick+0xa>
    3c78:	cd b7       	in	r28, 0x3d	; 61
    3c7a:	de b7       	in	r29, 0x3e	; 62
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    3c7c:	80 91 9b 06 	lds	r24, 0x069B
    3c80:	88 23       	and	r24, r24
    3c82:	09 f0       	breq	.+2      	; 0x3c86 <vTaskIncrementTick+0x18>
    3c84:	bb c0       	rjmp	.+374    	; 0x3dfc <vTaskIncrementTick+0x18e>
	{
		++xTickCount;
    3c86:	80 91 96 06 	lds	r24, 0x0696
    3c8a:	90 91 97 06 	lds	r25, 0x0697
    3c8e:	01 96       	adiw	r24, 0x01	; 1
    3c90:	90 93 97 06 	sts	0x0697, r25
    3c94:	80 93 96 06 	sts	0x0696, r24
		if( xTickCount == ( portTickType ) 0U )
    3c98:	80 91 96 06 	lds	r24, 0x0696
    3c9c:	90 91 97 06 	lds	r25, 0x0697
    3ca0:	00 97       	sbiw	r24, 0x00	; 0
    3ca2:	d1 f5       	brne	.+116    	; 0x3d18 <vTaskIncrementTick+0xaa>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );
			
			pxTemp = pxDelayedTaskList;
    3ca4:	80 91 df 06 	lds	r24, 0x06DF
    3ca8:	90 91 e0 06 	lds	r25, 0x06E0
    3cac:	9c 83       	std	Y+4, r25	; 0x04
    3cae:	8b 83       	std	Y+3, r24	; 0x03
			pxDelayedTaskList = pxOverflowDelayedTaskList;
    3cb0:	80 91 e1 06 	lds	r24, 0x06E1
    3cb4:	90 91 e2 06 	lds	r25, 0x06E2
    3cb8:	90 93 e0 06 	sts	0x06E0, r25
    3cbc:	80 93 df 06 	sts	0x06DF, r24
			pxOverflowDelayedTaskList = pxTemp;
    3cc0:	8b 81       	ldd	r24, Y+3	; 0x03
    3cc2:	9c 81       	ldd	r25, Y+4	; 0x04
    3cc4:	90 93 e2 06 	sts	0x06E2, r25
    3cc8:	80 93 e1 06 	sts	0x06E1, r24
			xNumOfOverflows++;
    3ccc:	80 91 9e 06 	lds	r24, 0x069E
    3cd0:	8f 5f       	subi	r24, 0xFF	; 255
    3cd2:	80 93 9e 06 	sts	0x069E, r24
	
			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    3cd6:	e0 91 df 06 	lds	r30, 0x06DF
    3cda:	f0 91 e0 06 	lds	r31, 0x06E0
    3cde:	80 81       	ld	r24, Z
    3ce0:	88 23       	and	r24, r24
    3ce2:	39 f4       	brne	.+14     	; 0x3cf2 <vTaskIncrementTick+0x84>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the	
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
    3ce4:	8f ef       	ldi	r24, 0xFF	; 255
    3ce6:	9f ef       	ldi	r25, 0xFF	; 255
    3ce8:	90 93 78 00 	sts	0x0078, r25
    3cec:	80 93 77 00 	sts	0x0077, r24
    3cf0:	13 c0       	rjmp	.+38     	; 0x3d18 <vTaskIncrementTick+0xaa>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    3cf2:	e0 91 df 06 	lds	r30, 0x06DF
    3cf6:	f0 91 e0 06 	lds	r31, 0x06E0
    3cfa:	05 80       	ldd	r0, Z+5	; 0x05
    3cfc:	f6 81       	ldd	r31, Z+6	; 0x06
    3cfe:	e0 2d       	mov	r30, r0
    3d00:	86 81       	ldd	r24, Z+6	; 0x06
    3d02:	97 81       	ldd	r25, Z+7	; 0x07
    3d04:	9e 83       	std	Y+6, r25	; 0x06
    3d06:	8d 83       	std	Y+5, r24	; 0x05
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
    3d08:	ed 81       	ldd	r30, Y+5	; 0x05
    3d0a:	fe 81       	ldd	r31, Y+6	; 0x06
    3d0c:	82 81       	ldd	r24, Z+2	; 0x02
    3d0e:	93 81       	ldd	r25, Z+3	; 0x03
    3d10:	90 93 78 00 	sts	0x0078, r25
    3d14:	80 93 77 00 	sts	0x0077, r24
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
    3d18:	20 91 96 06 	lds	r18, 0x0696
    3d1c:	30 91 97 06 	lds	r19, 0x0697
    3d20:	80 91 77 00 	lds	r24, 0x0077
    3d24:	90 91 78 00 	lds	r25, 0x0078
    3d28:	28 17       	cp	r18, r24
    3d2a:	39 07       	cpc	r19, r25
    3d2c:	08 f4       	brcc	.+2      	; 0x3d30 <vTaskIncrementTick+0xc2>
    3d2e:	6b c0       	rjmp	.+214    	; 0x3e06 <vTaskIncrementTick+0x198>
    3d30:	e0 91 df 06 	lds	r30, 0x06DF
    3d34:	f0 91 e0 06 	lds	r31, 0x06E0
    3d38:	80 81       	ld	r24, Z
    3d3a:	88 23       	and	r24, r24
    3d3c:	39 f4       	brne	.+14     	; 0x3d4c <vTaskIncrementTick+0xde>
    3d3e:	8f ef       	ldi	r24, 0xFF	; 255
    3d40:	9f ef       	ldi	r25, 0xFF	; 255
    3d42:	90 93 78 00 	sts	0x0078, r25
    3d46:	80 93 77 00 	sts	0x0077, r24
    3d4a:	5d c0       	rjmp	.+186    	; 0x3e06 <vTaskIncrementTick+0x198>
    3d4c:	e0 91 df 06 	lds	r30, 0x06DF
    3d50:	f0 91 e0 06 	lds	r31, 0x06E0
    3d54:	05 80       	ldd	r0, Z+5	; 0x05
    3d56:	f6 81       	ldd	r31, Z+6	; 0x06
    3d58:	e0 2d       	mov	r30, r0
    3d5a:	86 81       	ldd	r24, Z+6	; 0x06
    3d5c:	97 81       	ldd	r25, Z+7	; 0x07
    3d5e:	9e 83       	std	Y+6, r25	; 0x06
    3d60:	8d 83       	std	Y+5, r24	; 0x05
    3d62:	ed 81       	ldd	r30, Y+5	; 0x05
    3d64:	fe 81       	ldd	r31, Y+6	; 0x06
    3d66:	82 81       	ldd	r24, Z+2	; 0x02
    3d68:	93 81       	ldd	r25, Z+3	; 0x03
    3d6a:	9a 83       	std	Y+2, r25	; 0x02
    3d6c:	89 83       	std	Y+1, r24	; 0x01
    3d6e:	20 91 96 06 	lds	r18, 0x0696
    3d72:	30 91 97 06 	lds	r19, 0x0697
    3d76:	89 81       	ldd	r24, Y+1	; 0x01
    3d78:	9a 81       	ldd	r25, Y+2	; 0x02
    3d7a:	28 17       	cp	r18, r24
    3d7c:	39 07       	cpc	r19, r25
    3d7e:	38 f4       	brcc	.+14     	; 0x3d8e <vTaskIncrementTick+0x120>
    3d80:	89 81       	ldd	r24, Y+1	; 0x01
    3d82:	9a 81       	ldd	r25, Y+2	; 0x02
    3d84:	90 93 78 00 	sts	0x0078, r25
    3d88:	80 93 77 00 	sts	0x0077, r24
    3d8c:	3c c0       	rjmp	.+120    	; 0x3e06 <vTaskIncrementTick+0x198>
    3d8e:	8d 81       	ldd	r24, Y+5	; 0x05
    3d90:	9e 81       	ldd	r25, Y+6	; 0x06
    3d92:	02 96       	adiw	r24, 0x02	; 2
    3d94:	0e 94 94 13 	call	0x2728	; 0x2728 <vListRemove>
    3d98:	ed 81       	ldd	r30, Y+5	; 0x05
    3d9a:	fe 81       	ldd	r31, Y+6	; 0x06
    3d9c:	84 89       	ldd	r24, Z+20	; 0x14
    3d9e:	95 89       	ldd	r25, Z+21	; 0x15
    3da0:	00 97       	sbiw	r24, 0x00	; 0
    3da2:	29 f0       	breq	.+10     	; 0x3dae <vTaskIncrementTick+0x140>
    3da4:	8d 81       	ldd	r24, Y+5	; 0x05
    3da6:	9e 81       	ldd	r25, Y+6	; 0x06
    3da8:	0c 96       	adiw	r24, 0x0c	; 12
    3daa:	0e 94 94 13 	call	0x2728	; 0x2728 <vListRemove>
    3dae:	ed 81       	ldd	r30, Y+5	; 0x05
    3db0:	fe 81       	ldd	r31, Y+6	; 0x06
    3db2:	96 89       	ldd	r25, Z+22	; 0x16
    3db4:	80 91 99 06 	lds	r24, 0x0699
    3db8:	89 17       	cp	r24, r25
    3dba:	28 f4       	brcc	.+10     	; 0x3dc6 <vTaskIncrementTick+0x158>
    3dbc:	ed 81       	ldd	r30, Y+5	; 0x05
    3dbe:	fe 81       	ldd	r31, Y+6	; 0x06
    3dc0:	86 89       	ldd	r24, Z+22	; 0x16
    3dc2:	80 93 99 06 	sts	0x0699, r24
    3dc6:	ed 81       	ldd	r30, Y+5	; 0x05
    3dc8:	fe 81       	ldd	r31, Y+6	; 0x06
    3dca:	86 89       	ldd	r24, Z+22	; 0x16
    3dcc:	28 2f       	mov	r18, r24
    3dce:	30 e0       	ldi	r19, 0x00	; 0
    3dd0:	c9 01       	movw	r24, r18
    3dd2:	88 0f       	add	r24, r24
    3dd4:	99 1f       	adc	r25, r25
    3dd6:	88 0f       	add	r24, r24
    3dd8:	99 1f       	adc	r25, r25
    3dda:	88 0f       	add	r24, r24
    3ddc:	99 1f       	adc	r25, r25
    3dde:	82 0f       	add	r24, r18
    3de0:	93 1f       	adc	r25, r19
    3de2:	ac 01       	movw	r20, r24
    3de4:	40 56       	subi	r20, 0x60	; 96
    3de6:	59 4f       	sbci	r21, 0xF9	; 249
    3de8:	8d 81       	ldd	r24, Y+5	; 0x05
    3dea:	9e 81       	ldd	r25, Y+6	; 0x06
    3dec:	9c 01       	movw	r18, r24
    3dee:	2e 5f       	subi	r18, 0xFE	; 254
    3df0:	3f 4f       	sbci	r19, 0xFF	; 255
    3df2:	ca 01       	movw	r24, r20
    3df4:	b9 01       	movw	r22, r18
    3df6:	0e 94 dc 12 	call	0x25b8	; 0x25b8 <vListInsertEnd>
    3dfa:	9a cf       	rjmp	.-204    	; 0x3d30 <vTaskIncrementTick+0xc2>
	}
	else
	{
		++uxMissedTicks;
    3dfc:	80 91 9c 06 	lds	r24, 0x069C
    3e00:	8f 5f       	subi	r24, 0xFF	; 255
    3e02:	80 93 9c 06 	sts	0x069C, r24
		}
	}
	#endif

	traceTASK_INCREMENT_TICK( xTickCount );
}
    3e06:	26 96       	adiw	r28, 0x06	; 6
    3e08:	0f b6       	in	r0, 0x3f	; 63
    3e0a:	f8 94       	cli
    3e0c:	de bf       	out	0x3e, r29	; 62
    3e0e:	0f be       	out	0x3f, r0	; 63
    3e10:	cd bf       	out	0x3d, r28	; 61
    3e12:	cf 91       	pop	r28
    3e14:	df 91       	pop	r29
    3e16:	08 95       	ret

00003e18 <vTaskSwitchContext>:

#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
    3e18:	df 93       	push	r29
    3e1a:	cf 93       	push	r28
    3e1c:	00 d0       	rcall	.+0      	; 0x3e1e <vTaskSwitchContext+0x6>
    3e1e:	cd b7       	in	r28, 0x3d	; 61
    3e20:	de b7       	in	r29, 0x3e	; 62
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
    3e22:	80 91 9b 06 	lds	r24, 0x069B
    3e26:	88 23       	and	r24, r24
    3e28:	49 f0       	breq	.+18     	; 0x3e3c <vTaskSwitchContext+0x24>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
    3e2a:	81 e0       	ldi	r24, 0x01	; 1
    3e2c:	80 93 9d 06 	sts	0x069D, r24
    3e30:	54 c0       	rjmp	.+168    	; 0x3eda <vTaskSwitchContext+0xc2>
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
    3e32:	80 91 99 06 	lds	r24, 0x0699
    3e36:	81 50       	subi	r24, 0x01	; 1
    3e38:	80 93 99 06 	sts	0x0699, r24
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    3e3c:	80 91 99 06 	lds	r24, 0x0699
    3e40:	28 2f       	mov	r18, r24
    3e42:	30 e0       	ldi	r19, 0x00	; 0
    3e44:	c9 01       	movw	r24, r18
    3e46:	88 0f       	add	r24, r24
    3e48:	99 1f       	adc	r25, r25
    3e4a:	88 0f       	add	r24, r24
    3e4c:	99 1f       	adc	r25, r25
    3e4e:	88 0f       	add	r24, r24
    3e50:	99 1f       	adc	r25, r25
    3e52:	82 0f       	add	r24, r18
    3e54:	93 1f       	adc	r25, r19
    3e56:	fc 01       	movw	r30, r24
    3e58:	e0 56       	subi	r30, 0x60	; 96
    3e5a:	f9 4f       	sbci	r31, 0xF9	; 249
    3e5c:	80 81       	ld	r24, Z
    3e5e:	88 23       	and	r24, r24
    3e60:	41 f3       	breq	.-48     	; 0x3e32 <vTaskSwitchContext+0x1a>
			--uxTopReadyPriority;
		}
	
		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
    3e62:	80 91 99 06 	lds	r24, 0x0699
    3e66:	28 2f       	mov	r18, r24
    3e68:	30 e0       	ldi	r19, 0x00	; 0
    3e6a:	c9 01       	movw	r24, r18
    3e6c:	88 0f       	add	r24, r24
    3e6e:	99 1f       	adc	r25, r25
    3e70:	88 0f       	add	r24, r24
    3e72:	99 1f       	adc	r25, r25
    3e74:	88 0f       	add	r24, r24
    3e76:	99 1f       	adc	r25, r25
    3e78:	82 0f       	add	r24, r18
    3e7a:	93 1f       	adc	r25, r19
    3e7c:	80 56       	subi	r24, 0x60	; 96
    3e7e:	99 4f       	sbci	r25, 0xF9	; 249
    3e80:	9a 83       	std	Y+2, r25	; 0x02
    3e82:	89 83       	std	Y+1, r24	; 0x01
    3e84:	e9 81       	ldd	r30, Y+1	; 0x01
    3e86:	fa 81       	ldd	r31, Y+2	; 0x02
    3e88:	01 80       	ldd	r0, Z+1	; 0x01
    3e8a:	f2 81       	ldd	r31, Z+2	; 0x02
    3e8c:	e0 2d       	mov	r30, r0
    3e8e:	82 81       	ldd	r24, Z+2	; 0x02
    3e90:	93 81       	ldd	r25, Z+3	; 0x03
    3e92:	e9 81       	ldd	r30, Y+1	; 0x01
    3e94:	fa 81       	ldd	r31, Y+2	; 0x02
    3e96:	92 83       	std	Z+2, r25	; 0x02
    3e98:	81 83       	std	Z+1, r24	; 0x01
    3e9a:	e9 81       	ldd	r30, Y+1	; 0x01
    3e9c:	fa 81       	ldd	r31, Y+2	; 0x02
    3e9e:	21 81       	ldd	r18, Z+1	; 0x01
    3ea0:	32 81       	ldd	r19, Z+2	; 0x02
    3ea2:	89 81       	ldd	r24, Y+1	; 0x01
    3ea4:	9a 81       	ldd	r25, Y+2	; 0x02
    3ea6:	03 96       	adiw	r24, 0x03	; 3
    3ea8:	28 17       	cp	r18, r24
    3eaa:	39 07       	cpc	r19, r25
    3eac:	59 f4       	brne	.+22     	; 0x3ec4 <vTaskSwitchContext+0xac>
    3eae:	e9 81       	ldd	r30, Y+1	; 0x01
    3eb0:	fa 81       	ldd	r31, Y+2	; 0x02
    3eb2:	01 80       	ldd	r0, Z+1	; 0x01
    3eb4:	f2 81       	ldd	r31, Z+2	; 0x02
    3eb6:	e0 2d       	mov	r30, r0
    3eb8:	82 81       	ldd	r24, Z+2	; 0x02
    3eba:	93 81       	ldd	r25, Z+3	; 0x03
    3ebc:	e9 81       	ldd	r30, Y+1	; 0x01
    3ebe:	fa 81       	ldd	r31, Y+2	; 0x02
    3ec0:	92 83       	std	Z+2, r25	; 0x02
    3ec2:	81 83       	std	Z+1, r24	; 0x01
    3ec4:	e9 81       	ldd	r30, Y+1	; 0x01
    3ec6:	fa 81       	ldd	r31, Y+2	; 0x02
    3ec8:	01 80       	ldd	r0, Z+1	; 0x01
    3eca:	f2 81       	ldd	r31, Z+2	; 0x02
    3ecc:	e0 2d       	mov	r30, r0
    3ece:	86 81       	ldd	r24, Z+6	; 0x06
    3ed0:	97 81       	ldd	r25, Z+7	; 0x07
    3ed2:	90 93 93 06 	sts	0x0693, r25
    3ed6:	80 93 92 06 	sts	0x0692, r24
	
		traceTASK_SWITCHED_IN();
		vWriteTraceToBuffer();
	}
}
    3eda:	0f 90       	pop	r0
    3edc:	0f 90       	pop	r0
    3ede:	cf 91       	pop	r28
    3ee0:	df 91       	pop	r29
    3ee2:	08 95       	ret

00003ee4 <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
    3ee4:	df 93       	push	r29
    3ee6:	cf 93       	push	r28
    3ee8:	00 d0       	rcall	.+0      	; 0x3eea <vTaskPlaceOnEventList+0x6>
    3eea:	00 d0       	rcall	.+0      	; 0x3eec <vTaskPlaceOnEventList+0x8>
    3eec:	00 d0       	rcall	.+0      	; 0x3eee <vTaskPlaceOnEventList+0xa>
    3eee:	cd b7       	in	r28, 0x3d	; 61
    3ef0:	de b7       	in	r29, 0x3e	; 62
    3ef2:	9c 83       	std	Y+4, r25	; 0x04
    3ef4:	8b 83       	std	Y+3, r24	; 0x03
    3ef6:	7e 83       	std	Y+6, r23	; 0x06
    3ef8:	6d 83       	std	Y+5, r22	; 0x05
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
    3efa:	4b 81       	ldd	r20, Y+3	; 0x03
    3efc:	5c 81       	ldd	r21, Y+4	; 0x04
    3efe:	80 91 92 06 	lds	r24, 0x0692
    3f02:	90 91 93 06 	lds	r25, 0x0693
    3f06:	9c 01       	movw	r18, r24
    3f08:	24 5f       	subi	r18, 0xF4	; 244
    3f0a:	3f 4f       	sbci	r19, 0xFF	; 255
    3f0c:	ca 01       	movw	r24, r20
    3f0e:	b9 01       	movw	r22, r18
    3f10:	0e 94 28 13 	call	0x2650	; 0x2650 <vListInsert>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    3f14:	80 91 92 06 	lds	r24, 0x0692
    3f18:	90 91 93 06 	lds	r25, 0x0693
    3f1c:	02 96       	adiw	r24, 0x02	; 2
    3f1e:	0e 94 94 13 	call	0x2728	; 0x2728 <vListRemove>
	}
	#else
	{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
    3f22:	20 91 96 06 	lds	r18, 0x0696
    3f26:	30 91 97 06 	lds	r19, 0x0697
    3f2a:	8d 81       	ldd	r24, Y+5	; 0x05
    3f2c:	9e 81       	ldd	r25, Y+6	; 0x06
    3f2e:	82 0f       	add	r24, r18
    3f30:	93 1f       	adc	r25, r19
    3f32:	9a 83       	std	Y+2, r25	; 0x02
    3f34:	89 83       	std	Y+1, r24	; 0x01
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    3f36:	89 81       	ldd	r24, Y+1	; 0x01
    3f38:	9a 81       	ldd	r25, Y+2	; 0x02
    3f3a:	0e 94 6c 21 	call	0x42d8	; 0x42d8 <prvAddCurrentTaskToDelayedList>
	}
	#endif
}
    3f3e:	26 96       	adiw	r28, 0x06	; 6
    3f40:	0f b6       	in	r0, 0x3f	; 63
    3f42:	f8 94       	cli
    3f44:	de bf       	out	0x3e, r29	; 62
    3f46:	0f be       	out	0x3f, r0	; 63
    3f48:	cd bf       	out	0x3d, r28	; 61
    3f4a:	cf 91       	pop	r28
    3f4c:	df 91       	pop	r29
    3f4e:	08 95       	ret

00003f50 <xTaskRemoveFromEventList>:
	
#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
    3f50:	df 93       	push	r29
    3f52:	cf 93       	push	r28
    3f54:	00 d0       	rcall	.+0      	; 0x3f56 <xTaskRemoveFromEventList+0x6>
    3f56:	00 d0       	rcall	.+0      	; 0x3f58 <xTaskRemoveFromEventList+0x8>
    3f58:	0f 92       	push	r0
    3f5a:	cd b7       	in	r28, 0x3d	; 61
    3f5c:	de b7       	in	r29, 0x3e	; 62
    3f5e:	9d 83       	std	Y+5, r25	; 0x05
    3f60:	8c 83       	std	Y+4, r24	; 0x04
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.
	
	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    3f62:	ec 81       	ldd	r30, Y+4	; 0x04
    3f64:	fd 81       	ldd	r31, Y+5	; 0x05
    3f66:	05 80       	ldd	r0, Z+5	; 0x05
    3f68:	f6 81       	ldd	r31, Z+6	; 0x06
    3f6a:	e0 2d       	mov	r30, r0
    3f6c:	86 81       	ldd	r24, Z+6	; 0x06
    3f6e:	97 81       	ldd	r25, Z+7	; 0x07
    3f70:	9b 83       	std	Y+3, r25	; 0x03
    3f72:	8a 83       	std	Y+2, r24	; 0x02
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
    3f74:	8a 81       	ldd	r24, Y+2	; 0x02
    3f76:	9b 81       	ldd	r25, Y+3	; 0x03
    3f78:	0c 96       	adiw	r24, 0x0c	; 12
    3f7a:	0e 94 94 13 	call	0x2728	; 0x2728 <vListRemove>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    3f7e:	80 91 9b 06 	lds	r24, 0x069B
    3f82:	88 23       	and	r24, r24
    3f84:	61 f5       	brne	.+88     	; 0x3fde <xTaskRemoveFromEventList+0x8e>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    3f86:	8a 81       	ldd	r24, Y+2	; 0x02
    3f88:	9b 81       	ldd	r25, Y+3	; 0x03
    3f8a:	02 96       	adiw	r24, 0x02	; 2
    3f8c:	0e 94 94 13 	call	0x2728	; 0x2728 <vListRemove>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
    3f90:	ea 81       	ldd	r30, Y+2	; 0x02
    3f92:	fb 81       	ldd	r31, Y+3	; 0x03
    3f94:	96 89       	ldd	r25, Z+22	; 0x16
    3f96:	80 91 99 06 	lds	r24, 0x0699
    3f9a:	89 17       	cp	r24, r25
    3f9c:	28 f4       	brcc	.+10     	; 0x3fa8 <xTaskRemoveFromEventList+0x58>
    3f9e:	ea 81       	ldd	r30, Y+2	; 0x02
    3fa0:	fb 81       	ldd	r31, Y+3	; 0x03
    3fa2:	86 89       	ldd	r24, Z+22	; 0x16
    3fa4:	80 93 99 06 	sts	0x0699, r24
    3fa8:	ea 81       	ldd	r30, Y+2	; 0x02
    3faa:	fb 81       	ldd	r31, Y+3	; 0x03
    3fac:	86 89       	ldd	r24, Z+22	; 0x16
    3fae:	28 2f       	mov	r18, r24
    3fb0:	30 e0       	ldi	r19, 0x00	; 0
    3fb2:	c9 01       	movw	r24, r18
    3fb4:	88 0f       	add	r24, r24
    3fb6:	99 1f       	adc	r25, r25
    3fb8:	88 0f       	add	r24, r24
    3fba:	99 1f       	adc	r25, r25
    3fbc:	88 0f       	add	r24, r24
    3fbe:	99 1f       	adc	r25, r25
    3fc0:	82 0f       	add	r24, r18
    3fc2:	93 1f       	adc	r25, r19
    3fc4:	ac 01       	movw	r20, r24
    3fc6:	40 56       	subi	r20, 0x60	; 96
    3fc8:	59 4f       	sbci	r21, 0xF9	; 249
    3fca:	8a 81       	ldd	r24, Y+2	; 0x02
    3fcc:	9b 81       	ldd	r25, Y+3	; 0x03
    3fce:	9c 01       	movw	r18, r24
    3fd0:	2e 5f       	subi	r18, 0xFE	; 254
    3fd2:	3f 4f       	sbci	r19, 0xFF	; 255
    3fd4:	ca 01       	movw	r24, r20
    3fd6:	b9 01       	movw	r22, r18
    3fd8:	0e 94 dc 12 	call	0x25b8	; 0x25b8 <vListInsertEnd>
    3fdc:	0a c0       	rjmp	.+20     	; 0x3ff2 <xTaskRemoveFromEventList+0xa2>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    3fde:	8a 81       	ldd	r24, Y+2	; 0x02
    3fe0:	9b 81       	ldd	r25, Y+3	; 0x03
    3fe2:	9c 01       	movw	r18, r24
    3fe4:	24 5f       	subi	r18, 0xF4	; 244
    3fe6:	3f 4f       	sbci	r19, 0xFF	; 255
    3fe8:	83 ee       	ldi	r24, 0xE3	; 227
    3fea:	96 e0       	ldi	r25, 0x06	; 6
    3fec:	b9 01       	movw	r22, r18
    3fee:	0e 94 dc 12 	call	0x25b8	; 0x25b8 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
    3ff2:	ea 81       	ldd	r30, Y+2	; 0x02
    3ff4:	fb 81       	ldd	r31, Y+3	; 0x03
    3ff6:	96 89       	ldd	r25, Z+22	; 0x16
    3ff8:	e0 91 92 06 	lds	r30, 0x0692
    3ffc:	f0 91 93 06 	lds	r31, 0x0693
    4000:	86 89       	ldd	r24, Z+22	; 0x16
    4002:	98 17       	cp	r25, r24
    4004:	18 f0       	brcs	.+6      	; 0x400c <xTaskRemoveFromEventList+0xbc>
	{
		/* Return true if the task removed from the event list has
		a higher priority than the calling task.  This allows
		the calling task to know if it should force a context
		switch now. */
		xReturn = pdTRUE;
    4006:	81 e0       	ldi	r24, 0x01	; 1
    4008:	89 83       	std	Y+1, r24	; 0x01
    400a:	01 c0       	rjmp	.+2      	; 0x400e <xTaskRemoveFromEventList+0xbe>
	}
	else
	{
		xReturn = pdFALSE;
    400c:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    400e:	89 81       	ldd	r24, Y+1	; 0x01
}
    4010:	0f 90       	pop	r0
    4012:	0f 90       	pop	r0
    4014:	0f 90       	pop	r0
    4016:	0f 90       	pop	r0
    4018:	0f 90       	pop	r0
    401a:	cf 91       	pop	r28
    401c:	df 91       	pop	r29
    401e:	08 95       	ret

00004020 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
    4020:	df 93       	push	r29
    4022:	cf 93       	push	r28
    4024:	00 d0       	rcall	.+0      	; 0x4026 <vTaskSetTimeOutState+0x6>
    4026:	cd b7       	in	r28, 0x3d	; 61
    4028:	de b7       	in	r29, 0x3e	; 62
    402a:	9a 83       	std	Y+2, r25	; 0x02
    402c:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    402e:	80 91 9e 06 	lds	r24, 0x069E
    4032:	e9 81       	ldd	r30, Y+1	; 0x01
    4034:	fa 81       	ldd	r31, Y+2	; 0x02
    4036:	80 83       	st	Z, r24
	pxTimeOut->xTimeOnEntering = xTickCount;
    4038:	80 91 96 06 	lds	r24, 0x0696
    403c:	90 91 97 06 	lds	r25, 0x0697
    4040:	e9 81       	ldd	r30, Y+1	; 0x01
    4042:	fa 81       	ldd	r31, Y+2	; 0x02
    4044:	92 83       	std	Z+2, r25	; 0x02
    4046:	81 83       	std	Z+1, r24	; 0x01
}
    4048:	0f 90       	pop	r0
    404a:	0f 90       	pop	r0
    404c:	cf 91       	pop	r28
    404e:	df 91       	pop	r29
    4050:	08 95       	ret

00004052 <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
    4052:	df 93       	push	r29
    4054:	cf 93       	push	r28
    4056:	00 d0       	rcall	.+0      	; 0x4058 <xTaskCheckForTimeOut+0x6>
    4058:	00 d0       	rcall	.+0      	; 0x405a <xTaskCheckForTimeOut+0x8>
    405a:	0f 92       	push	r0
    405c:	cd b7       	in	r28, 0x3d	; 61
    405e:	de b7       	in	r29, 0x3e	; 62
    4060:	9b 83       	std	Y+3, r25	; 0x03
    4062:	8a 83       	std	Y+2, r24	; 0x02
    4064:	7d 83       	std	Y+5, r23	; 0x05
    4066:	6c 83       	std	Y+4, r22	; 0x04
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    4068:	0f b6       	in	r0, 0x3f	; 63
    406a:	f8 94       	cli
    406c:	0f 92       	push	r0
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
    406e:	ea 81       	ldd	r30, Y+2	; 0x02
    4070:	fb 81       	ldd	r31, Y+3	; 0x03
    4072:	90 81       	ld	r25, Z
    4074:	80 91 9e 06 	lds	r24, 0x069E
    4078:	98 17       	cp	r25, r24
    407a:	71 f0       	breq	.+28     	; 0x4098 <xTaskCheckForTimeOut+0x46>
    407c:	ea 81       	ldd	r30, Y+2	; 0x02
    407e:	fb 81       	ldd	r31, Y+3	; 0x03
    4080:	21 81       	ldd	r18, Z+1	; 0x01
    4082:	32 81       	ldd	r19, Z+2	; 0x02
    4084:	80 91 96 06 	lds	r24, 0x0696
    4088:	90 91 97 06 	lds	r25, 0x0697
    408c:	82 17       	cp	r24, r18
    408e:	93 07       	cpc	r25, r19
    4090:	18 f0       	brcs	.+6      	; 0x4098 <xTaskCheckForTimeOut+0x46>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
    4092:	81 e0       	ldi	r24, 0x01	; 1
    4094:	89 83       	std	Y+1, r24	; 0x01
    4096:	2f c0       	rjmp	.+94     	; 0x40f6 <xTaskCheckForTimeOut+0xa4>
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
    4098:	20 91 96 06 	lds	r18, 0x0696
    409c:	30 91 97 06 	lds	r19, 0x0697
    40a0:	ea 81       	ldd	r30, Y+2	; 0x02
    40a2:	fb 81       	ldd	r31, Y+3	; 0x03
    40a4:	81 81       	ldd	r24, Z+1	; 0x01
    40a6:	92 81       	ldd	r25, Z+2	; 0x02
    40a8:	28 1b       	sub	r18, r24
    40aa:	39 0b       	sbc	r19, r25
    40ac:	ec 81       	ldd	r30, Y+4	; 0x04
    40ae:	fd 81       	ldd	r31, Y+5	; 0x05
    40b0:	80 81       	ld	r24, Z
    40b2:	91 81       	ldd	r25, Z+1	; 0x01
    40b4:	28 17       	cp	r18, r24
    40b6:	39 07       	cpc	r19, r25
    40b8:	e0 f4       	brcc	.+56     	; 0x40f2 <xTaskCheckForTimeOut+0xa0>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
    40ba:	ec 81       	ldd	r30, Y+4	; 0x04
    40bc:	fd 81       	ldd	r31, Y+5	; 0x05
    40be:	40 81       	ld	r20, Z
    40c0:	51 81       	ldd	r21, Z+1	; 0x01
    40c2:	ea 81       	ldd	r30, Y+2	; 0x02
    40c4:	fb 81       	ldd	r31, Y+3	; 0x03
    40c6:	21 81       	ldd	r18, Z+1	; 0x01
    40c8:	32 81       	ldd	r19, Z+2	; 0x02
    40ca:	80 91 96 06 	lds	r24, 0x0696
    40ce:	90 91 97 06 	lds	r25, 0x0697
    40d2:	b9 01       	movw	r22, r18
    40d4:	68 1b       	sub	r22, r24
    40d6:	79 0b       	sbc	r23, r25
    40d8:	cb 01       	movw	r24, r22
    40da:	84 0f       	add	r24, r20
    40dc:	95 1f       	adc	r25, r21
    40de:	ec 81       	ldd	r30, Y+4	; 0x04
    40e0:	fd 81       	ldd	r31, Y+5	; 0x05
    40e2:	91 83       	std	Z+1, r25	; 0x01
    40e4:	80 83       	st	Z, r24
			vTaskSetTimeOutState( pxTimeOut );
    40e6:	8a 81       	ldd	r24, Y+2	; 0x02
    40e8:	9b 81       	ldd	r25, Y+3	; 0x03
    40ea:	0e 94 10 20 	call	0x4020	; 0x4020 <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    40ee:	19 82       	std	Y+1, r1	; 0x01
    40f0:	02 c0       	rjmp	.+4      	; 0x40f6 <xTaskCheckForTimeOut+0xa4>
		}
		else
		{
			xReturn = pdTRUE;
    40f2:	81 e0       	ldi	r24, 0x01	; 1
    40f4:	89 83       	std	Y+1, r24	; 0x01
		}
	}
	taskEXIT_CRITICAL();
    40f6:	0f 90       	pop	r0
    40f8:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    40fa:	89 81       	ldd	r24, Y+1	; 0x01
}
    40fc:	0f 90       	pop	r0
    40fe:	0f 90       	pop	r0
    4100:	0f 90       	pop	r0
    4102:	0f 90       	pop	r0
    4104:	0f 90       	pop	r0
    4106:	cf 91       	pop	r28
    4108:	df 91       	pop	r29
    410a:	08 95       	ret

0000410c <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
    410c:	df 93       	push	r29
    410e:	cf 93       	push	r28
    4110:	cd b7       	in	r28, 0x3d	; 61
    4112:	de b7       	in	r29, 0x3e	; 62
	xMissedYield = pdTRUE;
    4114:	81 e0       	ldi	r24, 0x01	; 1
    4116:	80 93 9d 06 	sts	0x069D, r24
}
    411a:	cf 91       	pop	r28
    411c:	df 91       	pop	r29
    411e:	08 95       	ret

00004120 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
    4120:	df 93       	push	r29
    4122:	cf 93       	push	r28
    4124:	00 d0       	rcall	.+0      	; 0x4126 <prvIdleTask+0x6>
    4126:	cd b7       	in	r28, 0x3d	; 61
    4128:	de b7       	in	r29, 0x3e	; 62
    412a:	9a 83       	std	Y+2, r25	; 0x02
    412c:	89 83       	std	Y+1, r24	; 0x01
	( void ) pvParameters;

	for( ;; )
	{
		/* See if any tasks have been deleted. */
		prvCheckTasksWaitingTermination();
    412e:	0e 94 2e 21 	call	0x425c	; 0x425c <prvCheckTasksWaitingTermination>
    4132:	fd cf       	rjmp	.-6      	; 0x412e <prvIdleTask+0xe>

00004134 <prvInitialiseTCBVariables>:
 *----------------------------------------------------------*/



static void prvInitialiseTCBVariables( tskTCB *pxTCB, const signed char * const pcName, unsigned portBASE_TYPE uxPriority, const xMemoryRegion * const xRegions, unsigned short usStackDepth )
{
    4134:	0f 93       	push	r16
    4136:	1f 93       	push	r17
    4138:	df 93       	push	r29
    413a:	cf 93       	push	r28
    413c:	cd b7       	in	r28, 0x3d	; 61
    413e:	de b7       	in	r29, 0x3e	; 62
    4140:	29 97       	sbiw	r28, 0x09	; 9
    4142:	0f b6       	in	r0, 0x3f	; 63
    4144:	f8 94       	cli
    4146:	de bf       	out	0x3e, r29	; 62
    4148:	0f be       	out	0x3f, r0	; 63
    414a:	cd bf       	out	0x3d, r28	; 61
    414c:	9a 83       	std	Y+2, r25	; 0x02
    414e:	89 83       	std	Y+1, r24	; 0x01
    4150:	7c 83       	std	Y+4, r23	; 0x04
    4152:	6b 83       	std	Y+3, r22	; 0x03
    4154:	4d 83       	std	Y+5, r20	; 0x05
    4156:	3f 83       	std	Y+7, r19	; 0x07
    4158:	2e 83       	std	Y+6, r18	; 0x06
    415a:	19 87       	std	Y+9, r17	; 0x09
    415c:	08 87       	std	Y+8, r16	; 0x08
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
    415e:	89 81       	ldd	r24, Y+1	; 0x01
    4160:	9a 81       	ldd	r25, Y+2	; 0x02
    4162:	49 96       	adiw	r24, 0x19	; 25
    4164:	2b 81       	ldd	r18, Y+3	; 0x03
    4166:	3c 81       	ldd	r19, Y+4	; 0x04
    4168:	b9 01       	movw	r22, r18
    416a:	48 e0       	ldi	r20, 0x08	; 8
    416c:	50 e0       	ldi	r21, 0x00	; 0
    416e:	0e 94 a3 22 	call	0x4546	; 0x4546 <strncpy>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
    4172:	e9 81       	ldd	r30, Y+1	; 0x01
    4174:	fa 81       	ldd	r31, Y+2	; 0x02
    4176:	10 a2       	std	Z+32, r1	; 0x20

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	if( uxPriority >= configMAX_PRIORITIES )
    4178:	8d 81       	ldd	r24, Y+5	; 0x05
    417a:	85 30       	cpi	r24, 0x05	; 5
    417c:	10 f0       	brcs	.+4      	; 0x4182 <prvInitialiseTCBVariables+0x4e>
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
    417e:	84 e0       	ldi	r24, 0x04	; 4
    4180:	8d 83       	std	Y+5, r24	; 0x05
	}

	pxTCB->uxPriority = uxPriority;
    4182:	e9 81       	ldd	r30, Y+1	; 0x01
    4184:	fa 81       	ldd	r31, Y+2	; 0x02
    4186:	8d 81       	ldd	r24, Y+5	; 0x05
    4188:	86 8b       	std	Z+22, r24	; 0x16
	{
		pxTCB->uxBasePriority = uxPriority;
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
    418a:	89 81       	ldd	r24, Y+1	; 0x01
    418c:	9a 81       	ldd	r25, Y+2	; 0x02
    418e:	02 96       	adiw	r24, 0x02	; 2
    4190:	0e 94 cc 12 	call	0x2598	; 0x2598 <vListInitialiseItem>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
    4194:	89 81       	ldd	r24, Y+1	; 0x01
    4196:	9a 81       	ldd	r25, Y+2	; 0x02
    4198:	0c 96       	adiw	r24, 0x0c	; 12
    419a:	0e 94 cc 12 	call	0x2598	; 0x2598 <vListInitialiseItem>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
    419e:	e9 81       	ldd	r30, Y+1	; 0x01
    41a0:	fa 81       	ldd	r31, Y+2	; 0x02
    41a2:	89 81       	ldd	r24, Y+1	; 0x01
    41a4:	9a 81       	ldd	r25, Y+2	; 0x02
    41a6:	91 87       	std	Z+9, r25	; 0x09
    41a8:	80 87       	std	Z+8, r24	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
    41aa:	8d 81       	ldd	r24, Y+5	; 0x05
    41ac:	28 2f       	mov	r18, r24
    41ae:	30 e0       	ldi	r19, 0x00	; 0
    41b0:	85 e0       	ldi	r24, 0x05	; 5
    41b2:	90 e0       	ldi	r25, 0x00	; 0
    41b4:	82 1b       	sub	r24, r18
    41b6:	93 0b       	sbc	r25, r19
    41b8:	e9 81       	ldd	r30, Y+1	; 0x01
    41ba:	fa 81       	ldd	r31, Y+2	; 0x02
    41bc:	95 87       	std	Z+13, r25	; 0x0d
    41be:	84 87       	std	Z+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
    41c0:	e9 81       	ldd	r30, Y+1	; 0x01
    41c2:	fa 81       	ldd	r31, Y+2	; 0x02
    41c4:	89 81       	ldd	r24, Y+1	; 0x01
    41c6:	9a 81       	ldd	r25, Y+2	; 0x02
    41c8:	93 8b       	std	Z+19, r25	; 0x13
    41ca:	82 8b       	std	Z+18, r24	; 0x12
	{
		( void ) xRegions;
		( void ) usStackDepth;
	}
	#endif
}
    41cc:	29 96       	adiw	r28, 0x09	; 9
    41ce:	0f b6       	in	r0, 0x3f	; 63
    41d0:	f8 94       	cli
    41d2:	de bf       	out	0x3e, r29	; 62
    41d4:	0f be       	out	0x3f, r0	; 63
    41d6:	cd bf       	out	0x3d, r28	; 61
    41d8:	cf 91       	pop	r28
    41da:	df 91       	pop	r29
    41dc:	1f 91       	pop	r17
    41de:	0f 91       	pop	r16
    41e0:	08 95       	ret

000041e2 <prvInitialiseTaskLists>:
	}
	/*-----------------------------------------------------------*/
#endif

static void prvInitialiseTaskLists( void )
{
    41e2:	df 93       	push	r29
    41e4:	cf 93       	push	r28
    41e6:	0f 92       	push	r0
    41e8:	cd b7       	in	r28, 0x3d	; 61
    41ea:	de b7       	in	r29, 0x3e	; 62
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
    41ec:	19 82       	std	Y+1, r1	; 0x01
    41ee:	13 c0       	rjmp	.+38     	; 0x4216 <prvInitialiseTaskLists+0x34>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
    41f0:	89 81       	ldd	r24, Y+1	; 0x01
    41f2:	28 2f       	mov	r18, r24
    41f4:	30 e0       	ldi	r19, 0x00	; 0
    41f6:	c9 01       	movw	r24, r18
    41f8:	88 0f       	add	r24, r24
    41fa:	99 1f       	adc	r25, r25
    41fc:	88 0f       	add	r24, r24
    41fe:	99 1f       	adc	r25, r25
    4200:	88 0f       	add	r24, r24
    4202:	99 1f       	adc	r25, r25
    4204:	82 0f       	add	r24, r18
    4206:	93 1f       	adc	r25, r19
    4208:	80 56       	subi	r24, 0x60	; 96
    420a:	99 4f       	sbci	r25, 0xF9	; 249
    420c:	0e 94 a2 12 	call	0x2544	; 0x2544 <vListInitialise>

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
    4210:	89 81       	ldd	r24, Y+1	; 0x01
    4212:	8f 5f       	subi	r24, 0xFF	; 255
    4214:	89 83       	std	Y+1, r24	; 0x01
    4216:	89 81       	ldd	r24, Y+1	; 0x01
    4218:	85 30       	cpi	r24, 0x05	; 5
    421a:	50 f3       	brcs	.-44     	; 0x41f0 <prvInitialiseTaskLists+0xe>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
    421c:	8d ec       	ldi	r24, 0xCD	; 205
    421e:	96 e0       	ldi	r25, 0x06	; 6
    4220:	0e 94 a2 12 	call	0x2544	; 0x2544 <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
    4224:	86 ed       	ldi	r24, 0xD6	; 214
    4226:	96 e0       	ldi	r25, 0x06	; 6
    4228:	0e 94 a2 12 	call	0x2544	; 0x2544 <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyList );
    422c:	83 ee       	ldi	r24, 0xE3	; 227
    422e:	96 e0       	ldi	r25, 0x06	; 6
    4230:	0e 94 a2 12 	call	0x2544	; 0x2544 <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
    4234:	8c ee       	ldi	r24, 0xEC	; 236
    4236:	96 e0       	ldi	r25, 0x06	; 6
    4238:	0e 94 a2 12 	call	0x2544	; 0x2544 <vListInitialise>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    423c:	8d ec       	ldi	r24, 0xCD	; 205
    423e:	96 e0       	ldi	r25, 0x06	; 6
    4240:	90 93 e0 06 	sts	0x06E0, r25
    4244:	80 93 df 06 	sts	0x06DF, r24
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    4248:	86 ed       	ldi	r24, 0xD6	; 214
    424a:	96 e0       	ldi	r25, 0x06	; 6
    424c:	90 93 e2 06 	sts	0x06E2, r25
    4250:	80 93 e1 06 	sts	0x06E1, r24
}
    4254:	0f 90       	pop	r0
    4256:	cf 91       	pop	r28
    4258:	df 91       	pop	r29
    425a:	08 95       	ret

0000425c <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
    425c:	df 93       	push	r29
    425e:	cf 93       	push	r28
    4260:	00 d0       	rcall	.+0      	; 0x4262 <prvCheckTasksWaitingTermination+0x6>
    4262:	0f 92       	push	r0
    4264:	cd b7       	in	r28, 0x3d	; 61
    4266:	de b7       	in	r29, 0x3e	; 62
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
    4268:	80 91 94 06 	lds	r24, 0x0694
    426c:	88 23       	and	r24, r24
    426e:	71 f1       	breq	.+92     	; 0x42cc <prvCheckTasksWaitingTermination+0x70>
		{
			vTaskSuspendAll();
    4270:	0e 94 6c 1d 	call	0x3ad8	; 0x3ad8 <vTaskSuspendAll>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
    4274:	80 91 ec 06 	lds	r24, 0x06EC
    4278:	1b 82       	std	Y+3, r1	; 0x03
    427a:	88 23       	and	r24, r24
    427c:	11 f4       	brne	.+4      	; 0x4282 <prvCheckTasksWaitingTermination+0x26>
    427e:	81 e0       	ldi	r24, 0x01	; 1
    4280:	8b 83       	std	Y+3, r24	; 0x03
			xTaskResumeAll();
    4282:	0e 94 78 1d 	call	0x3af0	; 0x3af0 <xTaskResumeAll>

			if( xListIsEmpty == pdFALSE )
    4286:	8b 81       	ldd	r24, Y+3	; 0x03
    4288:	88 23       	and	r24, r24
    428a:	01 f5       	brne	.+64     	; 0x42cc <prvCheckTasksWaitingTermination+0x70>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
    428c:	0f b6       	in	r0, 0x3f	; 63
    428e:	f8 94       	cli
    4290:	0f 92       	push	r0
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
    4292:	e0 91 f1 06 	lds	r30, 0x06F1
    4296:	f0 91 f2 06 	lds	r31, 0x06F2
    429a:	86 81       	ldd	r24, Z+6	; 0x06
    429c:	97 81       	ldd	r25, Z+7	; 0x07
    429e:	9a 83       	std	Y+2, r25	; 0x02
    42a0:	89 83       	std	Y+1, r24	; 0x01
					vListRemove( &( pxTCB->xGenericListItem ) );
    42a2:	89 81       	ldd	r24, Y+1	; 0x01
    42a4:	9a 81       	ldd	r25, Y+2	; 0x02
    42a6:	02 96       	adiw	r24, 0x02	; 2
    42a8:	0e 94 94 13 	call	0x2728	; 0x2728 <vListRemove>
					--uxCurrentNumberOfTasks;
    42ac:	80 91 95 06 	lds	r24, 0x0695
    42b0:	81 50       	subi	r24, 0x01	; 1
    42b2:	80 93 95 06 	sts	0x0695, r24
					--uxTasksDeleted;
    42b6:	80 91 94 06 	lds	r24, 0x0694
    42ba:	81 50       	subi	r24, 0x01	; 1
    42bc:	80 93 94 06 	sts	0x0694, r24
				}
				taskEXIT_CRITICAL();
    42c0:	0f 90       	pop	r0
    42c2:	0f be       	out	0x3f, r0	; 63

				prvDeleteTCB( pxTCB );
    42c4:	89 81       	ldd	r24, Y+1	; 0x01
    42c6:	9a 81       	ldd	r25, Y+2	; 0x02
    42c8:	0e 94 05 22 	call	0x440a	; 0x440a <prvDeleteTCB>
			}
		}
	}
	#endif
}
    42cc:	0f 90       	pop	r0
    42ce:	0f 90       	pop	r0
    42d0:	0f 90       	pop	r0
    42d2:	cf 91       	pop	r28
    42d4:	df 91       	pop	r29
    42d6:	08 95       	ret

000042d8 <prvAddCurrentTaskToDelayedList>:
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
    42d8:	df 93       	push	r29
    42da:	cf 93       	push	r28
    42dc:	00 d0       	rcall	.+0      	; 0x42de <prvAddCurrentTaskToDelayedList+0x6>
    42de:	cd b7       	in	r28, 0x3d	; 61
    42e0:	de b7       	in	r29, 0x3e	; 62
    42e2:	9a 83       	std	Y+2, r25	; 0x02
    42e4:	89 83       	std	Y+1, r24	; 0x01
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
    42e6:	e0 91 92 06 	lds	r30, 0x0692
    42ea:	f0 91 93 06 	lds	r31, 0x0693
    42ee:	89 81       	ldd	r24, Y+1	; 0x01
    42f0:	9a 81       	ldd	r25, Y+2	; 0x02
    42f2:	93 83       	std	Z+3, r25	; 0x03
    42f4:	82 83       	std	Z+2, r24	; 0x02

	if( xTimeToWake < xTickCount )
    42f6:	20 91 96 06 	lds	r18, 0x0696
    42fa:	30 91 97 06 	lds	r19, 0x0697
    42fe:	89 81       	ldd	r24, Y+1	; 0x01
    4300:	9a 81       	ldd	r25, Y+2	; 0x02
    4302:	82 17       	cp	r24, r18
    4304:	93 07       	cpc	r25, r19
    4306:	70 f4       	brcc	.+28     	; 0x4324 <prvAddCurrentTaskToDelayedList+0x4c>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    4308:	80 91 e1 06 	lds	r24, 0x06E1
    430c:	90 91 e2 06 	lds	r25, 0x06E2
    4310:	20 91 92 06 	lds	r18, 0x0692
    4314:	30 91 93 06 	lds	r19, 0x0693
    4318:	2e 5f       	subi	r18, 0xFE	; 254
    431a:	3f 4f       	sbci	r19, 0xFF	; 255
    431c:	b9 01       	movw	r22, r18
    431e:	0e 94 28 13 	call	0x2650	; 0x2650 <vListInsert>
    4322:	1e c0       	rjmp	.+60     	; 0x4360 <prvAddCurrentTaskToDelayedList+0x88>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    4324:	40 91 df 06 	lds	r20, 0x06DF
    4328:	50 91 e0 06 	lds	r21, 0x06E0
    432c:	80 91 92 06 	lds	r24, 0x0692
    4330:	90 91 93 06 	lds	r25, 0x0693
    4334:	9c 01       	movw	r18, r24
    4336:	2e 5f       	subi	r18, 0xFE	; 254
    4338:	3f 4f       	sbci	r19, 0xFF	; 255
    433a:	ca 01       	movw	r24, r20
    433c:	b9 01       	movw	r22, r18
    433e:	0e 94 28 13 	call	0x2650	; 0x2650 <vListInsert>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
    4342:	20 91 77 00 	lds	r18, 0x0077
    4346:	30 91 78 00 	lds	r19, 0x0078
    434a:	89 81       	ldd	r24, Y+1	; 0x01
    434c:	9a 81       	ldd	r25, Y+2	; 0x02
    434e:	82 17       	cp	r24, r18
    4350:	93 07       	cpc	r25, r19
    4352:	30 f4       	brcc	.+12     	; 0x4360 <prvAddCurrentTaskToDelayedList+0x88>
		{
			xNextTaskUnblockTime = xTimeToWake;
    4354:	89 81       	ldd	r24, Y+1	; 0x01
    4356:	9a 81       	ldd	r25, Y+2	; 0x02
    4358:	90 93 78 00 	sts	0x0078, r25
    435c:	80 93 77 00 	sts	0x0077, r24
		}
	}
}
    4360:	0f 90       	pop	r0
    4362:	0f 90       	pop	r0
    4364:	cf 91       	pop	r28
    4366:	df 91       	pop	r29
    4368:	08 95       	ret

0000436a <prvAllocateTCBAndStack>:
/*-----------------------------------------------------------*/

static tskTCB *prvAllocateTCBAndStack( unsigned short usStackDepth, portSTACK_TYPE *puxStackBuffer )
{
    436a:	df 93       	push	r29
    436c:	cf 93       	push	r28
    436e:	cd b7       	in	r28, 0x3d	; 61
    4370:	de b7       	in	r29, 0x3e	; 62
    4372:	28 97       	sbiw	r28, 0x08	; 8
    4374:	0f b6       	in	r0, 0x3f	; 63
    4376:	f8 94       	cli
    4378:	de bf       	out	0x3e, r29	; 62
    437a:	0f be       	out	0x3f, r0	; 63
    437c:	cd bf       	out	0x3d, r28	; 61
    437e:	9c 83       	std	Y+4, r25	; 0x04
    4380:	8b 83       	std	Y+3, r24	; 0x03
    4382:	7e 83       	std	Y+6, r23	; 0x06
    4384:	6d 83       	std	Y+5, r22	; 0x05
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
    4386:	81 e2       	ldi	r24, 0x21	; 33
    4388:	90 e0       	ldi	r25, 0x00	; 0
    438a:	0e 94 36 12 	call	0x246c	; 0x246c <pvPortMalloc>
    438e:	9a 83       	std	Y+2, r25	; 0x02
    4390:	89 83       	std	Y+1, r24	; 0x01

	if( pxNewTCB != NULL )
    4392:	89 81       	ldd	r24, Y+1	; 0x01
    4394:	9a 81       	ldd	r25, Y+2	; 0x02
    4396:	00 97       	sbiw	r24, 0x00	; 0
    4398:	69 f1       	breq	.+90     	; 0x43f4 <prvAllocateTCBAndStack+0x8a>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
    439a:	8d 81       	ldd	r24, Y+5	; 0x05
    439c:	9e 81       	ldd	r25, Y+6	; 0x06
    439e:	00 97       	sbiw	r24, 0x00	; 0
    43a0:	39 f4       	brne	.+14     	; 0x43b0 <prvAllocateTCBAndStack+0x46>
    43a2:	8b 81       	ldd	r24, Y+3	; 0x03
    43a4:	9c 81       	ldd	r25, Y+4	; 0x04
    43a6:	0e 94 36 12 	call	0x246c	; 0x246c <pvPortMalloc>
    43aa:	98 87       	std	Y+8, r25	; 0x08
    43ac:	8f 83       	std	Y+7, r24	; 0x07
    43ae:	04 c0       	rjmp	.+8      	; 0x43b8 <prvAllocateTCBAndStack+0x4e>
    43b0:	8d 81       	ldd	r24, Y+5	; 0x05
    43b2:	9e 81       	ldd	r25, Y+6	; 0x06
    43b4:	98 87       	std	Y+8, r25	; 0x08
    43b6:	8f 83       	std	Y+7, r24	; 0x07
    43b8:	e9 81       	ldd	r30, Y+1	; 0x01
    43ba:	fa 81       	ldd	r31, Y+2	; 0x02
    43bc:	8f 81       	ldd	r24, Y+7	; 0x07
    43be:	98 85       	ldd	r25, Y+8	; 0x08
    43c0:	90 8f       	std	Z+24, r25	; 0x18
    43c2:	87 8b       	std	Z+23, r24	; 0x17

		if( pxNewTCB->pxStack == NULL )
    43c4:	e9 81       	ldd	r30, Y+1	; 0x01
    43c6:	fa 81       	ldd	r31, Y+2	; 0x02
    43c8:	87 89       	ldd	r24, Z+23	; 0x17
    43ca:	90 8d       	ldd	r25, Z+24	; 0x18
    43cc:	00 97       	sbiw	r24, 0x00	; 0
    43ce:	39 f4       	brne	.+14     	; 0x43de <prvAllocateTCBAndStack+0x74>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
    43d0:	89 81       	ldd	r24, Y+1	; 0x01
    43d2:	9a 81       	ldd	r25, Y+2	; 0x02
    43d4:	0e 94 7c 12 	call	0x24f8	; 0x24f8 <vPortFree>
			pxNewTCB = NULL;
    43d8:	1a 82       	std	Y+2, r1	; 0x02
    43da:	19 82       	std	Y+1, r1	; 0x01
    43dc:	0b c0       	rjmp	.+22     	; 0x43f4 <prvAllocateTCBAndStack+0x8a>
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) usStackDepth * sizeof( portSTACK_TYPE ) );
    43de:	e9 81       	ldd	r30, Y+1	; 0x01
    43e0:	fa 81       	ldd	r31, Y+2	; 0x02
    43e2:	87 89       	ldd	r24, Z+23	; 0x17
    43e4:	90 8d       	ldd	r25, Z+24	; 0x18
    43e6:	2b 81       	ldd	r18, Y+3	; 0x03
    43e8:	3c 81       	ldd	r19, Y+4	; 0x04
    43ea:	65 ea       	ldi	r22, 0xA5	; 165
    43ec:	70 e0       	ldi	r23, 0x00	; 0
    43ee:	a9 01       	movw	r20, r18
    43f0:	0e 94 9c 22 	call	0x4538	; 0x4538 <memset>
		}
	}

	return pxNewTCB;
    43f4:	89 81       	ldd	r24, Y+1	; 0x01
    43f6:	9a 81       	ldd	r25, Y+2	; 0x02
}
    43f8:	28 96       	adiw	r28, 0x08	; 8
    43fa:	0f b6       	in	r0, 0x3f	; 63
    43fc:	f8 94       	cli
    43fe:	de bf       	out	0x3e, r29	; 62
    4400:	0f be       	out	0x3f, r0	; 63
    4402:	cd bf       	out	0x3d, r28	; 61
    4404:	cf 91       	pop	r28
    4406:	df 91       	pop	r29
    4408:	08 95       	ret

0000440a <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
    440a:	df 93       	push	r29
    440c:	cf 93       	push	r28
    440e:	00 d0       	rcall	.+0      	; 0x4410 <prvDeleteTCB+0x6>
    4410:	cd b7       	in	r28, 0x3d	; 61
    4412:	de b7       	in	r29, 0x3e	; 62
    4414:	9a 83       	std	Y+2, r25	; 0x02
    4416:	89 83       	std	Y+1, r24	; 0x01
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
    4418:	e9 81       	ldd	r30, Y+1	; 0x01
    441a:	fa 81       	ldd	r31, Y+2	; 0x02
    441c:	87 89       	ldd	r24, Z+23	; 0x17
    441e:	90 8d       	ldd	r25, Z+24	; 0x18
    4420:	0e 94 7c 12 	call	0x24f8	; 0x24f8 <vPortFree>
		vPortFree( pxTCB );
    4424:	89 81       	ldd	r24, Y+1	; 0x01
    4426:	9a 81       	ldd	r25, Y+2	; 0x02
    4428:	0e 94 7c 12 	call	0x24f8	; 0x24f8 <vPortFree>
	}
    442c:	0f 90       	pop	r0
    442e:	0f 90       	pop	r0
    4430:	cf 91       	pop	r28
    4432:	df 91       	pop	r29
    4434:	08 95       	ret

00004436 <__mulsi3>:
    4436:	62 9f       	mul	r22, r18
    4438:	d0 01       	movw	r26, r0
    443a:	73 9f       	mul	r23, r19
    443c:	f0 01       	movw	r30, r0
    443e:	82 9f       	mul	r24, r18
    4440:	e0 0d       	add	r30, r0
    4442:	f1 1d       	adc	r31, r1
    4444:	64 9f       	mul	r22, r20
    4446:	e0 0d       	add	r30, r0
    4448:	f1 1d       	adc	r31, r1
    444a:	92 9f       	mul	r25, r18
    444c:	f0 0d       	add	r31, r0
    444e:	83 9f       	mul	r24, r19
    4450:	f0 0d       	add	r31, r0
    4452:	74 9f       	mul	r23, r20
    4454:	f0 0d       	add	r31, r0
    4456:	65 9f       	mul	r22, r21
    4458:	f0 0d       	add	r31, r0
    445a:	99 27       	eor	r25, r25
    445c:	72 9f       	mul	r23, r18
    445e:	b0 0d       	add	r27, r0
    4460:	e1 1d       	adc	r30, r1
    4462:	f9 1f       	adc	r31, r25
    4464:	63 9f       	mul	r22, r19
    4466:	b0 0d       	add	r27, r0
    4468:	e1 1d       	adc	r30, r1
    446a:	f9 1f       	adc	r31, r25
    446c:	bd 01       	movw	r22, r26
    446e:	cf 01       	movw	r24, r30
    4470:	11 24       	eor	r1, r1
    4472:	08 95       	ret

00004474 <__udivmodsi4>:
    4474:	a1 e2       	ldi	r26, 0x21	; 33
    4476:	1a 2e       	mov	r1, r26
    4478:	aa 1b       	sub	r26, r26
    447a:	bb 1b       	sub	r27, r27
    447c:	fd 01       	movw	r30, r26
    447e:	0d c0       	rjmp	.+26     	; 0x449a <__udivmodsi4_ep>

00004480 <__udivmodsi4_loop>:
    4480:	aa 1f       	adc	r26, r26
    4482:	bb 1f       	adc	r27, r27
    4484:	ee 1f       	adc	r30, r30
    4486:	ff 1f       	adc	r31, r31
    4488:	a2 17       	cp	r26, r18
    448a:	b3 07       	cpc	r27, r19
    448c:	e4 07       	cpc	r30, r20
    448e:	f5 07       	cpc	r31, r21
    4490:	20 f0       	brcs	.+8      	; 0x449a <__udivmodsi4_ep>
    4492:	a2 1b       	sub	r26, r18
    4494:	b3 0b       	sbc	r27, r19
    4496:	e4 0b       	sbc	r30, r20
    4498:	f5 0b       	sbc	r31, r21

0000449a <__udivmodsi4_ep>:
    449a:	66 1f       	adc	r22, r22
    449c:	77 1f       	adc	r23, r23
    449e:	88 1f       	adc	r24, r24
    44a0:	99 1f       	adc	r25, r25
    44a2:	1a 94       	dec	r1
    44a4:	69 f7       	brne	.-38     	; 0x4480 <__udivmodsi4_loop>
    44a6:	60 95       	com	r22
    44a8:	70 95       	com	r23
    44aa:	80 95       	com	r24
    44ac:	90 95       	com	r25
    44ae:	9b 01       	movw	r18, r22
    44b0:	ac 01       	movw	r20, r24
    44b2:	bd 01       	movw	r22, r26
    44b4:	cf 01       	movw	r24, r30
    44b6:	08 95       	ret

000044b8 <__prologue_saves__>:
    44b8:	2f 92       	push	r2
    44ba:	3f 92       	push	r3
    44bc:	4f 92       	push	r4
    44be:	5f 92       	push	r5
    44c0:	6f 92       	push	r6
    44c2:	7f 92       	push	r7
    44c4:	8f 92       	push	r8
    44c6:	9f 92       	push	r9
    44c8:	af 92       	push	r10
    44ca:	bf 92       	push	r11
    44cc:	cf 92       	push	r12
    44ce:	df 92       	push	r13
    44d0:	ef 92       	push	r14
    44d2:	ff 92       	push	r15
    44d4:	0f 93       	push	r16
    44d6:	1f 93       	push	r17
    44d8:	cf 93       	push	r28
    44da:	df 93       	push	r29
    44dc:	cd b7       	in	r28, 0x3d	; 61
    44de:	de b7       	in	r29, 0x3e	; 62
    44e0:	ca 1b       	sub	r28, r26
    44e2:	db 0b       	sbc	r29, r27
    44e4:	0f b6       	in	r0, 0x3f	; 63
    44e6:	f8 94       	cli
    44e8:	de bf       	out	0x3e, r29	; 62
    44ea:	0f be       	out	0x3f, r0	; 63
    44ec:	cd bf       	out	0x3d, r28	; 61
    44ee:	09 94       	ijmp

000044f0 <__epilogue_restores__>:
    44f0:	2a 88       	ldd	r2, Y+18	; 0x12
    44f2:	39 88       	ldd	r3, Y+17	; 0x11
    44f4:	48 88       	ldd	r4, Y+16	; 0x10
    44f6:	5f 84       	ldd	r5, Y+15	; 0x0f
    44f8:	6e 84       	ldd	r6, Y+14	; 0x0e
    44fa:	7d 84       	ldd	r7, Y+13	; 0x0d
    44fc:	8c 84       	ldd	r8, Y+12	; 0x0c
    44fe:	9b 84       	ldd	r9, Y+11	; 0x0b
    4500:	aa 84       	ldd	r10, Y+10	; 0x0a
    4502:	b9 84       	ldd	r11, Y+9	; 0x09
    4504:	c8 84       	ldd	r12, Y+8	; 0x08
    4506:	df 80       	ldd	r13, Y+7	; 0x07
    4508:	ee 80       	ldd	r14, Y+6	; 0x06
    450a:	fd 80       	ldd	r15, Y+5	; 0x05
    450c:	0c 81       	ldd	r16, Y+4	; 0x04
    450e:	1b 81       	ldd	r17, Y+3	; 0x03
    4510:	aa 81       	ldd	r26, Y+2	; 0x02
    4512:	b9 81       	ldd	r27, Y+1	; 0x01
    4514:	ce 0f       	add	r28, r30
    4516:	d1 1d       	adc	r29, r1
    4518:	0f b6       	in	r0, 0x3f	; 63
    451a:	f8 94       	cli
    451c:	de bf       	out	0x3e, r29	; 62
    451e:	0f be       	out	0x3f, r0	; 63
    4520:	cd bf       	out	0x3d, r28	; 61
    4522:	ed 01       	movw	r28, r26
    4524:	08 95       	ret

00004526 <memcpy>:
    4526:	fb 01       	movw	r30, r22
    4528:	dc 01       	movw	r26, r24
    452a:	02 c0       	rjmp	.+4      	; 0x4530 <memcpy+0xa>
    452c:	01 90       	ld	r0, Z+
    452e:	0d 92       	st	X+, r0
    4530:	41 50       	subi	r20, 0x01	; 1
    4532:	50 40       	sbci	r21, 0x00	; 0
    4534:	d8 f7       	brcc	.-10     	; 0x452c <memcpy+0x6>
    4536:	08 95       	ret

00004538 <memset>:
    4538:	dc 01       	movw	r26, r24
    453a:	01 c0       	rjmp	.+2      	; 0x453e <memset+0x6>
    453c:	6d 93       	st	X+, r22
    453e:	41 50       	subi	r20, 0x01	; 1
    4540:	50 40       	sbci	r21, 0x00	; 0
    4542:	e0 f7       	brcc	.-8      	; 0x453c <memset+0x4>
    4544:	08 95       	ret

00004546 <strncpy>:
    4546:	fb 01       	movw	r30, r22
    4548:	dc 01       	movw	r26, r24
    454a:	41 50       	subi	r20, 0x01	; 1
    454c:	50 40       	sbci	r21, 0x00	; 0
    454e:	48 f0       	brcs	.+18     	; 0x4562 <strncpy+0x1c>
    4550:	01 90       	ld	r0, Z+
    4552:	0d 92       	st	X+, r0
    4554:	00 20       	and	r0, r0
    4556:	c9 f7       	brne	.-14     	; 0x454a <strncpy+0x4>
    4558:	01 c0       	rjmp	.+2      	; 0x455c <strncpy+0x16>
    455a:	1d 92       	st	X+, r1
    455c:	41 50       	subi	r20, 0x01	; 1
    455e:	50 40       	sbci	r21, 0x00	; 0
    4560:	e0 f7       	brcc	.-8      	; 0x455a <strncpy+0x14>
    4562:	08 95       	ret

00004564 <_exit>:
    4564:	f8 94       	cli

00004566 <__stop_program>:
    4566:	ff cf       	rjmp	.-2      	; 0x4566 <__stop_program>
